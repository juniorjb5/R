<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Análisis de datos en R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Orlando Joaqui-Barandica" />
    <meta name="date" content="2022-01-01" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/rladies.css" rel="stylesheet" />
    <link href="libs/remark-css/rladies-fonts.css" rel="stylesheet" />
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link href="libs/animate.css/animate.xaringan.css" rel="stylesheet" />
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="libs/xaringanExtra-extra-styles/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <script src="libs/clipboard/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Click para copiar código","success":"Código copiado","error":"Ctrl+C para copiar"})</script>
    <script src="libs/freezeframe/freezeframe.min.js"></script>
    <script src="libs/xaringanExtra-freezeframe/freezeframe-init.js"></script>
    <script id="xaringanExtra-freezeframe-options" type="application/json">{"selector":"img[src$=\"gif\"]","trigger":"click","overlay":false,"responsive":false,"warnings":true}</script>
    <link href="libs/animate.css-xaringan/animate.fade.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <link href="libs/font-awesome/css/fontawesome-all.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">







class: inverse, left, bottom
background-image: url("img/back1.jpg")
background-size: cover


# **Análisis de datos en R**
----

## **Orlando Joaqui-Barandica**
### Orlando Joaqui-Barandica
### Universidad del Valle | 2022



---



class: inverse, middle, center
background-color: #C0392B


&lt;br&gt;&lt;br&gt;

.center[
&lt;img style="border-radius: 50%;" src="img/avatar.png"
width="160px" href="https://www.joaquibarandica.com"
/&gt;

### [PhD. Student. Orlando Joaqui-Barandica](https://www.joaquibarandica.com) &lt;br/&gt;
### Universidad del Valle
]

&lt;br&gt;


.center[

*PhD. Student in Engineering with emphasis in Engineering Industrial* 
 
*MSc. Applied Economics*
 
*BSc. Statistic*



<i class="fas  fa-link fa-spin "></i> [www.joaquibarandica.com](https://www.joaquibarandica.com)

]


---



class: inverse center middle

# PRESENTACIÓN DEL CURSO

&lt;img src="https://media.giphy.com/media/Ssltx68WIeX1wA0Mg8/giphy.gif" width="150%"/&gt;




.left[Pulsa &lt;kbd-black&gt;O&lt;/kbd-black&gt; para ver el panel de diapositivas]
.left[Pulsa &lt;kbd-black&gt;H&lt;/kbd-black&gt; para ver otros atajos]

---



# Objetivos




¡Bienvenidos!

Tomen asiento, entren a la secta del **software libre** y dejen a Excel en la entrada..

.pull-left[

El **objetivo** del curso no es ser un/a experimentado/a programador/a de `R`, sino adquirir los suficientes conocimientos como para lograr 5 objetivos:


- **Perder el miedo** a programar.
- Entender los [**conceptos básicos de R**](https://cran.rstudio.com/), lenguaje estadístico por excelencia, desde cero.
- Dotarnos de **autonomía en el análisis** de datos.
- Crear programas y flujos de trabajo **reproducibles** y mantenibles.
- Adquirir habilidades en la **visualización de datos** en `R` (haciendo uso también de otras herramientas como [**Datawrapper**](https://www.datawrapper.de/)), incluyendo la visualización de datos en **mapas**.

]

.pull-right[

&lt;img src="https://media.giphy.com/media/9ADoZQgs0tyww/giphy.gif"/&gt;

]



📚 Estas **diapositivas** han sido elaboradas con el propio `R` haciendo uso del paquete `{xaringan}`
y `{xaringanExtra}`.


---

class: inverse middle
background-color: #C0392B

### 👉 BLOQUE I. Introducción a R desde cero

* Instalación de R y RStudio. Primeros pasos. Tipos de datos.
* Datos estructurados: matrices y data.frame
* Extras: estructuras de control, proyectos


### 👉 BLOQUE II. Introducción a tidyverse

* Funciones
* Tibbles y tidy data
* Introducción a tidyverse. Relacionando datos (joins).

### 👉 BLOQUE III. Introducción al dataviz en R

* Dataviz: introducción histórica.
* Introducción a ggplot2
* Dataviz: la importancia de visualizar datos.
* Profundizando en ggplot2

### 👉 BLOQUE IV. Comunicando resultados

* Introducción a rmarkdown.




---

class: inverse center middle

# Bloque I: Introducción a R desde cero.

&amp;nbsp;

.left[

### 👉 [Instalación y primeros pasos](#instalacion-primeros-pasos)

### 👉 [Celdas: tipos de datos](#tipos-datos)

### 👉 [Columnas: vectores](#vectores)

### 👉 [Tablas: estructuras de datos](#matrices-dataframes)

### 👉 [Extras: estructuras de control](#estructuras)

]

---

name: instalacion-primeros-pasos
class: center, middle

# Instalación y primeros pasos

## **Instalación de R**

&amp;nbsp;

Programaremos como escribimos un libro: necesitamos una **gramática** (`R`) y un **Word** (`RStudio`).

---

# Requisitos del curso

Para el presente curso los únicos **requisitos** serán:

1. **Conexión a internet** (para la descarga de algunos datos y paquetes).

2. **Instalar R**: será nuestro **lenguaje**, nuestro **castellano** para poder «comunicarnos con el ordenador. La descarga la haremos (gratuitamente) desde &lt;https://cran.r-project.org/&gt;

3. **Instalar R Studio**. De la misma manera que podemos escribir castellano en un ordenador, en un Word, en un papel o en un tuit, podemos usar distintos IDE (entornos de desarrollo integrados, nuestro Office), para que el trabajo sea más cómodo. Nuestro **Word** para nosotros será **RStudio**.

.left[
  &lt;img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/cran-R.jpg" alt = "cran-R" align = "left" width = "500" style = "margin-top: 5vh"&gt;
]
.right[
  &lt;img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/R-studio.jpg" alt = "RStudio" align = "right" width = "500" style = "margin-top: 5vh;"&gt;
]

---

# Instalación de R

El **lenguaje de programación R** será nuestra **gramática**, nuestra ortografía y nuestro diccionario

&amp;nbsp;

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/pantalla1_cran.jpg" alt = "cran-R" align = "right" width = "500" style = "margin-top: 10vh;margin-right: 0.5rem;margin-left: 1rem;"&gt;

* **Paso 1**: entra en la [web oficial de R](https://cran.r-project.org/) y selecciona la instalación acorde a tu sistema operativo.

* **Paso 2**: para **Mac** basta con que hacer click en el archivo **.pkg**, y abrirlo una vez descargado. Para sistemas **Windows**, debemos clickar en `install R for the first time` y en la siguiente pantalla hacer click en `Download R for Windows`. Una vez descargado, **abrirlo como cualquier archivo de instalación**.

* **Paso 3**: abrir el **ejecutable** de tu escritorio o en tu Launchap (en Windows puede que tengas dos ejecutables i386 y x64, la versión de 32 y de 64 bits; haz click preferiblemente en el de x64).

---

# Primera operación

Para comprobar que se ha instalado correctamente, tras abrir `R`, deberías ver una **pantalla blanca** similar a esta (en realidad se llama **consola**)

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/cranR.jpg" alt = "consola" align = "left" width = "350" style = "margin-top: 5vh;margin-right: 3rem;"&gt;

Vamos a escribir **nuestra primera operación** en la consola:

* Una variable llamada `a` le asignaremos el valor `1`. En `R` asignaremos valores con `&lt;-`, como una flecha: `a &lt;- 1` significa que a una variable que llamamos a le asignamos el valor 1.

* Una variable llamada `b` le asignaremos el valor `2`.

* **Sumamos las variables** haciendo `a + b`.


```r
# Primera operación
a &lt;- 1 # Una variable a con valor --&gt; 1
b &lt;- 2 # Una variable b con valor --&gt; 2
*a + b
```

El **resultado** que nos devuelve la consola será 3 (2 + 1).


```
&gt; [1] 3
```


---

# Instalación de R Studio

El **Word**  que usaremos para trabajar y escribir en nuestro lenguaje será **RStudio** (lo que se conoce como un IDE: entorno integrado de desarrollo).

&amp;nbsp;

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/pantalla_rstudio.jpg" alt = "RStudio" align = "right" width = "450" style = "margin-top: 10vh;margin-right: 2rem;"&gt;

* **Paso 1**: entra la [web oficial de RStudio](https://www.rstudio.com/products/rstudio/download/#download) y selecciona la descarga gratuita.

* **Paso 2**: selecciona el ejecutable que te aparezca acorde a tu sistema operativo. 

* **Paso 3**: tras descargar el ejecutable, hay que abrirlo como otro cualquier otro ejecutable y dejar que termine la instalación.


---

# Organización de RStudio

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/inicio_rstudio_2.jpg" alt = "Rstudio" align = "left" width = "333" style = "margin-top: 3vh;margin-right: 2rem;margin-bottom: 1vh;"&gt;
&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/inicio_rstudio_3.jpg" alt = "Rstudio" align = "left" width = "283" style = "margin-top: 3vh;margin-right: 2rem;margin-bottom: 1vh;"&gt;
&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/inicio_rstudio_4.jpg" alt = "Rstudio" align = "left" width = "298" style = "margin-top: 3vh;margin-right: 2rem;margin-bottom: 1vh;"&gt;


&amp;nbsp;



* **Consola**: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo código que antes (la suma) en ella. La consola será donde **ejecutaremos órdenes y mostraremos resultados**.

* **Environment (entorno de variables)**: la pantalla pequeña (puedes ajustar los márgenes con el ratón a tu gusto) que tenemos en la parte superior derecha. Nos mostrará las **variables que tenemos definidas, el tipo y su valor**.

* **Panel multiusos**: la ventana que tenemos en la parte inferior derecha no servirá para buscar **ayuda de funciones**, además de para **visualizar gráficos**. 



---

# Tips de RStudio: modo oscuro


&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/menu_1.jpg" alt = "Rstudio" align = "left" width = "300" style = "margin-top: 3vh;margin-right: 2rem;"&gt;
&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/menu_2.jpg" alt = "Rstudio" align = "left" width = "350" style = "margin-top: 3vh;margin-right: 2rem;"&gt;

**Consejo**: cambiar en tu `RStudio` la tonalidad del fondo de tu programa, en tonos oscuros y no blancos.

---

# ¿Qué es R?

&lt;img src = "https://logos.turbio.repl.co/rlang.svg" alt = "Rstudio" align = "left" width = "350" style = "margin-top: 3vh;margin-right: 2rem;"&gt;


&amp;nbsp;



`R` es un **lenguaje estadístico**, creado por y para la estadística, con 4 ventajas fundamentales:


* **Software libre** (como C++, Python, Fortran, y otros tantos lenguajes). El software libre no solo tiene una ventaja evidente (es gratis, ok) sino que permite **acceder libremente a código ajeno**.

* **Lenguaje modular**: en la instalación que hemos realizado no se han instalado todas las funcionalidades, solo el mínimo para poder funcionar, de forma que se ahorra espacio en disco y en memoria. Al ser software libre, existen trozos de **código hechos por otras personas llamados paquetes**, que podemos ir instalando a nuestro gusto según los vayamos necesitando.

--

* **Gran comunidad de usuarios**: `R` tiene una comunidad de usuarios gigante para hacer estadística (Python tiene una enorme comunidad pero más enfocada al Machine Learning), con más de 18 000 paquetes.

--

* **Lenguaje de alto nivel**. Los lenguajes de alto nivel, como `R` o `Python`, facilitan la programación al usuario, teniendo que preocuparte solo de la tarea de programar. Son lenguajes con una menor curva de aprendizaje aunque suelen ser más lentos en su ejecución en comparación con lenguajes de bajo nivel (`C`, `C++` o `Fortran`).

---

class: inverse center middle

COMPRAR un libro --&gt; instalar un paquete (una sola vez) `install.packages()`
&lt;figure&gt;
&lt;img src = "https://cdn.cienradios.com/wp-content/uploads/sites/14/2020/09/Book-Depository-2.jpg" alt = "comprar-libros" align = "middle" width = "480" style = "margin-top: 1vh;"&gt;
&lt;/figure&gt;

SELECCIONAR un libro (ya comprado) --&gt; acceder a un paquete ya instalado (en cada sesión que queramos usarlo) `library()`
&lt;figure&gt;
&lt;img src = "https://cdn.sincroguia.tv/uploads/programs/l/a/-/la-biblioteca-de-los-libros-rechazados-704306_SPA-77.jpg" alt = "comprar-libros-2" align = "middle" width = "480" style = "margin-top: 1vh;"&gt;
&lt;/figure&gt;


---

# Paquetes en R

Como hemos mencionado, existen trozos de **código hechos por otras personas llamados paquetes**, que podemos ir instalando a nuestro gusto según los vayamos necesitando.


&amp;nbsp;


A lo largo del curso usaremos varios de esos paquetes, pero el más importante para nuestro objetivo es el paquete `{ggplot2}`, un paquete para la **elaboración de visualizaciones de datos**. Vamos a instalarlo (necesitamos internet para ello) con la orden `install.packages("ggplot")`


```r
install.packages("ggplot2")
```


&amp;nbsp;



La **instalación de un paquete** es el equivalente a comprar a un libro: solo lo debemos hacer **la primera vez** que lo usemos en un ordenador (descargándose los archivos del paquete a nuestro local). Una vez que tenemos comprado nuestro libro, para poder usarlo, simplemente debemos **indicar al programa que nos lo acerque de la estantería** con `library(ggplot2)`.


```r
library(ggplot2)
```

---

class: center middle

# ¿Por qué no usar Excel?

![](./img/meme_barco.jpg)

---

class: inverse center middle

# ¿Por qué no usar Excel?


&lt;img src = "https://upload.wikimedia.org/wikipedia/commons/9/92/Soup_Spoon.jpg" alt = "cuchara" align = "middle" width = "600" style = "margin-top: 3vh;"&gt;


Excel es una excelente cuchara: puedes ser el mejor partiendo un filete con una cuchara, pero seguirás siendo una persona comiendo filete con cuchara.

---

# ¿Por qué no usar Excel?

Excel es una **hoja de cálculo**, ni más ni menos, y el propio **Microsoft desaconseja el uso de Excel para el análisis de datos**. El Excel es una herramienta maravillosa para ser usada como una sencilla hoja de cálculo:

* Llevar las cuentas de tu familia.
* Una declaración de Renta sencilla.
* Planificar viajes

&amp;nbsp;

**NO ESTÁ DISEÑADO** para ser una base de datos, y muchos menos pensado para generar un entorno flexible para el análisis estadístico y la visualización de datos, con algunas desventajas:


* **Software de pago** (bien por el usuario, bien por la administración o empresa).

* **Software cerrado**: solo podemos hacer lo que Excel ha creído que interesante que podamos hacer. Incluso con la programación de macros, las funcionalidades de Excel siguen siendo mucho más limitadas

* **Alto consumo de memoria**.

* **No es universal**: no solo es de pago sino que además, dependiendo de la versión que tengas de Excel, tendrá un formato distinto para datos como fechas, teniendo incluso extensiones distintas.

---


# Epic fails en Excel


.pull-left[&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/excel_genes.jpg" alt = "Rstudio" align = "left" width = "250"&gt;

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/excel_uk.jpg" alt = "Rstudio" align = "left" width = "250"&gt;

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/excel_edades.jpg" alt = "Rstudio" align = "left" width = "250"&gt;]

.pull-right[



&amp;nbsp;




## Problemas de **versiones**


&amp;nbsp;



&amp;nbsp;




## Problemas de **memoria**



&amp;nbsp;



## Problemas de **codificación**



]

---


# Primeros pasos en R: calculadora

Empecemos por lo sencillo: **¿cómo usar R como una calculadora?** Si escribimos `2 + 1` en la consola y pulsamos ENTER, la consola nos mostrará el resultado de la suma.


```r
2 + 1
```

```
&gt; [1] 3
```

--

Si dicha suma la quisiéramos utilizar para un segundo cálculo: ¿y si la **almacenamos en alguna variable**? Por ejemplo, vamos a guardar la suma en una variable `x`


```r
*x &lt;- 2 + 1
```

--

Si te fijas ahora `x` aparece definida en nuestro **panel `environment`**, y puede ser usada de nuevo


```r
x + 3
```

```
&gt; [1] 6
```

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/environment_1.jpg" alt = "environment" align = "right" width = "450"&gt;

---

# Primeros pasos en R: calculadora

### Multiplicación


```r
x * y
```

### Elevar al cuadrado


```r
x^2
```

### Valor absoluto


```r
abs(x)
```

--

##  Errores

Durante tu aprendizaje va a ser **muy habitual que las cosas no salgan a la primera**, ni siquiera a la décima, apareciendo en consola mensajes en un color rojo. A **programar se aprende programando**, así que haz las pruebas que quieras: lo peor que puede pasar es que tengas que reiniciar `R`.

---

# Mensajes de «error»


* **Mensajes de ERROR**: irán precedidos de la frase **«Error in…»**, y serán aquellos **fallos que impidan la ejecución del código** (un error muy habitual es intentar acceder a funciones de algún paquete sin tenerlo instalado: estás intentando leerte un libro de tu biblioteca pero ni siquiera has ido a la tienda a «comprarlo»). Veamos un ejemplo intentando **sumar un número a un texto**.


```r
"a" + 1
```

```
&gt; Error in "a" + 1: argumento no-numérico para operador binario
```

&amp;nbsp;

* Mensajes **WARNING**: irán precedidos de la frase **«Warning in…»**, y son los fallos más delicados ya que son posibles incoherencias pero que no van a hacer que tu código deje de ejecutarse.


```r
sqrt(-1)
```

```
&gt; Warning in sqrt(-1): Se han producido NaNs
```

```
&gt; [1] NaN
```


**¿Ha ejecutado la orden?** Sí, pero te advierte de que el resultado de la operación es un NaN, **Not A Number**, un valor que no existe (al menos dentro de los números reales).


---

# ¿Dónde programamos? Script

Un **script** será el documento en el que programamos, nuestro equivalente a un archivo `.doc`, pero aquí será un archivo con extensión `.R`, donde escribiremos las órdenes.

&amp;nbsp;

Es **importante no abusar de la consola**: todo lo que no escribas en un script, cuando cierres `RStudio`, lo habrás perdido (cómo si en lugar de escribir en un Word y guardarlo, nunca guardases el documento).

&amp;nbsp;

Para **abrir nuestro primero script**, haz click en el menú superior en `File &lt;&lt; New File &lt;&lt; R Script`.

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/inicio_rstudio_5.jpg" alt = "environment" align = "right" width = "450"&gt;


---

# Ejecutar nuestros scripts

Ahora tenemos una **cuarta ventana**: la ventana donde **escribiremos nuestros códigos**

&amp;nbsp;

### **¿Cómo ejecutar nuestro script?**

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/inicio_rstudio_6.jpg" alt = "environment" align = "left" width = "500" style = "margin-top: 3vh;margin-right: 2rem;"&gt;


1. Escribimos el código que queremos ejecutar (en este caso, la suma de antes).

2. Guardamos el archivo `.R` haciendo click en el botón de guardar (`Save current document`)

3. El código **no se ejecuta salvo que se lo indiquemos**. Tenemos tres opciones:

  - **Copiar y pegar en consola** el código.
  - **Seleccionar las líneas de código** a ejecutar y clickar en `Run` (o con su atajo).
  - Activar el cuadrado `Source on save` a la **derecha del botón de guardar**: no solo se nos guarda sino que se ejecuta el código completo.


---

# Primeros ejercicios: trasteando con la consola


.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: el código inferior define una variable `a` al que le asigna el valor `2`. Añade debajo otra línea para definir una variable `b` con el valor `5`. Tras asignarles valores, multiplica los números en consola.


```r
a &lt;- 2
```

* 📝 **Ejercicio 2**: modifica el código inferior para definir dos variables `c` y `d`, con valores 3 y -1.


```r
c &lt;- # deberías asignarle el valor 3
d &lt;- # deberías asignarle el valor -1
```

* 📝 **Ejercicio 3**: con las variables `a` y `b` del ejercicio 1, crea una nueva variable `e` guardando el resultado de su multiplicación `a * b`. Escribe `e` en consola para ver su resultado

]

.panel[.panel-name[Solución ej. 1]


```r
# Para poner comentarios en el código se usa #

# Definición de variables
a &lt;- 2
b &lt;- 5

# Multiplicación
a * b
```

```
&gt; [1] 10
```
]

.panel[.panel-name[Solución ej. 2]


```r
# Definición de variables
c &lt;- 3
d &lt;- -1
```
]

.panel[.panel-name[Solución ej. 3]


```r
# Variables
a &lt;- 2
b &lt;- 5

# Resultado
e &lt;- a * b

# Muestro en consola
e
```

```
&gt; [1] 10
```


]
]


---
name: tipos-datos
class: center, middle

# Tipos de datos 

## **De la celda a la tabla**

&amp;nbsp;

¿De qué tipo pueden ser los datos que tenemos contenidos en cada celda de una «tabla»?

---

# Datos: de la celda a la tabla

&lt;img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/celdas.jpg" alt = "celdas" align = "center" width = "850" style = "margin-top: 1vh;"&gt;


* **Celda**: un **dato individual** de un tipo concreto.
* **Variable**: **concatenación de datos** del mismo tipo.
* **Matriz**: **concatenación de variables** del **mismo tipo** y longitud.
* **Tabla**: **concatenación de variables** de **distinto tipo** pero igual longitud.

---

# Celdas: tipos de datos individuales

**¿Existen variables más allá de los números?**


&amp;nbsp;

Piensa por ejemplo en los **datos guardados de una persona**:

* La edad o el peso será un **número**.
* Su nombre será una cadena de **texto**.
* Su fecha de nacimiento será precisamente eso, una **fecha**.
* A la pregunta «¿está usted soltero/a?» la respuesta será lo que llamamos una **variable binaria o lógica** (`TRUE` si está soltero/a o `FALSE` en otro caso).

&lt;img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/celdas.jpg" alt = "celdas" align = "center" width = "600" style = "margin-top: 1vh;"&gt;

---

# Variables numéricas

El **dato más sencillo**, dato que ya hemos usado en nuestros primeros pasos como calculadora.


```r
a &lt;- 1
b &lt;- 2
a + b
```

En el código anterior, tanto `a` como `b`, como la suma `a + b` **son de tipo numérico** (podemos comprobarlo con `class()`)


```r
# Clase de las variables
*class(a)
```

```
&gt; [1] "numeric"
```

**Operaciones**: con los datos numéricos podemos realizar todas las **operaciones aritméticas** que se nos ocurriría hacer en una **calculadora**.


```r
b &lt;- 5
b^3
```

```
&gt; [1] 125
```


---

# Variables de texto

No solo de números viven los datos: imagina que además de la edad de una persona queremos **guardar su nombre**.


```r
edad &lt;- 32
*nombre &lt;- "Juanito"
```

&amp;nbsp;

La variable `nombre` es de **tipo caracter**: una **cadena de texto** (conocido en otros lenguajes como string o char) que va **SIEMPRE ENTRE comillas**.


```r
*class(nombre)
```

```
&gt; [1] "character"
```

Las cadenas de texto son un **tipo especial de dato** con los que obviamente no podremos hacer operaciones aritméticas, pero si podemos hacer **otras operaciones** como pegar cadenas de texto o localizar patrones de letras dentro de ellas.

---

# Nuestra primera función: paste

Una **función** es un **trozo de código encapsulado bajo un nombre**, en función de unos **argumentos de entrada**. Nuestra primera función será `paste()`: dadas **dos cadenas de texto como argumento de entrada** nos permite pegarlas, indicándole en el **argumento** `sep = ` el caracter que queremos entre medias.


```r
# todo junto, sin espacios, igual a paste0("Juanito", "Perez")
paste("Juanito", "Perez", sep = "") 
```

```
&gt; [1] "JuanitoPerez"
```


```r
paste("Juanito", "Perez") # separados por un espacio
```

```
&gt; [1] "Juanito Perez"
```


```r
paste("Juanito", "Perez", sep = ".") # separados por un punto .
```

```
&gt; [1] "Juanito.Perez"
```

&amp;nbsp;

**Argumentos por defecto**: `paste(nombre, apellido)` es equivalente a `paste(nombre, apellido, sep = " ")`. El argumento `sep` tiene un **valor por defecto** `sep = " "`: si no se le asigna otro, tomará ese por defecto.

---

# Nuestro primer paquete: glue

Otra forma **más intuitiva de trabajar con textos** es usar el **paquete** `{glue}`.



```r
install.packages("glue") # solo la primera vez
library(glue)
```



Recuerda que `install.packages()` es solo necesario la primera que «compramos el libro»: cada vez que queramos usarlo bastará con `library()`.

&amp;nbsp;

Con dicho paquete podemos **usar variables dentro de cadenas de texto**. Por ejemplo, vamos a crear «la edad es de ... años», donde la edad concreta la tenemos guardada en una variable `edad`.


```r
edad &lt;- 32
glue("La edad es de {edad} años")
```

```
&gt; La edad es de 32 años
```

---

# Variables lógicas

Una **variable lógica, binaria o booleana** es aquella que **solo puede tomar dos valores** (en realidad pueden tomar un tercer valor, ausente):

* `TRUE`, **verdadero**, guardado internamente como un 1.
* `FALSE`, **falso**, guardado internamente como un 0.


```r
soltero &lt;- TRUE # ¿Es soltero? --&gt; SÍ
class(soltero)
```

```
&gt; [1] "logical"
```

&amp;nbsp;

**NO son variables de texto**: "TRUE" es un texto (como rojo o azul), `TRUE` es una valor lógico.


```r
TRUE + 1
```

```
&gt; [1] 2
```

```r
"TRUE" + 1
```

```
&gt; Error in "TRUE" + 1: argumento no-numérico para operador binario
```

---

# Condiciones lógicas

Los valores lógicos suelen ser **resultado de evaluar condiciones lógicas**. Por ejemplo, imaginemos que queremos comprobar si una persona está o no soltero, con el **operador lógico** `==` (¿lo de la izquierda es igual a lo de la derecha) y su opuesto `!=` (distinto de).


```r
soltero &lt;- TRUE # persona soltera
soltero == TRUE # ¿está soltero?
```

```
&gt; [1] TRUE
```

```r
soltero != TRUE # ¿no está soltero?
```

```
&gt; [1] FALSE
```


Es importante **distinguir** una asignación con `&lt;-` (una variable pasará a tener almacenado dicho valor) a una **comparación lógica** con `==` (no estamos asignando nada, estamos preguntando si la parte de la izquierda es igual a la de la derecha).

---

# Condiciones lógicas


Por el mismo razonamiento podemos **comparar si una variable numérica** cumple una condición.

**¿Tiene la persona menos de 32 años?**


```r
*edad &lt;- 38
edad &lt; 32 # ¿Es la edad menor de 32 años?
```

```
&gt; [1] FALSE
```

Además de las comparaciones «igual a»  frente «distinto», también comparaciones de orden como `&lt;, &lt;=, &gt; o &gt;=`.


```r
edad &lt;= 38
```

```
&gt; [1] TRUE
```

```r
edad &gt; 38
```

```
&gt; [1] FALSE
```

---

# Combinar condiciones lógicas

Las **condiciones lógicas pueden ser combinadas**, principalmente de dos maneras:

* **Intersección**: **todas** las condiciones concatenadas se deben cumplir (conjunción y, operador `&amp;`) para devolver un `TRUE`.

* **Unión**: basta con que **una** de las condiciones concatenadas se cumpla (conjunción o, operador `|`) para devolver un `TRUE`.

&amp;nbsp;

Ejemplo: podríamos preguntarnos si la persona tiene menos de 32 años y está soltero (AMBAS deben cumplirse).


```r
edad &lt; 32 &amp; soltero
```

```
&gt; [1] FALSE
```

El resultado es `FALSE` ya que solo se cumple una de las condiciones. Si nos bastase con una («¿está soltero y/o tiene menos de 32 años?»), el valor devuelto sería `TRUE`


```r
edad &lt; 32 | soltero
```

```
&gt; [1] TRUE
```

---

# Variables de tipo fecha

Las **variables de tipo fecha** son de un tipo muy especial: no son una simple cadena de texto "2021-04-21", representan un **instante temporal**.


```r
# Cadena de texto
fecha_char &lt;- "2021-04-21"
fecha_char + 1
```

```
&gt; Error in fecha_char + 1: argumento no-numérico para operador binario
```

Para **convertirlo a una fecha** podemos usar la función `as.Date()` 


```r
fecha_date &lt;- as.Date("2021-04-21")
fecha_date 
```

```
&gt; [1] "2021-04-21"
```

```r
fecha_date + 1
```

```
&gt; [1] "2021-04-22"
```

Dado que internamente es un número, **podemos restar fechas** (días entre ambas), podemos sumar números a fechas (fecha días después), etc.


```r
as.Date("2021-04-21") - as.Date("2021-02-15")
```

```
&gt; Time difference of 65 days
```

---

# Funcionalidades de fechas

**¿Cómo obtener automáticamente la fecha de hoy?**


```r
Sys.Date()
```

```
&gt; [1] "2022-04-04"
```

&amp;nbsp;

**¿Cómo convertir una cadena de texto a fecha?** Basta usar la función `as.Date()`, pasándole como argumento la fecha y su formato .


```r
as.Date("10-03-2020", "%d-%m-%Y") # con día-mes-año (4 cifras)
```

```
&gt; [1] "2020-03-10"
```

```r
as.Date("10-03-20", "%d-%m-%y")  # con día-mes-año (2 cifras)
```

```
&gt; [1] "2020-03-10"
```


Dentro del **paquete `{lubridate}` tenemos bastantes **funciones útiles** para trabajar con fechas como las siguientes.

---

# Paquete lubridate: fechas

En `R` tenemos un paquete muy útil para el manejo de fechas, el paquete `{lubridate}`


```r
install.packages("lubridate") # solo la primera vez
library(lubridate)
```



Con `today()` por ejemplo podemos obtener directamente la fecha actual.


```r
today()
```

```
&gt; [1] "2022-04-04"
```

Con `now()` puedes obtener la fecha y hora actual.


```r
now()
```

```
&gt; [1] "2022-04-04 12:21:41 -05"
```

---

# Paquete lubridate: fechas

Con `year()`, `month()` o `day()` podemos extraer el año, mes y día de un dato en tipo fecha.


```r
fecha &lt;- today()
year(fecha)
```

```
&gt; [1] 2022
```

```r
month(fecha)
```

```
&gt; [1] 4
```

```r
day(fecha)
```

```
&gt; [1] 4
```

También tenemos funciones como `ymd()` o `my()` para **convertir texto o números** a datos de tipo **fecha**.


```r
ymd(20170131)
```

```
&gt; [1] "2017-01-31"
```

```r
my("jan-2021")
```

```
&gt; [1] "2021-01-01"
```

---

# Paquete lubridate: fechas

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://raw.githubusercontent.com/rstudio/cheatsheets/main/pngs/thumbnails/lubridate-cheatsheet-thumbs.png" alt="Imagen extraída de https://lubridate.tidyverse.org/" width="97%" /&gt;
&lt;p class="caption"&gt;Imagen extraída de https://lubridate.tidyverse.org/&lt;/p&gt;
&lt;/div&gt;


---

# Paquete stringr

El **paquete `{stringr}`** permite un **manejo más complejo de cadenas de texto** (como el uso de **expresiones regulares**).

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://dadosdelaplace.github.io/courses-ECI-2022/img/stringr.png" alt="Imagen extraída de https://stringr.tidyverse.org/" width="87%" /&gt;
&lt;p class="caption"&gt;Imagen extraída de https://stringr.tidyverse.org/&lt;/p&gt;
&lt;/div&gt;

---

# Tips

Si haces click en la consola y pulsas la flecha «arriba» del teclado, te irá apareciendo todo el **historial de órdenes ejecutadas**. Es una manera de ahorrar tiempo para ejecutar órdenes similares a las ya ejecutadas. Si empiezas a escribir el nombre de una variable pero no te acuerdas exactamente de su nombre, pulsando tabulador te autocompletará solo.

&amp;nbsp;

Siempre que veas el símbolo `&gt;` como última línea en la consola significa que está listo para que le escribamos otra orden.

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/tip_consola_lista.jpg" alt = "tip-consola" align = "right" width = "750"&gt;


---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]

* 📝 **Ejercicio 1**: define una variable que guarde tu edad y otra con tu nombre

* 📝 **Ejercicio 2**: define otra variable que responda la pregunta «¿tengo hermanos?» y otra con la fecha de tu nacimiento.
 

* 📝 **Ejercicio 3**: define otra variable con tus apellidos. Junta con `paste()` o `glue()` las variables `nombre` y `apellidos` en una sola variable `nombre_completo`.
 

* 📝 **Ejercicio 4**: calcula los días que han pasado desde la fecha de tu nacimiento, haciendo la resta entre la fecha de hoy (`today()`) y la fecha de nacimiento definida en el ejercicio 2. 
 

* 📝 **Ejercicio 5**: obtén una variable lógica que nos diga si se cumplen (todas) las condiciones i) menor de 30 años (`edad &lt; 30`); ii) con hermanos (`hermanos == TRUE`); iii) nacido en 1990 o posterior (`fecha_nacimiento &gt;= as.Date("1990-01-01")`).

* 📝 **Ejercicio 6**: modifica el código del ejercicio anterior para obtener una variable lógica que nos diga si se cumplen (al menos) ALGUNA de las condiciones.
]

.panel[.panel-name[Solución ej. 1]


```r
edad &lt;- 32 # tipo numeric
class(edad)
```

```
&gt; [1] "numeric"
```

```r
nombre &lt;- "Juanito" # tipo caracter
class(nombre)
```

```
&gt; [1] "character"
```
]

.panel[.panel-name[Solución ej. 2]


```r
hermanos &lt;- TRUE # tipo hermanos
class(hermanos)
```

```
&gt; [1] "logical"
```

```r
fecha_nacimiento &lt;- as.Date("1989-09-10") # tipo fecha
class(fecha_nacimiento)
```

```
&gt; [1] "Date"
```

]

.panel[.panel-name[Solución ej. 3]


```r
# Nombre
nombre &lt;- "Juanito"
# Apellidos
apellidos &lt;- "Perez Liébana"

# Pegamos
library(glue)
nombre_completo &lt;- glue("{nombre} {apellidos}")
nombre_completo
```

```
&gt; Juanito Perez Liébana
```

```r
# Otra forma
nombre_completo &lt;- paste(nombre, apellidos)
nombre_completo
```

```
&gt; [1] "Juanito Perez Liébana"
```
]

.panel[.panel-name[Solución ej. 4]


```r
library(lubridate)
fecha_nacimiento &lt;- as.Date("1989-09-10")
today() - fecha_nacimiento
```

```
&gt; Time difference of 11894 days
```
]

.panel[.panel-name[Solución ej. 5]


```r
# Se tienen que cumplir todas
edad &lt; 30 &amp; fecha_nacimiento &gt;= as.Date("1990-01-01") &amp; hermanos
```

```
&gt; [1] FALSE
```

```r
# otra forma
edad &lt; 30 &amp; fecha_nacimiento &gt;= as.Date("1990-01-01") &amp; hermanos == TRUE
```

```
&gt; [1] FALSE
```

]

.panel[.panel-name[Solución ej. 6]


```r
# Se tienen que cumplir todas
edad &lt; 30 | fecha_nacimiento &gt;= as.Date("1990-01-01") | hermanos
```

```
&gt; [1] TRUE
```
]
]


---

name: vectores
class: center, middle

# Vectores


## **Variables: colección de datos individuales de igual tipo**

&amp;nbsp;

¿Cómo **concatenar** edades de varias personas? ¿Cómo ordenarlas?

---

# Vectores: concatenar elementos

Los **vectores o arrays** no son más que una **concatenación de elementos del mismo tipo** (de hecho un número individual `x &lt;- 1` es en realidad un vector de longitud uno).

Los crearemos con `c()` (c de concatenar), con sus **elementos entre paréntesis y separados por comas**. 


```r
edades &lt;- c(32, 27, 60, 61)
edades
```

```
&gt; [1] 32 27 60 61
```

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/vectores_enviroment.jpg" alt = "stringr" align = "right" width = "350"&gt;


La **longitud de un vector** se puede calcular con `length()`


```r
length(edades)
```

```
&gt; [1] 4
```

Dado que un número y un vector es lo mismo (con distinta longitud), podemos **concatenar a vectores uno tras otro**.


```r
c(edades, edades, 8)
```

```
&gt; [1] 32 27 60 61 32 27 60 61  8
```


---

# Secuencias numéricas

Es habitual **crear vectores numéricos con un patrón** repetido. Hay un **atajo**: `seq()` nos permite crear una **secuencia desde un elemento inicial hasta un elemento final**, avanzando de uno en uno.


```r
seq(1, 11) # secuencia desde 1 hasta 11 de 1 en 1 (equivalente: 1:11)
```

```
&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11
```

```r
11:1 # orden inverso
```

```
&gt;  [1] 11 10  9  8  7  6  5  4  3  2  1
```

También podemos definir **otro tipo de distancia entre dos elementos consecutivos**


```r
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

```
&gt;  [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0
```

Otras veces nos interesará definir una secuencia con un **número concreto de elementos**.


```r
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 11
```

```
&gt; [1]  1.000000  9.166667 17.333333 25.500000 33.666667 41.833333 50.000000
```

---

# Secuencias numéricas

**Vectores repetidos**: otro atajo, para definir vectores de elementos repetidos, es la función `rep()` nos permite repetir un elemento un número fijado de veces.


```r
rep(0, 7) # vector de 7 ceros
```

```
&gt; [1] 0 0 0 0 0 0 0
```

No solo podemos repetir un número sino que podemos **repetir vectores enteros**.


```r
rep(c(0, 1, 2), 4) # repetimos el vector c(0, 1, 2) 4 veces
```

```
&gt;  [1] 0 1 2 0 1 2 0 1 2 0 1 2
```

Esa repetición además podemos definirla también de **forma intercalada**


```r
rep(c(0, 1, 2), each = 4) # cuatro 0, luego cuatro 1, luego cuatro 2
```

```
&gt;  [1] 0 0 0 0 1 1 1 1 2 2 2 2
```

---

# Vectores de texto


El concepto de vectores **no solo atañe a los números**


```r
mi_nombre &lt;- c("Mi", "nombre", "es", "Juanito")
mi_nombre
```

```
&gt; [1] "Mi"      "nombre"  "es"      "Juanito"
```

Cuando tenemos un vector de caracteres podemos colapsarlos con `paste()`, esta vez con `collapse = ...`


```r
paste(mi_nombre, collapse = ".") # separados por un punto .
```

```
&gt; [1] "Mi.nombre.es.Juanito"
```

Podemos también combinar vectores numéricos con caracteres.


```r
glue("persona_{1:5}") # separado por una barra baja
```

```
&gt; persona_1
&gt; persona_2
&gt; persona_3
&gt; persona_4
&gt; persona_5
```

---

# Vectores lógicos

Los **vectores lógicos** suelen aparecer de nuevo como la evaluación de condiciones lógicas.  Por ejemplo, si definimos el vector `x &lt;- c(1.5, -1, 2, 4, 3, -4)`, ¿qué numeros de x son menores que 2?


```r
x &lt;- c(1.5, -1, 2, 4, 3, -4)
x &lt; 2 
```

```
&gt; [1]  TRUE  TRUE FALSE FALSE FALSE  TRUE
```

El primer, segundo y sexto elemento del vector son los únicos elementos (estrictamente) menores que 2, de ahí que en el primer, segundo y sexto elemento aparezca un TRUE y en el resto un FALSE.

&amp;nbsp;

Al igual que antes, las condiciones pueden ser **combinadas**


```r
x &lt;- c(1.5, -1, 2, 4, 3, -4)
x &lt; 3 &amp; x &gt; 0 # Solo los que cumplen ambas condiciones
```

```
&gt; [1]  TRUE FALSE  TRUE FALSE FALSE FALSE
```

---

# Datos ausentes

* **NA** (not available): valores que no tenemos (por ejemplo, el dato de contagios covid los fines de semana).


```r
x &lt;- c(1, NA, 3, NA, NA, 5, 6) # Vector numérico con datos faltante
x
```

```
&gt; [1]  1 NA  3 NA NA  5  6
```

```r
2 * x
```

```
&gt; [1]  2 NA  6 NA NA 10 12
```

--

* **NaN** (not a number): resultado no permitido


```r
sqrt(-1)
```

```
&gt; [1] NaN
```


```r
x &lt;- c(1, NA, 3, 4, 6, 7, NaN, NA)
is.na(x)
```

```
&gt; [1] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE
```

---

# Operaciones aritméticas con vectores

Toda **operación aritmética** que podamos hacer con un número la vamos a poder a hacer con un vector de números: la operación se realizará en **CADA ELEMENTO** del vector (en otros lenguajes no siempre es así).


```r
# Multiplicamos por 2 a CADA ELEMENTO del vector
z &lt;- c(2, 4, 6)
2 * z
```

```
&gt; [1]  4  8 12
```

De la misma manera se pueden definir **sumas** de vectores.


```r
x &lt;- c(1, 3, 5)
x + z
```

```
&gt; [1]  3  7 11
```

--

Dado que los valores lógicos son guardados internamente como `0/1`  podemos usar operaciones aritméticas con ellos.


```r
x &lt;- c(1, 3, 5)
sum(x &lt; 2) # sumamos el vector lógico --&gt; número de valores TRUE
```

```
&gt; [1] 1
```

---

# Operaciones estadísticas con vectores
 
También podemos realizar **operaciones estadísticas** como la suma, la media o la mediana.


```r
y &lt;- c(1, -4, 5, 0, 7)
sum(y)  # suma
```

```
&gt; [1] 9
```

```r
mean(y) # media
```

```
&gt; [1] 1.8
```

**IMPORTANTE**: las operaciones con ausentes darán como resultado ausente (salvo que los eliminemos antes con `na.rm = TRUE`).


```r
y &lt;- c(1, 2, NA, -5, 0)
sum(y)
```

```
&gt; [1] NA
```

```r
sum(y, na.rm = TRUE)
```

```
&gt; [1] -2
```


---

# Seleccionar elementos

¿Y si del vector original queremos **EXTRAER UN SUBCONJUNTO**? La forma más sencilla es **acceder al elemento i-ésimo** con el operador de selección `[i]`, o en base a una **condición lógica**




```r
edades &lt;- c(20, 30, 32, NA, 61)
edades[3] # accedemos a la edad de la tercera persona
```

```
&gt; [1] 32
```

```r
*edades[c(3, 4)]
```

```
&gt; [1] 32 NA
```

```r
edades[edades &gt; 30]
```

```
&gt; [1] 32 NA 61
```

Otras veces no querremos seleccionar un elemento sino **filtrarlo**, con el operador `[-i]`


```r
edades[-1]
```

```
&gt; [1] 30 32 NA 61
```




---

# Nombrando vectores


`R` nos permite dar **significado léxico a nuestros datos**, pudiendo poner **nombres a los elementos** de un vector.


```r
x &lt;- c("edad" = 31, "tlf" = 613910687, "cp" = 33007) # cada número tiene un significado distinto
x
```

```
&gt;      edad       tlf        cp 
&gt;        31 613910687     33007
```

Esto es una ventaja ya que nos permite su **selección usando dichos nombres**: los números ya representan algo.


```r
x[c("edad", "cp")] # seleccionamos los elementos que tienen ese nombre asignado
```

```
&gt;  edad    cp 
&gt;    31 33007
```

Con la función `names()` podemos, no solo consultar sino cambiar los nombres.


```r
names(x) # Consultamos nombres antiguos
```

```
&gt; [1] "edad" "tlf"  "cp"
```

```r
names(x) &lt;- c("años", "móvil", "dirección") # Cambiamos nombres
```

---

# Ordenar vectores

Una acción **muy habitual** es **ordenar los datos**: de menor a mayor edad, datos más recientes vs antiguos, etc. Para ello tenemos la función `sort()`: vamos a ordenar, por ejemplo, una colección de edades.


```r
edades &lt;- c(81, 7, 25, 41, 65, 20, 32, 23, 77)
sort(edades) # orden de joven a mayor
```

```
&gt; [1]  7 20 23 25 32 41 65 77 81
```

Por defecto `sort()` ordena de menor a mayor: con `decreasing = TRUE` podemos ordenar de mayor a menor.


```r
sort(edades, decreasing = TRUE) 
```

```
&gt; [1] 81 77 65 41 32 25 23 20  7
```

Otra forma de ordenar un vector es **pedirle nos devuelva los índices de los elementos ordenados** con `order`, y luego usar dichos índices.


```r
x &lt;- c(7, 1, 2, 6)
x[order(x)]
```

```
&gt; [1] 1 2 6 7
```

---

# Ejercicios con vectores

.panelset[
.panel[.panel-name[Ejercicios]

* 📝 **Ejercicio 1**: modifica el código inferior para crear un vector de nombre `vector_num` que contenga los números 1, 5 y -7.


```r
# Vector de números
vector_num &lt;- c(1)
```

* 📝 **Ejercicio 2**: define un vector que contenga los números `1, 10, -1 y 2`, y obtén su longitud.
 

* 📝 **Ejercicio 3**: crea un vector con las palabras "Hola", "me", "llamo" (y tu nombre y apellidos), y pega luego sus elementos de forma que la frase esté correctamente escrita en castellano. Tras hacerlo, añade "y tengo 30 años".
 
 
* 📝 **Ejercicio 4**: crea una secuencia que empiece en 1 y recorra todos los naturales hasta el 10. Después crea otra secuencia de longitud 7 en la que todos los números sean 3.
 

* 📝 **Ejercicio 5**: crea un vector con las edades de cuatro conocidos o familiares. Tras ello, determina cuáles de ellos tienen menos de 20 años, 30 años o más, menos de 40 años y más de 65 años.

]

.panel[.panel-name[Solución ej. 1]


```r
# Vector de números
vector_num &lt;- c(1, 5, -7)
vector_num
```

```
&gt; [1]  1  5 -7
```
]

.panel[.panel-name[Solución ej. 2]


```r
# Vector de números
vector_num &lt;- c(1, 10, -1, 2)
length(vector_num)
```

```
&gt; [1] 4
```
]

.panel[.panel-name[Solución ej. 3]


```r
# Definiendo el vector
vector_char &lt;- c("Hola", "me", "llamo", "Juanito",
                 "Perez", "Liébana")

# Pegamos
frase &lt;- paste(vector_char, collapse = " ")
frase
```

```
&gt; [1] "Hola me llamo Juanito Perez Liébana"
```

```r
# Añadimos frase
glue("{frase} y tengo 30 años.")
```

```
&gt; Hola me llamo Juanito Perez Liébana y tengo 30 años.
```
]

.panel[.panel-name[Solución ej. 4]


```r
1:10
```

```
&gt;  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
rep(3, 7) # secuencia repetida de treses
```

```
&gt; [1] 3 3 3 3 3 3 3
```
]

.panel[.panel-name[Solución ej. 5]


```r
edades &lt;- c(27, 32, 60, 61) # en mi caso, por ejemplo
edades &lt; 20 # menos de 20 años
```

```
&gt; [1] FALSE FALSE FALSE FALSE
```

```r
edades &gt;= 30 # 30 años o más
```

```
&gt; [1] FALSE  TRUE  TRUE  TRUE
```

```r
edades &lt; 40 # menos de 40 años
```

```
&gt; [1]  TRUE  TRUE FALSE FALSE
```
]
]



---

name: matrices-dataframes
class: center, middle



# Datos estructurados: colección de variables


## **matrices: igual tipo y longitud**

&amp;nbsp;

## **data.frame o tabla: distinto tipo pero igual longitud**

---

# Datos estructurados: colección de variables


&lt;img src = "https://raw.githubusercontent.com/dadosdelaplace/slides-ECI-2022/main/img/celdas.jpg" alt = "celdas" align = "center" width = "580" style = "margin-top: 1vh;"&gt;

Ya sabemos:

✅ Los **tipos de datos** que puede contener una **celda**.

✅ Como **concatenar celdas** obteniendo variables (vectores, datos del mismo tipo).

Lo que haremos a continuación será **juntar esas variables**: bien del **mismo tipo** (matrices), bien de **distinto tipo** (`data.frame`), pero en cualquier caso de **igual longitud**.

---

# Matrices: variables del mismo tipo

Cuando analizamos datos solemos tener **varias variables distintas de cada individuo**. Necesitamos una «tabla» que una distintas variables (de IGUAL longitud). Las **matrices** son una **concatenación de variables, del mismo tipo e igual longitud**, dispuestas en columnas (normalmente cada fila representa un individuo y cada columna una variable). La concatenación en columnas la haremos con `cbind()`.


```r
estaturas &lt;- c(150, 160, 170, 180)
pesos &lt;- c(60, 70, 80, 90)
datos_matriz &lt;- cbind(estaturas, pesos) # Construimos la matriz por columnas
datos_matriz # nuestra primera matriz
```

```
&gt;      estaturas pesos
&gt; [1,]       150    60
&gt; [2,]       160    70
&gt; [3,]       170    80
&gt; [4,]       180    90
```


| estaturas| pesos|
|---------:|-----:|
|       150|    60|
|       160|    70|
|       170|    80|
|       180|    90|

---

# Matrices


También podemos **construir la matriz por filas** con `rbind()`, que nos permite **añadir filas a una matriz o construirla desde cero** (aunque lo habitual es tener cada variable en una columna y cada individuo en una fila).


```r
rbind(estaturas, pesos) # Construimos la matriz por filas
```

```
&gt;           [,1] [,2] [,3] [,4]
&gt; estaturas  150  160  170  180
&gt; pesos       60   70   80   90
```


|          |    |    |    |    |
|:---------|---:|---:|---:|---:|
|estaturas | 150| 160| 170| 180|
|pesos     |  60|  70|  80|  90|

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/datos_matriz_1.jpg" alt = "course-ECI" align = "right" width = "400" style = "margin-top: 3vh;margin-right: 0.5rem;margin-left: 0.5rem;"&gt;

--

Podemos **visualizar la matriz** en un formato «excelizado» con la función `View()`


```r
View(datos_matriz)
```

---

# Matrices

.panelset[
.panel[.panel-name[Ejemplo] 

Veamos un ejemplo más jugoso para practicar: una matriz con las edades, teléfonos y códigos postales.



```r
edades &lt;- c(14, 56, 31, 20, 68) # vector numérico de longitud 4
tlf &lt;- c(NA, 683839390, 621539732, NA, NA)
cp &lt;- c(33007, 28019, 37005, 18003, 28045)

# Construimos la matriz por columnas
datos_matriz &lt;- cbind(edades, tlf, cp) 
datos_matriz
```

```
&gt;      edades       tlf    cp
&gt; [1,]     14        NA 33007
&gt; [2,]     56 683839390 28019
&gt; [3,]     31 621539732 37005
&gt; [4,]     20        NA 18003
&gt; [5,]     68        NA 28045
```
]

.panel[.panel-name[Añadir columna] 

Con `cbind()` también podemos **añadir una columna**


```r
cbind(datos_matriz, "estaturas" = c(160, NA, 181, 165, 173))
```

```
&gt;      edades       tlf    cp estaturas
&gt; [1,]     14        NA 33007       160
&gt; [2,]     56 683839390 28019        NA
&gt; [3,]     31 621539732 37005       181
&gt; [4,]     20        NA 18003       165
&gt; [5,]     68        NA 28045       173
```
]

.panel[.panel-name[Dimensiones] 
Y podemos **ver sus dimensiones** con `dim()`, o por separado con `nrow()` y `ncol()`


```r
dim(datos_matriz)
```

```
&gt; [1] 5 3
```

```r
c(nrow(datos_matriz), ncol(datos_matriz))
```

```
&gt; [1] 5 3
```

Dada una matriz también podemos **«darle vuelta»** (lo que se conoce como **matriz transpuesta**) con `t()`.


```r
t(datos_matriz)
```

```
&gt;         [,1]      [,2]      [,3]  [,4]  [,5]
&gt; edades    14        56        31    20    68
&gt; tlf       NA 683839390 621539732    NA    NA
&gt; cp     33007     28019     37005 18003 28045
```

]

.panel[.panel-name[matrix()] 

Igual que a veces es útil generar un vector de elementos repetidos, también podemos definir una **matriz de números repetidos** (por ejemplo, de ceros), con la función `matrix()`, indicándole el número de filas y columnas.


```r
matrix(0, nrow = 4, ncol = 2) # 4 filas, 2 columnas, todo 0's
```

```
&gt;      [,1] [,2]
&gt; [1,]    0    0
&gt; [2,]    0    0
&gt; [3,]    0    0
&gt; [4,]    0    0
```

También podemos **definir una matriz a partir de un vector numérico**, reorganizando los valores en forma de matriz, sabiendo que los elementos se van colocando por columnas.


```r
z &lt;- matrix(1:15, ncol = 5) # Matriz con el vector 1:5 con 5 columnas (ergo 3 filas)
z
```

```
&gt;      [,1] [,2] [,3] [,4] [,5]
&gt; [1,]    1    4    7   10   13
&gt; [2,]    2    5    8   11   14
&gt; [3,]    3    6    9   12   15
```

]

.panel[.panel-name[Operaciones] 

Con las matrices sucede como con los vectores: cuando **aplicamos una operación aritmética se la estamos aplicando elemento a elemento**, por ejemplo, dividir entre 5 o sumar una constante


```r
datos_matriz / 5
```

```
&gt;      edades       tlf     cp
&gt; [1,]    2.8        NA 6601.4
&gt; [2,]   11.2 136767878 5603.8
&gt; [3,]    6.2 124307946 7401.0
&gt; [4,]    4.0        NA 3600.6
&gt; [5,]   13.6        NA 5609.0
```

```r
datos_matriz + 3
```

```
&gt;      edades       tlf    cp
&gt; [1,]     17        NA 33010
&gt; [2,]     59 683839393 28022
&gt; [3,]     34 621539735 37008
&gt; [4,]     23        NA 18006
&gt; [5,]     71        NA 28048
```
]

.panel[.panel-name[Otras matrices] 

También podemos **crear matrices de otros tipos de datos**, siempre y cuando las columnas sean del mismo tipo e igual longitud.


```r
nombres &lt;- c("Juanito", "Carlos", "María", "Paloma")
apellidos &lt;- c("Perez", "García", "Pérez", "Liébana")
cbind(nombres, apellidos)
```

```
&gt;      nombres   apellidos
&gt; [1,] "Juanito" "Perez"  
&gt; [2,] "Carlos"  "García" 
&gt; [3,] "María"   "Pérez"  
&gt; [4,] "Paloma"  "Liébana"
```

]
]

---

# Matrices

Las matrices son objetos **bidimensionales**: para acceder a la **fila i-ésima** se usa el operador `[i, ]` (dejando el otro sin rellenar), para acceder a la **columna j-ésima** se usa el operador `[, j]`. Para acceder **conjuntamente al elemento (i, j)** se  `[i, j]`. También podemos **acceder por nombres de las columnas**.



```r
datos_matriz[2, 3]
```

```
&gt;    cp 
&gt; 28019
```

```r
datos_matriz[1, ] # fila 1
```

```
&gt; edades    tlf     cp 
&gt;     14     NA  33007
```

```r
datos_matriz[, 3] # columna 3
```

```
&gt; [1] 33007 28019 37005 18003 28045
```

```r
datos_matriz[1, c("edades", "tlf")] # por nombres
```

```
&gt; edades    tlf 
&gt;     14     NA
```

---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: modifica el código para definir una matriz x de ceros de 3 filas y 7 columnas.
 

```r
# Matriz
x &lt;- matrix(0, nrow = 2, ncol = 3)
x
```

* 📝 **Ejercicio 2**: a la matriz anterior, suma un 1 a cada número de la matriz y divide el resultado entre 5.
 
* 📝 **Ejercicio 3**: accede a toda la segunda fila de la matriz anterior. Accede a toda la tercera columna de la matriz anterior. Accede al elemento que ocupa la primera fila y la segunda columna.

]

.panel[.panel-name[Solución Ej. 1]


```r
# Matriz
x &lt;- matrix(0, nrow = 3, ncol = 7)
x
```

```
&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
&gt; [1,]    0    0    0    0    0    0    0
&gt; [2,]    0    0    0    0    0    0    0
&gt; [3,]    0    0    0    0    0    0    0
```

]

.panel[.panel-name[Solución Ej. 2]


```r
(x + 1) / 5
```

```
&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7]
&gt; [1,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2
&gt; [2,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2
&gt; [3,]  0.2  0.2  0.2  0.2  0.2  0.2  0.2
```

]

.panel[.panel-name[Solución Ej. 3]


```r
x[2, ] # toda la segunda fila
```

```
&gt; [1] 0 0 0 0 0 0 0
```

```r
x[, 3] # toda la tercera columna
```

```
&gt; [1] 0 0 0
```

```r
x[1, 2] # primera fila y segunda columna
```

```
&gt; [1] 0
```

]

]
 
---

# data.frame: tablas

**¿Qué sucede si añadimos una columna con los nombres de cada persona en nuestra matriz `datos_matriz`?** En dicha matriz teníamos guardadas las edades, códigos postales y teléfonos de una serie de personas, todas ellas variables numéricas.


```r
nombres &lt;- c("Sonia", "Carla", "Pepito", "Carlos")
datos_matriz_nueva &lt;- cbind(nombres, datos_matriz)
datos_matriz_nueva
```

```
&gt;      nombres  edades tlf         cp     
&gt; [1,] "Sonia"  "14"   NA          "33007"
&gt; [2,] "Carla"  "56"   "683839390" "28019"
&gt; [3,] "Pepito" "31"   "621539732" "37005"
&gt; [4,] "Carlos" "20"   NA          "18003"
&gt; [5,] "Sonia"  "68"   NA          "28045"
```

Como una **matriz SOLO puede tener un tipo de dato**, al añadir una variable de tipo texto, `R` se ha visto obligado a convertir los números en texto: hemos **roto la integridad** de los datos.


```r
datos_matriz_nueva[, "pesos"] + 1
```

```
&gt; Error in datos_matriz_nueva[, "pesos"]: subíndice fuera de  los límites
```


---

# data.frame: tablas

El formato de tabla de datos en `R` que vamos a empezar a usar se llama `data.frame`, y no es más que una **colección de variables de igual longitud pero cada una puede ser de un tipo distinto**. Para crear un `data.frame` basta con usar la función `data.frame()`.


```r
# Nombres
nombres &lt;- c("Sonia", "Carla", "Pepito", "Carlos")
# Edades
edades &lt;- c(45, 67, NA, 31)
# Estado civil (no lo sabemos de una persona)
casado &lt;- c(TRUE, FALSE, FALSE, NA)
# Fecha de creación (fecha en el que esa persona entra en el sistema)
# lo convertimos a tipo fecha
f_creacion &lt;-
  as.Date(c("2021-03-04", "2020-10-12", "1990-04-05", "2019-09-10"))

# Creamos nuestro primer data.frame
tabla &lt;- data.frame(nombres, edades, casado, f_creacion)
tabla
```

```
&gt;   nombres edades casado f_creacion
&gt; 1   Sonia     45   TRUE 2021-03-04
&gt; 2   Carla     67  FALSE 2020-10-12
&gt; 3  Pepito     NA  FALSE 1990-04-05
&gt; 4  Carlos     31     NA 2019-09-10
```

---

# data.frame: tablas

Al igual que con las matrices, podemos **crearlos** indicando además el **nombre de las columnas**.


```r
tabla &lt;- data.frame("nombre" = nombres, "edad" = edades,
                    "casado" = casado, "fecha_registro" = f_creacion)
```


Si tenemos un `data.frame` ya creado podemos usar `data.frame()` también para añadir una columna.


```r
# Añadimos una nueva columna con nº de hermanos/as
tabla &lt;- data.frame(tabla, "n_hermanos" = c(0, 0, 1, 5))
```

Con `View()` podemos **visualizar nuestra tabla**.


```r
View(tabla)
```


|nombre | edad|casado |fecha_registro | n_hermanos|
|:------|----:|:------|:--------------|----------:|
|Sonia  |   45|TRUE   |2021-03-04     |          0|
|Carla  |   67|FALSE  |2020-10-12     |          0|
|Pepito |   NA|FALSE  |1990-04-05     |          1|
|Carlos |   31|NA     |2019-09-10     |          5|

---

# Selección de columnas y filas

Si queremos **acceder a una columna, fila o elemento** en concreto, los `data.frame` tienen las mismas ventajas que una matriz, así que bastaría con usar los mismos operadores.


```r
tabla[, 3] # Accedemos a la tercera columna
```

```
&gt; [1]  TRUE FALSE FALSE    NA
```

```r
tabla[4, ] # Accedemos a la cuarta fila
```

```
&gt;   nombre edad casado fecha_registro n_hermanos
&gt; 4 Carlos   31     NA     2019-09-10          5
```

No solo tiene las ventajas de una matriz si no que también tiene las ventajas de una **«base» de datos**: podemos **aceder a las variables** por su nombre poniendo el nombre de la tabla más el símbolo `$` y, con el tabulador, nos aparecerá un **menú de columnas** a elegir.

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/tabla_dolar.jpg" alt = "course-ECI" align = "right" width = "450" style = "margin-top: 3vh;margin-right: 0.5rem;margin-left: 0.5rem;"&gt;

---

# Ejercicios


.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: el `data.frame` llamado `airquality`, del paquete `{datasets}`, contiene variables de la calidad del aire de la ciudad de Nueva York desde mayo hasta septiembre de 1973. Obtén el nombre de las variables.
 

* 📝 **Ejercicio 2**: obtén las dimensiones del anterior conjunto de datos. ¿Cuántas variables hay? ¿Cuántos días se han medido?
 

* 📝 **Ejercicio 3**: filtra del conjunto anterior solo los datos del mes de julio.

* 📝 **Ejercicio 4**: qúedate solo con las variable Ozone y Temp.
 
* 📝 **Ejercicio 5**: añade a los datos originales una columna con la fecha completa (recuerda que es del año 1973 todas las observaciones.

]

.panel[.panel-name[Solución Ej. 1]


```r
# install.packages("datasets") si no estuviera ya instalado
library(datasets)
names(airquality)
```

```
&gt; [1] "Ozone"   "Solar.R" "Wind"    "Temp"    "Month"   "Day"
```

]

.panel[.panel-name[Solución Ej. 2]


```r
# Dimensiones
dim(airquality)
```

```
&gt; [1] 153   6
```

```r
nrow(airquality)
```

```
&gt; [1] 153
```

```r
ncol(airquality)
```

```
&gt; [1] 6
```

]

.panel[.panel-name[Solución Ej. 3]


```r
filtro_filas &lt;- airquality[airquality$Month == 7, ]
filtro_filas
```

```
&gt;    Ozone Solar.R Wind Temp Month Day
&gt; 62   135     269  4.1   84     7   1
&gt; 63    49     248  9.2   85     7   2
&gt; 64    32     236  9.2   81     7   3
&gt; 65    NA     101 10.9   84     7   4
&gt; 66    64     175  4.6   83     7   5
&gt; 67    40     314 10.9   83     7   6
&gt; 68    77     276  5.1   88     7   7
&gt; 69    97     267  6.3   92     7   8
&gt; 70    97     272  5.7   92     7   9
&gt; 71    85     175  7.4   89     7  10
&gt; 72    NA     139  8.6   82     7  11
&gt; 73    10     264 14.3   73     7  12
&gt; 74    27     175 14.9   81     7  13
&gt; 75    NA     291 14.9   91     7  14
&gt; 76     7      48 14.3   80     7  15
&gt; 77    48     260  6.9   81     7  16
&gt; 78    35     274 10.3   82     7  17
&gt; 79    61     285  6.3   84     7  18
&gt; 80    79     187  5.1   87     7  19
&gt; 81    63     220 11.5   85     7  20
&gt; 82    16       7  6.9   74     7  21
&gt; 83    NA     258  9.7   81     7  22
&gt; 84    NA     295 11.5   82     7  23
&gt; 85    80     294  8.6   86     7  24
&gt; 86   108     223  8.0   85     7  25
&gt; 87    20      81  8.6   82     7  26
&gt; 88    52      82 12.0   86     7  27
&gt; 89    82     213  7.4   88     7  28
&gt; 90    50     275  7.4   86     7  29
&gt; 91    64     253  7.4   83     7  30
&gt; 92    59     254  9.2   81     7  31
```

]

.panel[.panel-name[Solución Ej. 4]


```r
# Filtramos columnas
filtro_cols &lt;- airquality[, c("Ozone", "Temp")]
filtro_cols
```

```
&gt;     Ozone Temp
&gt; 1      41   67
&gt; 2      36   72
&gt; 3      12   74
&gt; 4      18   62
&gt; 5      NA   56
&gt; 6      28   66
&gt; 7      23   65
&gt; 8      19   59
&gt; 9       8   61
&gt; 10     NA   69
&gt; 11      7   74
&gt; 12     16   69
&gt; 13     11   66
&gt; 14     14   68
&gt; 15     18   58
&gt; 16     14   64
&gt; 17     34   66
&gt; 18      6   57
&gt; 19     30   68
&gt; 20     11   62
&gt; 21      1   59
&gt; 22     11   73
&gt; 23      4   61
&gt; 24     32   61
&gt; 25     NA   57
&gt; 26     NA   58
&gt; 27     NA   57
&gt; 28     23   67
&gt; 29     45   81
&gt; 30    115   79
&gt; 31     37   76
&gt; 32     NA   78
&gt; 33     NA   74
&gt; 34     NA   67
&gt; 35     NA   84
&gt; 36     NA   85
&gt; 37     NA   79
&gt; 38     29   82
&gt; 39     NA   87
&gt; 40     71   90
&gt; 41     39   87
&gt; 42     NA   93
&gt; 43     NA   92
&gt; 44     23   82
&gt; 45     NA   80
&gt; 46     NA   79
&gt; 47     21   77
&gt; 48     37   72
&gt; 49     20   65
&gt; 50     12   73
&gt; 51     13   76
&gt; 52     NA   77
&gt; 53     NA   76
&gt; 54     NA   76
&gt; 55     NA   76
&gt; 56     NA   75
&gt; 57     NA   78
&gt; 58     NA   73
&gt; 59     NA   80
&gt; 60     NA   77
&gt; 61     NA   83
&gt; 62    135   84
&gt; 63     49   85
&gt; 64     32   81
&gt; 65     NA   84
&gt; 66     64   83
&gt; 67     40   83
&gt; 68     77   88
&gt; 69     97   92
&gt; 70     97   92
&gt; 71     85   89
&gt; 72     NA   82
&gt; 73     10   73
&gt; 74     27   81
&gt; 75     NA   91
&gt; 76      7   80
&gt; 77     48   81
&gt; 78     35   82
&gt; 79     61   84
&gt; 80     79   87
&gt; 81     63   85
&gt; 82     16   74
&gt; 83     NA   81
&gt; 84     NA   82
&gt; 85     80   86
&gt; 86    108   85
&gt; 87     20   82
&gt; 88     52   86
&gt; 89     82   88
&gt; 90     50   86
&gt; 91     64   83
&gt; 92     59   81
&gt; 93     39   81
&gt; 94      9   81
&gt; 95     16   82
&gt; 96     78   86
&gt; 97     35   85
&gt; 98     66   87
&gt; 99    122   89
&gt; 100    89   90
&gt; 101   110   90
&gt; 102    NA   92
&gt; 103    NA   86
&gt; 104    44   86
&gt; 105    28   82
&gt; 106    65   80
&gt; 107    NA   79
&gt; 108    22   77
&gt; 109    59   79
&gt; 110    23   76
&gt; 111    31   78
&gt; 112    44   78
&gt; 113    21   77
&gt; 114     9   72
&gt; 115    NA   75
&gt; 116    45   79
&gt; 117   168   81
&gt; 118    73   86
&gt; 119    NA   88
&gt; 120    76   97
&gt; 121   118   94
&gt; 122    84   96
&gt; 123    85   94
&gt; 124    96   91
&gt; 125    78   92
&gt; 126    73   93
&gt; 127    91   93
&gt; 128    47   87
&gt; 129    32   84
&gt; 130    20   80
&gt; 131    23   78
&gt; 132    21   75
&gt; 133    24   73
&gt; 134    44   81
&gt; 135    21   76
&gt; 136    28   77
&gt; 137     9   71
&gt; 138    13   71
&gt; 139    46   78
&gt; 140    18   67
&gt; 141    13   76
&gt; 142    24   68
&gt; 143    16   82
&gt; 144    13   64
&gt; 145    23   71
&gt; 146    36   81
&gt; 147     7   69
&gt; 148    14   63
&gt; 149    30   70
&gt; 150    NA   77
&gt; 151    14   75
&gt; 152    18   76
&gt; 153    20   68
```

]

.panel[.panel-name[Solución Ej. 5]


```r
# Construimos las fechas (pegamos año-mes-día con "-")
fechas &lt;- 
  as.Date(paste("1973", airquality$Month, airquality$Day,
                sep = "-"))

# Añadimos
data.frame(airquality, fechas)
```

```
&gt;     Ozone Solar.R Wind Temp Month Day     fechas
&gt; 1      41     190  7.4   67     5   1 1973-05-01
&gt; 2      36     118  8.0   72     5   2 1973-05-02
&gt; 3      12     149 12.6   74     5   3 1973-05-03
&gt; 4      18     313 11.5   62     5   4 1973-05-04
&gt; 5      NA      NA 14.3   56     5   5 1973-05-05
&gt; 6      28      NA 14.9   66     5   6 1973-05-06
&gt; 7      23     299  8.6   65     5   7 1973-05-07
&gt; 8      19      99 13.8   59     5   8 1973-05-08
&gt; 9       8      19 20.1   61     5   9 1973-05-09
&gt; 10     NA     194  8.6   69     5  10 1973-05-10
&gt; 11      7      NA  6.9   74     5  11 1973-05-11
&gt; 12     16     256  9.7   69     5  12 1973-05-12
&gt; 13     11     290  9.2   66     5  13 1973-05-13
&gt; 14     14     274 10.9   68     5  14 1973-05-14
&gt; 15     18      65 13.2   58     5  15 1973-05-15
&gt; 16     14     334 11.5   64     5  16 1973-05-16
&gt; 17     34     307 12.0   66     5  17 1973-05-17
&gt; 18      6      78 18.4   57     5  18 1973-05-18
&gt; 19     30     322 11.5   68     5  19 1973-05-19
&gt; 20     11      44  9.7   62     5  20 1973-05-20
&gt; 21      1       8  9.7   59     5  21 1973-05-21
&gt; 22     11     320 16.6   73     5  22 1973-05-22
&gt; 23      4      25  9.7   61     5  23 1973-05-23
&gt; 24     32      92 12.0   61     5  24 1973-05-24
&gt; 25     NA      66 16.6   57     5  25 1973-05-25
&gt; 26     NA     266 14.9   58     5  26 1973-05-26
&gt; 27     NA      NA  8.0   57     5  27 1973-05-27
&gt; 28     23      13 12.0   67     5  28 1973-05-28
&gt; 29     45     252 14.9   81     5  29 1973-05-29
&gt; 30    115     223  5.7   79     5  30 1973-05-30
&gt; 31     37     279  7.4   76     5  31 1973-05-31
&gt; 32     NA     286  8.6   78     6   1 1973-06-01
&gt; 33     NA     287  9.7   74     6   2 1973-06-02
&gt; 34     NA     242 16.1   67     6   3 1973-06-03
&gt; 35     NA     186  9.2   84     6   4 1973-06-04
&gt; 36     NA     220  8.6   85     6   5 1973-06-05
&gt; 37     NA     264 14.3   79     6   6 1973-06-06
&gt; 38     29     127  9.7   82     6   7 1973-06-07
&gt; 39     NA     273  6.9   87     6   8 1973-06-08
&gt; 40     71     291 13.8   90     6   9 1973-06-09
&gt; 41     39     323 11.5   87     6  10 1973-06-10
&gt; 42     NA     259 10.9   93     6  11 1973-06-11
&gt; 43     NA     250  9.2   92     6  12 1973-06-12
&gt; 44     23     148  8.0   82     6  13 1973-06-13
&gt; 45     NA     332 13.8   80     6  14 1973-06-14
&gt; 46     NA     322 11.5   79     6  15 1973-06-15
&gt; 47     21     191 14.9   77     6  16 1973-06-16
&gt; 48     37     284 20.7   72     6  17 1973-06-17
&gt; 49     20      37  9.2   65     6  18 1973-06-18
&gt; 50     12     120 11.5   73     6  19 1973-06-19
&gt; 51     13     137 10.3   76     6  20 1973-06-20
&gt; 52     NA     150  6.3   77     6  21 1973-06-21
&gt; 53     NA      59  1.7   76     6  22 1973-06-22
&gt; 54     NA      91  4.6   76     6  23 1973-06-23
&gt; 55     NA     250  6.3   76     6  24 1973-06-24
&gt; 56     NA     135  8.0   75     6  25 1973-06-25
&gt; 57     NA     127  8.0   78     6  26 1973-06-26
&gt; 58     NA      47 10.3   73     6  27 1973-06-27
&gt; 59     NA      98 11.5   80     6  28 1973-06-28
&gt; 60     NA      31 14.9   77     6  29 1973-06-29
&gt; 61     NA     138  8.0   83     6  30 1973-06-30
&gt; 62    135     269  4.1   84     7   1 1973-07-01
&gt; 63     49     248  9.2   85     7   2 1973-07-02
&gt; 64     32     236  9.2   81     7   3 1973-07-03
&gt; 65     NA     101 10.9   84     7   4 1973-07-04
&gt; 66     64     175  4.6   83     7   5 1973-07-05
&gt; 67     40     314 10.9   83     7   6 1973-07-06
&gt; 68     77     276  5.1   88     7   7 1973-07-07
&gt; 69     97     267  6.3   92     7   8 1973-07-08
&gt; 70     97     272  5.7   92     7   9 1973-07-09
&gt; 71     85     175  7.4   89     7  10 1973-07-10
&gt; 72     NA     139  8.6   82     7  11 1973-07-11
&gt; 73     10     264 14.3   73     7  12 1973-07-12
&gt; 74     27     175 14.9   81     7  13 1973-07-13
&gt; 75     NA     291 14.9   91     7  14 1973-07-14
&gt; 76      7      48 14.3   80     7  15 1973-07-15
&gt; 77     48     260  6.9   81     7  16 1973-07-16
&gt; 78     35     274 10.3   82     7  17 1973-07-17
&gt; 79     61     285  6.3   84     7  18 1973-07-18
&gt; 80     79     187  5.1   87     7  19 1973-07-19
&gt; 81     63     220 11.5   85     7  20 1973-07-20
&gt; 82     16       7  6.9   74     7  21 1973-07-21
&gt; 83     NA     258  9.7   81     7  22 1973-07-22
&gt; 84     NA     295 11.5   82     7  23 1973-07-23
&gt; 85     80     294  8.6   86     7  24 1973-07-24
&gt; 86    108     223  8.0   85     7  25 1973-07-25
&gt; 87     20      81  8.6   82     7  26 1973-07-26
&gt; 88     52      82 12.0   86     7  27 1973-07-27
&gt; 89     82     213  7.4   88     7  28 1973-07-28
&gt; 90     50     275  7.4   86     7  29 1973-07-29
&gt; 91     64     253  7.4   83     7  30 1973-07-30
&gt; 92     59     254  9.2   81     7  31 1973-07-31
&gt; 93     39      83  6.9   81     8   1 1973-08-01
&gt; 94      9      24 13.8   81     8   2 1973-08-02
&gt; 95     16      77  7.4   82     8   3 1973-08-03
&gt; 96     78      NA  6.9   86     8   4 1973-08-04
&gt; 97     35      NA  7.4   85     8   5 1973-08-05
&gt; 98     66      NA  4.6   87     8   6 1973-08-06
&gt; 99    122     255  4.0   89     8   7 1973-08-07
&gt; 100    89     229 10.3   90     8   8 1973-08-08
&gt; 101   110     207  8.0   90     8   9 1973-08-09
&gt; 102    NA     222  8.6   92     8  10 1973-08-10
&gt; 103    NA     137 11.5   86     8  11 1973-08-11
&gt; 104    44     192 11.5   86     8  12 1973-08-12
&gt; 105    28     273 11.5   82     8  13 1973-08-13
&gt; 106    65     157  9.7   80     8  14 1973-08-14
&gt; 107    NA      64 11.5   79     8  15 1973-08-15
&gt; 108    22      71 10.3   77     8  16 1973-08-16
&gt; 109    59      51  6.3   79     8  17 1973-08-17
&gt; 110    23     115  7.4   76     8  18 1973-08-18
&gt; 111    31     244 10.9   78     8  19 1973-08-19
&gt; 112    44     190 10.3   78     8  20 1973-08-20
&gt; 113    21     259 15.5   77     8  21 1973-08-21
&gt; 114     9      36 14.3   72     8  22 1973-08-22
&gt; 115    NA     255 12.6   75     8  23 1973-08-23
&gt; 116    45     212  9.7   79     8  24 1973-08-24
&gt; 117   168     238  3.4   81     8  25 1973-08-25
&gt; 118    73     215  8.0   86     8  26 1973-08-26
&gt; 119    NA     153  5.7   88     8  27 1973-08-27
&gt; 120    76     203  9.7   97     8  28 1973-08-28
&gt; 121   118     225  2.3   94     8  29 1973-08-29
&gt; 122    84     237  6.3   96     8  30 1973-08-30
&gt; 123    85     188  6.3   94     8  31 1973-08-31
&gt; 124    96     167  6.9   91     9   1 1973-09-01
&gt; 125    78     197  5.1   92     9   2 1973-09-02
&gt; 126    73     183  2.8   93     9   3 1973-09-03
&gt; 127    91     189  4.6   93     9   4 1973-09-04
&gt; 128    47      95  7.4   87     9   5 1973-09-05
&gt; 129    32      92 15.5   84     9   6 1973-09-06
&gt; 130    20     252 10.9   80     9   7 1973-09-07
&gt; 131    23     220 10.3   78     9   8 1973-09-08
&gt; 132    21     230 10.9   75     9   9 1973-09-09
&gt; 133    24     259  9.7   73     9  10 1973-09-10
&gt; 134    44     236 14.9   81     9  11 1973-09-11
&gt; 135    21     259 15.5   76     9  12 1973-09-12
&gt; 136    28     238  6.3   77     9  13 1973-09-13
&gt; 137     9      24 10.9   71     9  14 1973-09-14
&gt; 138    13     112 11.5   71     9  15 1973-09-15
&gt; 139    46     237  6.9   78     9  16 1973-09-16
&gt; 140    18     224 13.8   67     9  17 1973-09-17
&gt; 141    13      27 10.3   76     9  18 1973-09-18
&gt; 142    24     238 10.3   68     9  19 1973-09-19
&gt; 143    16     201  8.0   82     9  20 1973-09-20
&gt; 144    13     238 12.6   64     9  21 1973-09-21
&gt; 145    23      14  9.2   71     9  22 1973-09-22
&gt; 146    36     139 10.3   81     9  23 1973-09-23
&gt; 147     7      49 10.3   69     9  24 1973-09-24
&gt; 148    14      20 16.6   63     9  25 1973-09-25
&gt; 149    30     193  6.9   70     9  26 1973-09-26
&gt; 150    NA     145 13.2   77     9  27 1973-09-27
&gt; 151    14     191 14.3   75     9  28 1973-09-28
&gt; 152    18     131  8.0   76     9  29 1973-09-29
&gt; 153    20     223 11.5   68     9  30 1973-09-30
```

]

]


---

name: estructuras
class: center, middle

# Extra: estructuras de control

## **if-else y bucles**

&amp;nbsp;

A veces necesitaremos algunas estructuras de control para guiar nuestro código

---

# Estructuras if-else

`if-else` es una de las **estructuras de control** más famosas: **SI** las condiciones impuestas se cumplen (`TRUE`), ejecuta las **órdenes que tengamos dentro del `if {}`. 


```r
edades &lt;- c(14, 17, 24, 56, 31, 20, 87, 73)
if (any(edades &lt; 18)) { # TRUE si al menos una persona mayor de edad
  print("existe alguna persona mayor de edad")
}
```

```
&gt; [1] "existe alguna persona mayor de edad"
```


```r
if (all(edades &gt;= 18)) { # TRUE si TODOS son mayores de edad
  print("todas las personas son mayores de edad")
}
```

Si no se cumple no hace nada salvo que añadamos un `else {}` (con lo que sucede cuando no sucede)


```r
if (all(edades &gt;= 18)) { # TRUE si TODOS son mayores de edad
  print("todas las personas son mayores de edad")
} else { # si hay alguno menor de edad 
  print("existe alguna persona menor de edad")
}
```

```
&gt; [1] "existe alguna persona menor de edad"
```

---

# Estructuras if-else

Con `ifelse` podemos plantear una **estructura condicional en formato vectorial**, en una sola línea de código, pasándole tres argumentos:

* la condición a cumplir
* lo que asignamos cuando se cumple
* lo que asignamos cuando no se cumple


```r
edades &lt;- c(14, 17, 24, 56, 31, 20, 87, 73)
edades_nuevas &lt;-
  ifelse(edades &lt;= 18, "menor", "mayor")
edades_nuevas
```

```
&gt; [1] "menor" "menor" "mayor" "mayor" "mayor" "mayor" "mayor" "mayor"
```


---

# Bucles (a evitar)

* `for`: bucle que permite **repetir** el mismo código un **número fijo** de veces.


```r
library(glue)
nombres &lt;- c("Javi", "Laura")
edades &lt;- c(32, 51)

# Recorremos cada uno de los nombres e imprimimos un mensaje que depende de i
*for (i in 1:length(nombres)) {
  print(glue("{nombres[i]} tiene {edades[i]} años")) 
}
```

```
&gt; Javi tiene 32 años
&gt; Laura tiene 51 años
```

* `while`: **repetir** un **número indeterminado** de veces hasta que se **deje de cumplir una condición**.


```r
ciclos &lt;- 1
*while(ciclos &lt;= 3) {
  print(paste("Todavía no, vamos por el ciclo ", ciclos))
  ciclos &lt;- ciclos + 1
}
```

```
&gt; [1] "Todavía no, vamos por el ciclo  1"
&gt; [1] "Todavía no, vamos por el ciclo  2"
&gt; [1] "Todavía no, vamos por el ciclo  3"
```

---


# Bucles (a evitar)

Los **bucles** en `R` suelen ser **bastante ineficiente** y solemos tener** estructuras más eficientes**. Por ejemplo, imagina que queremos calcular el cuadrado de todos los números desde el 1 hasta el 500.

* **Opción sin bucle**: definir la secuencia `1:500` y elevarla al cuadrado con `(1:500)^2`

* **Opción con bucle**


```r
for (i in 1:1:500) {
  i^2
}
```

Para comprobar la **eficiencia en tiempo** podemos usar el paquete `{microbenchmark}`: le pasamos las dos órdenes a comparar, y el número de veces `times` que ejecutaremos cada una para calcular tiempos medios.


```r
# install.packages("microbenchmark")
library(microbenchmark)
microbenchmark((1:500)^2, for (i in 1:1:500) {i^2}, times = 300)
```

```
&gt; Unit: microseconds
&gt;                            expr    min     lq        mean  median      uq
&gt;                       (1:500)^2    1.2    1.8    4.395667    3.20    5.20
&gt;  for (i in 1:1:500) {     i^2 } 1556.5 1639.2 2190.981333 1844.75 2510.05
&gt;     max neval
&gt;    49.1   300
&gt;  7137.8   300
```

---

class: inverse center middle

# Bloque II: Introducción al manejo de datos.

&amp;nbsp;

.left[

### 👉 [Funciones](#proyecto-funciones)

### 👉 [Datos tibble](#tibble)

### 👉 [Tidy data: ordenando los datos](#tidy-data)

### 👉 [Introducción a Tidyverse](#tidyverse)

### 👉 [Introducción a purrr (listas)](#purrr)

### 👉 [Relacionando datos: joins](#joins)

]

---

name: repaso-1
class: center, middle

# Repaso

Previously on Breaking Bad...

![](https://occ-0-1722-1723.1.nflxso.net/dnm/api/v6/E8vDc_W8CLv7-yMQu8KMEC7Rrr8/AAAABeq9Fg04r6qPCr1dq7VKOglPPuluLbGBoyy60tgKnh9KsXWh5Y2VaY7jDWhrl4QQV1NhshZxCtLJrM_3V_WJc5J0p-eW.jpg?r=776)

---

# Repaso: tipos de datos


&lt;img src = "https://miro.medium.com/max/727/0*MgEQsDgZZ7fJcdhZ.png" alt = "course-ECI" align = "left" width = "990" style = "margin-top: -5vh;margin-right: 0.5rem;margin-left: 0.5rem;"&gt;


https://medium.com/@tiwarigaurav2512

---

class: center, middle

# **¿SEGUIMOS?**

![](https://elsitioderuife.files.wordpress.com/2012/10/lenny-simpsons.jpg)

---

name: proyecto-funciones
class: center, middle

# Uso de funciones

## **encapsulando y ordenando nuestro código**

&amp;nbsp;

Las funciones nos servirán para **encapsular nuestro código** de forma que podamos usarlo muchas veces sin necesidad de escribirlo de nuevo.

---

# Funciones

No solo podemos usar las funciones predeterminadas, como `sum()` o `paste()`, sino que además podemos **crear nuestras propias funciones**, para automatizar **tareas que vayamos a repetir**, y evitarnos líneas y líneas de código, horas y horas de programación.

**¿Cómo crear nuestra propia función?** Veamos su **esquema básico**:

* Un **nombre**, por ejemplo `nombre_funcion`.
* A dicho nombre le asignamos `&lt;-` la palabra reservada `function()`.
* Dentro de `function()` definimos los **argumentos de entrada**.
* Dentro de `{}` incluiremos las órdenes.
* Finalizaremos la función con `return()` indicando lo que queremos **devolver**.


```r
nombre_funcion &lt;- function(argumento_1, argumento_2, ... ) {
  
  # Código que queramos ejecutar en la función
  código
  
  # Salida
  return(variable_salida)
}
```

**IMPORTANTE**: las variables que definamos dentro de la función son **locales, solo existirán dentro de la función** salvo que especifiquemos lo contrario.

---

# Funciones

Un **ejemplo muy simple**: una función para **calcular el área de un rectángulo**. Los **argumentos de entrada** serán los **lados** y el valor a **devolver** será el área (el producto de los lados).


```r
# Definición del nombre de función y argumentos de entrada
calcular_area &lt;- function(lado_1, lado_2) {

  # Resultado que devolvemos
  return(lado_1 * lado_2)
  
}
```

**¿Cómo aplicar la función?**


```r
# Aplicación de la función con los parámetros por defecto
calcular_area(5, 3) # área de un rectángulo 5 x 3 
```

```
&gt; [1] 15
```

---

# Funciones

Imagina que nos damos cuenta que el **90% de las veces el área que nos toca calcular fuese la de un cuadrado**, es decir, solo necesitamos un argumento, un lado: `R` nos permite **definir argumentos por defecto** en la función (tomarán dicho valor salvo que le asignemos otro).

**¿Por qué no asignar `lado_2 = lado_1` por defecto?**


```r
# Definición del nombre de función y argumentos de entrada
calcular_area &lt;- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area &lt;- lado_1 * lado_2
  
  # Resultado que devolvemos
  return(area)
  
}
```

Ahora, **si no indicamos nada por defecto el segundo lado será igual al primero** (un cuadrado).


```r
calcular_area(lado_1 = 5)
```

```
&gt; [1] 25
```

---

# Funciones

**Compliquemos un poco la función** y añadamos en la salida los valores de cada lado.


```r
calcular_area &lt;- function(lado_1, lado_2 = lado_1) {
  
  # Cuerpo de la función
  area &lt;- lado_1 * lado_2
  
  # Resultado
  return(c("area" = area, "lado_1" = lado_1, "lado_2" = lado_2))
}

salida &lt;- calcular_area(lado_1 = 5, lado_2 = 3)
salida
```

```
&gt;   area lado_1 lado_2 
&gt;     15      5      3
```

```r
salida["area"]
```

```
&gt; area 
&gt;   15
```

---

# Ejercicios de funciones


.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: modifica el código inferior para definir una función llamada `funcion_suma`, de forma que dados dos elementos, devuelve su suma.


```r
# Definimos función
nombre &lt;- function(x, y) {
  # Sumamos
  suma &lt;- # código a ejecutar
  # ¿Qué devolvemos?
  return()
}
```

* 📝 **Ejercicio 2**: modifica el código para definir una función llamada `funcion_producto`, de forma que dados dos elementos, devuelve su producto.

* 📝 **Ejercicio 3**: modifica el código para definir una función llamada `funcion_producto`, pero que por defecto calcule el cuadrado.

* 📝 **Ejercicio 4**: define una función llamada igualdad_nombres que, dados dos `nombres persona_1` e `persona_2`, nos diga si son iguales o no. Hazlo considerando importantes las mayúsculas, y sin que importen las mayúsculas. Recuerda que con `toupper()` podemos pasar todo un texto a mayúscula.

]

.panel[.panel-name[Solución Ej. 1]


```r
# Definimos función
funcion_suma &lt;- function(x, y) {
  
  # Sumamos
  suma &lt;- x + y
  
  # Devolvemos la salida
  return(suma)
}

# Aplicamos la función
funcion_suma(3, 7)
```

```
&gt; [1] 10
```

]

.panel[.panel-name[Solución Ej. 2]


```r
# Definimos función
funcion_producto &lt;- function(x, y) {
  
  # Multiplicamos
  producto &lt;- x * y
  
  # Devolvemos la salida
  return(producto)
}

# Aplicamos la función
funcion_producto(3, -7)
```

```
&gt; [1] -21
```

]

.panel[.panel-name[Solución Ej. 3]


```r
# Definimos función
funcion_producto &lt;- function(x, y = x) {
  
  # Multiplicamos
  producto &lt;- x * y
  
  # Devolvemos la salida
  return(producto)
}

# Aplicamos la función
funcion_producto(3) # por defecto x = 3, y = 3
```

```
&gt; [1] 9
```

```r
funcion_producto(3, -7)
```

```
&gt; [1] -21
```
]

.panel[.panel-name[Solución Ej. 4]

```r
# Distinguiendo mayúsculas
igualdad_nombres &lt;- function(persona_1, persona_2) {
  
  return(persona_1 == persona_2)
}
igualdad_nombres("Javi", "javi")
```

```
&gt; [1] FALSE
```

```r
igualdad_nombres("Javi", "Lucía")
```

```
&gt; [1] FALSE
```

```r
# Sin importar mayúsculas
igualdad_nombres &lt;- function(persona_1, persona_2) {
  
  return(toupper(persona_1) == toupper(persona_2))
}
igualdad_nombres("Javi", "javi")
```

```
&gt; [1] TRUE
```

```r
igualdad_nombres("Javi", "Lucía")
```

```
&gt; [1] FALSE
```
]

]

---

name: tibble
class: center, middle

# Mejorando los datos: tibble

![](./img/meme_gato.jpg)

## **mejorando los data.frame**

&amp;nbsp;

Un **dato de tipo tibble** será un `data.frame` mejorado: más ágil, más rápido y más cómodo.

---

# Tibble

Los **datos en formato tibble** (del paquete `{tibble}` incluido ya en `{tidyverse}`) son un tipo de `data.frame` mejorado, para una **gestión más ágil, eficiente y coherente**. Las tablas en formato `tibble` tienen **4 ventajas principales**:

* Imprime **mayor información de las variables**, y solo **imprime por defecto las primeras filas**.


```r
library(tibble)
# tibble
tabla_tb &lt;- tibble("x" = 1:30, "y" = rep(c("a", "b", "c"), 10),
                   "z" = 31:60, "logica" = rep(c(TRUE, TRUE, FALSE), 10))
tabla_tb
```

```
&gt; # A tibble: 30 x 4
&gt;        x y         z logica
&gt;    &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; 
&gt;  1     1 a        31 TRUE  
&gt;  2     2 b        32 TRUE  
&gt;  3     3 c        33 FALSE 
&gt;  4     4 a        34 TRUE  
&gt;  5     5 b        35 TRUE  
&gt;  6     6 c        36 FALSE 
&gt;  7     7 a        37 TRUE  
&gt;  8     8 b        38 TRUE  
&gt;  9     9 c        39 FALSE 
&gt; 10    10 a        40 TRUE  
&gt; # ... with 20 more rows
```

---

# Tibble

Los **datos en formato tibble** (del paquete `{tibble}`) son un tipo de `data.frame` mejorado, para una **gestión más ágil, eficiente y coherente**. Las tablas en formato `tibble` tienen **4 ventajas principales**:

* Mantiene la **integridad de los datos** (no cambia los tipos de las variables y hace una carga de datos inteligente).


```r
tibble("fecha" = as.Date(c("1989-01-01", "1989-02-01", "1989-03-01")),
       "valores" = 1:3)
```

```
&gt; # A tibble: 3 x 2
&gt;   fecha      valores
&gt;   &lt;date&gt;       &lt;int&gt;
&gt; 1 1989-01-01       1
&gt; 2 1989-02-01       2
&gt; 3 1989-03-01       3
```

---

# Tibble

Los **datos en formato tibble** (del paquete `{tibble}`) son un tipo de `data.frame` mejorado, para una **gestión más ágil, eficiente y coherente**. Las tablas en formato `tibble` tienen **4 ventajas principales**:

* La función `tibble()` **construye las variables secuencialmente**.


```r
# data.frame
data.frame("x" = 1:3, "z" = 11:13, "x*z" = x * z)
```

```
&gt; Error in x * z: arreglos de dimensón no compatibles
```


```r
# tibble
tabla_tb &lt;- tibble("x" = 1:3, "z" = 11:13, "x*z" = x * z)
tabla_tb
```

```
&gt; # A tibble: 3 x 3
&gt;       x     z `x*z`
&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;
&gt; 1     1    11    11
&gt; 2     2    12    24
&gt; 3     3    13    39
```

---

# Tibble

Puedes consultar **más funcionalidades** de dichos datos en &lt;https://tibble.tidyverse.org/&gt;. Ahora además de poder ver una cabecera de las filas con `head()` tenemos la función `glimpse()`, que nos permite **obtener el resumen de columnas**


```r
glimpse(tabla_tb)
```

```
&gt; Rows: 3
&gt; Columns: 3
&gt; $ x     &lt;int&gt; 1, 2, 3
&gt; $ z     &lt;int&gt; 11, 12, 13
&gt; $ `x*z` &lt;int&gt; 11, 24, 39
```

Si ya tienes un `data.frame` es altamente recomendable **convertirlo a tibble** con `as_tibble()`. Prueba además el paquete `{datapasta}`, que nos permite **copiar y pegar tablas de páginas web**, conviertiéndolas en formato `tribble` (tablas `tibble` fila a fila).


```r
datos &lt;- tribble(
  ~colA, ~colB,
  "a",   1,
  "b",   2,
)
datos
```

```
&gt; # A tibble: 2 x 2
&gt;   colA   colB
&gt;   &lt;chr&gt; &lt;dbl&gt;
&gt; 1 a         1
&gt; 2 b         2
```

---

name: tidy-data
class: center, middle

# Importando datos

## **Cargando datos**

&amp;nbsp;

En `{tidyverse}` no solo tenemos distintas funciones para cargar archivos (los paquetes `{readr}`, `{readxl}`, `{haven}`, `{rvest}` o `{googlesheets4}` como ejemplos) sino que disponemos de distintos paquetes para la carga de datos desde API como las del **AEMET, Our World in Data, Eurostat, Twitter o Spotify**.

---

# Importando archivos

El paquete `{readr}` dentro del entorno `{tidyverse}` contiene distintas funciones útiles para la carga de **datos rectangulares** (sin formatear).

* `read_csv()`: archivos `.csv` cuyo separador sea la coma `,`
* `read_csv2()`: archivos `.csv` cuyo separado sea la coma `;`
* `read_tsv()`: archivos cuyos valores estén separados por un tabulador.
* `read_delim()`: función general para leer archivos delimitados por caracteres.

Todos necesitan como argumento la **ruta del archivo**, amén de otros argumentos opcionales (saltar o no cabecera, si los decimales son con punto o coma, etc)

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://github.com/rstudio/cheatsheets/raw/main/pngs/thumbnails/data-import-cheatsheet-thumbs.png" alt="Resumen del paquete `{readr}`. Ver más en https://readr.tidyverse.org/" width="65%" /&gt;
&lt;p class="caption"&gt;Resumen del paquete `{readr}`. Ver más en https://readr.tidyverse.org/&lt;/p&gt;
&lt;/div&gt;

---

# Importando archivos

El paquete `{readxl}` contiene distintas funciones útiles para la carga de **archivos formateados por Excel** 

* `read_excel()`: para archivos Excel en general.
* `read_xls()`: para archivos `.xls` en particular
* `read_xlsx()`: para archivos `.xlsx` en particular

&amp;nbsp;

El paquete `{haven}` contiene distintas funciones útiles para la carga de **archivos de SAS, SPSS y Stata**. En todos los paquetes mencionados, podemos ejecutar funciones equivalentes `write_...()` para exportar dichos datos y guardarlos en los formatos mencionados.

&amp;nbsp;

El paquete `{rvest}` contiene distintas funciones útiles para screpear web sencillas como wikipedia. Puedes ver más información en &lt;https://rvest.tidyverse.org/&gt;


---

name: tidy-data
class: center, middle

# Tidy data

## **Ordenando los datos**

&amp;nbsp;

&gt; Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio).

---

# Tidy data: filosofía de trabajo

Hasta ahora solo le hemos dado importancia al «qué» pero no al **«cómo» manejamos los datos**.

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/flujo_tidy_data.jpg" alt="Flujo deseable de datos según Hadley Wickham, extraída de https://r4ds.had.co.nz/wrangle-intro.html" width="60%" /&gt;
&lt;p class="caption"&gt;Flujo deseable de datos según Hadley Wickham, extraída de https://r4ds.had.co.nz/wrangle-intro.html&lt;/p&gt;
&lt;/div&gt;

La **organización de nuestros datos** es fundamental para que su preparación y explotación sea lo más eficiente posible.

&amp;nbsp;

El concepto **tidy data** fue introducido por **Hadley Wickham** como el primer paso a realizar del entorno de paquetes que posteriormente se fueron desarrollando bajo el nombre de `{tidyverse}`, desarrollando un flujo de trabajo desde la carga hasta la visualización


---

# Tidy data

Los **conjuntos tidy o datos ordenados** tienen tres objetivos principales:

1. **Estandarización** en su estructura.
2. **Sencillez** en su manipulación.
3. Listos para ser **modelizados y visualizados**.

Para ello, los **datos ordenados o tidy data** deben cumplir:

* Cada **variable en una columna**.
* Cada **observación/registro/individuo en una fila** diferente.
* Cada **celda con un único valor**.
* Cada **conjunto** o unidad observacional conforma una **tabla**.

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/tidy_data.png" alt="Infografía con datos ordenados (tidy data) extraída de https://r4ds.had.co.nz/tidy-data.html" width="67%" /&gt;
&lt;p class="caption"&gt;Infografía con datos ordenados (tidy data) extraída de https://r4ds.had.co.nz/tidy-data.html&lt;/p&gt;
&lt;/div&gt;

Lo contrario lo llamaremos **datos desordenados** o _messy data_. 

---


# Messy data: valores en el nombre

Veamos un primer ejemplo con el conjunto `table4a` del paquete `{tidyr}`.


```r
library(tidyr)
table4a
```

```
&gt; # A tibble: 3 x 3
&gt;   country     `1999` `2000`
&gt; * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;
&gt; 1 Afghanistan    745   2666
&gt; 2 Brazil       37737  80488
&gt; 3 China       212258 213766
```

En este ejemplo de 3 filas y 3 columnas, tenemos dos columnas `1999` y `2000` que **no están representando cada una a una sola variable**: ambas son la misma variable, solo que medida en años distintos, **cada fila está representando dos observaciones (1999, 2000) en lugar de un solo registro**.

Lo que haremos será **incluir una nueva columna llamada `year`** que nos marque el año y otra `values` que nos diga el valor de la variable de interés en cada uno de esos años.

---

# pivot_longer: pivotando tablas


.pull-left[

Con la función `pivot_longer` del mencionado paquete le indicaremos lo siguiente:

* `cols`: **nombre de las columnas a pivotar**.
* `names_to`: nombre de la columna a la que vamos a mandar los valores que figuran ahora en los nombres de las columnas.
* `values_to`: nombre de la columna a la que vamos a mandar los valores.


```r
table4a %&gt;%
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year",
*              values_to = "values")
```

```
&gt; # A tibble: 6 x 3
&gt;   country     year  values
&gt;   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;
&gt; 1 Afghanistan 1999     745
&gt; 2 Afghanistan 2000    2666
&gt; 3 Brazil      1999   37737
&gt; 4 Brazil      2000   80488
&gt; 5 China       1999  212258
&gt; 6 China       2000  213766
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/tidy1.jpg" alt="Imagen extraída de https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf" width="99%" /&gt;
&lt;p class="caption"&gt;Imagen extraída de https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf&lt;/p&gt;
&lt;/div&gt;

]



---

# Segundo ejemplo: relig_income


```r
relig_income[1:3, ]
```

```
&gt; # A tibble: 3 x 11
&gt;   religion `&lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`
&gt;   &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
&gt; 1 Agnostic      27        34        60        81        76       137        122
&gt; 2 Atheist       12        27        37        52        35        70         73
&gt; 3 Buddhist      27        21        30        34        33        58         62
&gt; # ... with 3 more variables: `$100-150k` &lt;dbl&gt;, `&gt;150k` &lt;dbl&gt;,
&gt; #   `Don't know/refused` &lt;dbl&gt;
```

Salvo la primera, el **resto de columnas tienen como nombre los valores de una variable en sí misma (ingresos)**. Ahora en lugar de indicarle el nombre de todas vamos a indicarle **la columna que NO queremos pivotar**.


```r
# No necesitamos comillas en el nombre salvo que tengan caracteres que no sean letras
*relig_income %&gt;% pivot_longer(-religion, names_to = "ingresos", values_to = "frec")
```

```
&gt; # A tibble: 180 x 3
&gt;    religion ingresos            frec
&gt;    &lt;chr&gt;    &lt;chr&gt;              &lt;dbl&gt;
&gt;  1 Agnostic &lt;$10k                 27
&gt;  2 Agnostic $10-20k               34
&gt;  3 Agnostic $20-30k               60
&gt;  4 Agnostic $30-40k               81
&gt;  5 Agnostic $40-50k               76
&gt;  6 Agnostic $50-75k              137
&gt;  7 Agnostic $75-100k             122
&gt;  8 Agnostic $100-150k            109
&gt;  9 Agnostic &gt;150k                 84
&gt; 10 Agnostic Don't know/refused    96
&gt; # ... with 170 more rows
```

---

# Messy data: un registro en varias filas

.pull-left[

El **caso inverso**: tener un mismo registro (datos de un mismo individuo) pero dividido en varias filas con `pivot_wider()` **«ampliaremos» la tabla a lo ancho**


```r
table2[1:3, ]
```

```
&gt; # A tibble: 3 x 4
&gt;   country      year type          count
&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;         &lt;int&gt;
&gt; 1 Afghanistan  1999 cases           745
&gt; 2 Afghanistan  1999 population 19987071
&gt; 3 Afghanistan  2000 cases          2666
```



```r
table2 %&gt;%
  pivot_wider(names_from = type,
*             values_from = count)
```

```
&gt; # A tibble: 6 x 4
&gt;   country      year  cases population
&gt;   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
&gt; 1 Afghanistan  1999    745   19987071
&gt; 2 Afghanistan  2000   2666   20595360
&gt; 3 Brazil       1999  37737  172006362
&gt; 4 Brazil       2000  80488  174504898
&gt; 5 China        1999 212258 1272915272
&gt; 6 China        2000 213766 1280428583
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/tidy2.jpg" alt="Imagen extraída de https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf" width="99%" /&gt;
&lt;p class="caption"&gt;Imagen extraída de https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf&lt;/p&gt;
&lt;/div&gt;

]

---

# Messy data: múltiples valores en celda

.pull-left[


```r
table3
```


```
&gt; # A tibble: 4 x 3
&gt;   country      year rate           
&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;          
&gt; 1 Afghanistan  1999 745/19987071   
&gt; 2 Afghanistan  2000 2666/20595360  
&gt; 3 Brazil       1999 37737/172006362
&gt; 4 Brazil       2000 80488/174504898
```

En la columna `rate` hay **guardados dos valores, separados por /**, en una **celda no hay un único valor**. La función `separate()` nos permitirá **separar los múltiples valores**


```r
table3 %&gt;%
  separate(rate,
           into = c("cases",
*                   "population"))
```

```
&gt; # A tibble: 6 x 4
&gt;   country      year cases  population
&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     
&gt; 1 Afghanistan  1999 745    19987071  
&gt; 2 Afghanistan  2000 2666   20595360  
&gt; 3 Brazil       1999 37737  172006362 
&gt; 4 Brazil       2000 80488  174504898 
&gt; 5 China        1999 212258 1272915272
&gt; 6 China        2000 213766 1280428583
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/tidy3.jpg" alt="Imagen extraída de https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf" width="99%" /&gt;
&lt;p class="caption"&gt;Imagen extraída de https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf&lt;/p&gt;
&lt;/div&gt;

]

---

# Messy data: múltiples valores en celda

Si **queremos un caracter concreto para dividir** podemos indicárselo explícitamente


```r
table3 %&gt;%
  separate(rate,
           into = c("cases",
                    "population"),
           sep = "/")
```

```
&gt; # A tibble: 6 x 4
&gt;   country      year cases  population
&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     
&gt; 1 Afghanistan  1999 745    19987071  
&gt; 2 Afghanistan  2000 2666   20595360  
&gt; 3 Brazil       1999 37737  172006362 
&gt; 4 Brazil       2000 80488  174504898 
&gt; 5 China        1999 212258 1272915272
&gt; 6 China        2000 213766 1280428583
```

---

# Messy data: unite()

.pull-left[

De la misma manera que **podemos separar columnas también podemos unirlas**. Para ello vamos a usar la tabla `table5`: con la función `unite()` vamos a **unir el siglo (en century) y el año (en year)**.


```r
table5 %&gt;%
* unite(date, century, year)
```

```
&gt; # A tibble: 6 x 3
&gt;   country     date  rate             
&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;            
&gt; 1 Afghanistan 19_99 745/19987071     
&gt; 2 Afghanistan 20_00 2666/20595360    
&gt; 3 Brazil      19_99 37737/172006362  
&gt; 4 Brazil      20_00 80488/174504898  
&gt; 5 China       19_99 212258/1272915272
&gt; 6 China       20_00 213766/1280428583
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/tidy4.jpg" alt="Imagen extraída de https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf" width="99%" /&gt;
&lt;p class="caption"&gt;Imagen extraída de https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf&lt;/p&gt;
&lt;/div&gt;

]

---

# Convertir al tipo adecuado

Una opción muy útil que podemos usar al **aplicar la separación de los múltiples valores** es **convertir los datos al tipo adecuado**. Los datos unidos en `rate` eran **caracteres** (no podían ser numéricos). Al separarlos, por defecto, aunque ahora ya son solo números, **los separa como si fueran textos**. Con `convert = TRUE` podemos indicarle que identifique el tipo de dato y lo convierta.


```r
table3 %&gt;%
  separate(rate, 
           into = c("cases",
                    "population"),
           convert = TRUE)
```

```
&gt; # A tibble: 6 x 4
&gt;   country      year  cases population
&gt;   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
&gt; 1 Afghanistan  1999    745   19987071
&gt; 2 Afghanistan  2000   2666   20595360
&gt; 3 Brazil       1999  37737  172006362
&gt; 4 Brazil       2000  80488  174504898
&gt; 5 China        1999 212258 1272915272
&gt; 6 China        2000 213766 1280428583
```

---

# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]

* 📝 **Ejercicio 1**: convierte en _tidy data_ el siguiente _data.frame_.


```r
tabla_tb &lt;- tibble("trimestre" = c("T1", "T2", "T3"),
                   "2020" = c(10, 12, 7.5),
                   "2021" = c(8, 0, 9))
```

* 📝 **Ejercicio 2**: convierte en _tidy data_ el siguiente _data.frame_.
 

```r
tabla_tb &lt;- tibble("año" = c(2019, 2019, 2020, 2020, 2021, 2021),
                   "variable" = c("A", "B", "A", "B", "A", "B"),
                   "valor" = c(10, 9383, 7.58, 10839, 9, 32949))
```

* 📝 **Ejercicio 3**: convierte en _tidydata_ la tabla `table5` del paquete `{tidyr}`.

]

.panel[.panel-name[Solución Ej. 1]

El problema es que las dos columnas con nombres de año son en realidad valores que deberían pasar a ser variables, así que deberíamos disminuir aplicar `pivot_longer()`.


```r
library(tidyr)
tabla_tb &lt;- tibble("trimestre" = c("T1", "T2", "T3"),
                   "2020" = c(10, 12, 7.5),
                   "2021" = c(8, 0, 9))

# Aplicamos pivot_longer
tabla_tb %&gt;% pivot_longer(cols = c("2020", "2021"),
                          names_to = "año", values_to = "valores")
```

```
&gt; # A tibble: 6 x 3
&gt;   trimestre año   valores
&gt;   &lt;chr&gt;     &lt;chr&gt;   &lt;dbl&gt;
&gt; 1 T1        2020     10  
&gt; 2 T1        2021      8  
&gt; 3 T2        2020     12  
&gt; 4 T2        2021      0  
&gt; 5 T3        2020      7.5
&gt; 6 T3        2021      9
```


]


.panel[.panel-name[Solución Ej. 2]

El problema es que las filas que comparten año son el mismo registro (pero con dos características que tenemos divididas en dos filas), así que deberíamos disminuir aplicar `pivot_wider()`.


```r
tabla_tb &lt;- tibble("año" = c(2019, 2019, 2020, 2020, 2021, 2021),
                   "variable" = c("A", "B", "A", "B", "A", "B"),
                   "valor" = c(10, 9383, 7.58, 10839, 9, 32949))

# Aplicamos pivot_wider
tabla_tb %&gt;% pivot_wider(names_from = "variable",
                         values_from = "valor")
```

```
&gt; # A tibble: 3 x 3
&gt;     año     A     B
&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
&gt; 1  2019 10     9383
&gt; 2  2020  7.58 10839
&gt; 3  2021  9    32949
```

]

.panel[.panel-name[Solución Ej. 3]

Primero uniremos el siglo y las dos últimas cifras del año para obtener el año completo (guardado en año). Tras ello deberemos separar el valor del ratio en denominador y numerador (ya que ahora hay dos valores en una celda), y convertiremos el tipo de dato en la salida para que sea número.


```r
table5 %&gt;%
  unite(año, century, year, sep = "") %&gt;%
  separate(rate, c("numerador", "denominador"), convert = TRUE)
```

```
&gt; # A tibble: 6 x 4
&gt;   country     año   numerador denominador
&gt;   &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;       &lt;int&gt;
&gt; 1 Afghanistan 1999        745    19987071
&gt; 2 Afghanistan 2000       2666    20595360
&gt; 3 Brazil      1999      37737   172006362
&gt; 4 Brazil      2000      80488   174504898
&gt; 5 China       1999     212258  1272915272
&gt; 6 China       2000     213766  1280428583
```

]

]


---

name: tidyverse
class: center, middle

# Introducción a tidyverse

## **Manipulando (para bien) los datos**

&amp;nbsp;

El conjunto de paquetes de `{tidyverse}` supuso un antes y un después en el preprocesamiento de los datos en `R`

---

# Entorno tidyverse

Aunque conocemos ya un formato «excelizado» de almacenar los datos, muchas veces los **datos no los tenemos en el formato deseado**, o directamente queremos realizar algunas **transformaciones en los mismos**. Para trabajar con los datos vamos a cargar `{tidyverse}`, un **entorno de paquetes para el manejo de datos**.


```r
install.packages("tidyverse") # SOLO la primera vez
library(tidyverse)
```



&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://dadosdelaplace.github.io/courses-ECI-2022/img/flujo_tidyverse.png" alt="Imagen extraída de https://sporella.github.io/datos_espaciales_presentacion/#30" width="60%" /&gt;
&lt;p class="caption"&gt;Imagen extraída de https://sporella.github.io/datos_espaciales_presentacion/#30&lt;/p&gt;
&lt;/div&gt;

---

# Entorno tidyverse

El **entorno tidyverse** es una de las **herramientas más importantes en el manejo de datos en R**, una **colección de paquetes** pensada para el manejo, la exploración, el análisis y la visualización de datos, **compartiendo una misma filosofía y gramática**.

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://dadosdelaplace.github.io/courses-ECI-2022/img/flujo_tidyverse_1.png" alt="Imagen extraída de https://www.storybench.org/getting-started-with-tidyverse-in-r/" width="90%" /&gt;
&lt;p class="caption"&gt;Imagen extraída de https://www.storybench.org/getting-started-with-tidyverse-in-r/&lt;/p&gt;
&lt;/div&gt;

---

# Paquetes de tidyverse

* `{tidyr}`: para **adecuar los datos a tidy data**

* `{tibble}`: **mejorando los data.frame** para un manejo más eficiente.

* Paquetes `{readr}` para una **carga rápida y eficaz de datos rectangulares** (formatos .csv, .tsv, etc). Paquete `{readxl}` para **importar archivos .xls y .xlsx**. Paquete `{haven}` para importar archivos desde **SPSS, Stata y SAS**. Paquete `{httr}` para **importar desde web**. Paquete `{rvest}` para **web scraping**.

* `{dplyr}`: una **gramática de manipulación de datos** para facilitar su procesamiento.

* `{ggplot2}`: una **gramática para la visualización** de datos.

* Paquete `{stringr}` para un manejo sencillo de **cadenas de texto**. Paquete `{forcast}` para un manejo de **variables cualitativas** (en R conocidas como factores).

* `{purrr}`: manejo de **listas**.

* `{lubridate}` para el **manejo de fechas**.

&amp;nbsp;

Puedes ver su **documentación completa** en &lt;https://www.tidyverse.org/&gt;.

---

# Intro a tidyverse: conjunto starwars

Para nuestra **introducción de tidyverse** vamos a trastear con el conjunto de datos `starwars` del paquete `{dplyr}` (incluido en `{tidyverse}`).


.pull-left[

&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="https://rstudio-education.github.io/bootcamper/slides/02-visualize-data/img/luke-skywalker.png" alt="Imagen extraída de https://rstudio-education.github.io/" width="90%" /&gt;
&lt;p class="caption"&gt;Imagen extraída de https://rstudio-education.github.io/&lt;/p&gt;
&lt;/div&gt;
]

.pull-right[


```r
starwars
```

```
&gt; # A tibble: 87 x 14
&gt;    name     height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Luke Sk~    172    77 blond      fair       blue            19   male  mascu~
&gt;  2 C-3PO       167    75 &lt;NA&gt;       gold       yellow         112   none  mascu~
&gt;  3 R2-D2        96    32 &lt;NA&gt;       white, bl~ red             33   none  mascu~
&gt;  4 Darth V~    202   136 none       white      yellow          41.9 male  mascu~
&gt;  5 Leia Or~    150    49 brown      light      brown           19   fema~ femin~
&gt;  6 Owen La~    178   120 brown, gr~ light      blue            52   male  mascu~
&gt;  7 Beru Wh~    165    75 brown      light      blue            47   fema~ femin~
&gt;  8 R5-D4        97    32 &lt;NA&gt;       white, red red             NA   none  mascu~
&gt;  9 Biggs D~    183    84 black      light      brown           24   male  mascu~
&gt; 10 Obi-Wan~    182    77 auburn, w~ fair       blue-gray       57   male  mascu~
&gt; # ... with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

]

---

# Intro a tidyverse: conjunto starwars



```r
*glimpse(starwars)
```

```
&gt; Rows: 87
&gt; Columns: 14
&gt; $ name       &lt;chr&gt; "Luke Skywalker", "C-3PO", "R2-D2", "Darth Vader", "Leia Or~
&gt; $ height     &lt;int&gt; 172, 167, 96, 202, 150, 178, 165, 97, 183, 182, 188, 180, 2~
&gt; $ mass       &lt;dbl&gt; 77.0, 75.0, 32.0, 136.0, 49.0, 120.0, 75.0, 32.0, 84.0, 77.~
&gt; $ hair_color &lt;chr&gt; "blond", NA, NA, "none", "brown", "brown, grey", "brown", N~
&gt; $ skin_color &lt;chr&gt; "fair", "gold", "white, blue", "white", "light", "light", "~
&gt; $ eye_color  &lt;chr&gt; "blue", "yellow", "red", "yellow", "brown", "blue", "blue",~
&gt; $ birth_year &lt;dbl&gt; 19.0, 112.0, 33.0, 41.9, 19.0, 52.0, 47.0, NA, 24.0, 57.0, ~
&gt; $ sex        &lt;chr&gt; "male", "none", "none", "male", "female", "male", "female",~
&gt; $ gender     &lt;chr&gt; "masculine", "masculine", "masculine", "masculine", "femini~
&gt; $ homeworld  &lt;chr&gt; "Tatooine", "Tatooine", "Naboo", "Tatooine", "Alderaan", "T~
&gt; $ species    &lt;chr&gt; "Human", "Droid", "Droid", "Human", "Human", "Human", "Huma~
&gt; $ films      &lt;list&gt; &lt;"The Empire Strikes Back", "Revenge of the Sith", "Return~
&gt; $ vehicles   &lt;list&gt; &lt;"Snowspeeder", "Imperial Speeder Bike"&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, "Imp~
&gt; $ starships  &lt;list&gt; &lt;"X-wing", "Imperial shuttle"&gt;, &lt;&gt;, &lt;&gt;, "TIE Advanced x1",~
```

Dicho conjunto de datos, extraído de la [Star Wars API](https://swapi.dev/), recopila **14 variables para 87 personajes de Star Wars**. 


```r
dim(starwars)
```

```
&gt; [1] 87 14
```

---

# Intro a tidyverse: conjunto starwars


```r
print(starwars, n = 3, width = Inf)
```

```
&gt; # A tibble: 87 x 14
&gt;   name           height  mass hair_color skin_color  eye_color birth_year sex  
&gt;   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;
&gt; 1 Luke Skywalker    172    77 blond      fair        blue              19 male 
&gt; 2 C-3PO             167    75 &lt;NA&gt;       gold        yellow           112 none 
&gt; 3 R2-D2              96    32 &lt;NA&gt;       white, blue red               33 none 
&gt;   gender    homeworld species films     vehicles  starships
&gt;   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;   &lt;list&gt;    &lt;list&gt;    &lt;list&gt;   
&gt; 1 masculine Tatooine  Human   &lt;chr [5]&gt; &lt;chr [2]&gt; &lt;chr [2]&gt;
&gt; 2 masculine Tatooine  Droid   &lt;chr [6]&gt; &lt;chr [0]&gt; &lt;chr [0]&gt;
&gt; 3 masculine Naboo     Droid   &lt;chr [7]&gt; &lt;chr [0]&gt; &lt;chr [0]&gt;
&gt; # ... with 84 more rows
```

* `int`: números enteros (`height`).
* `dbl`: números reales (`mass`, `birth_year`).
* `chr`: cadenas de texto (`name`, `hair_color`, `skin_color`, `eye_color`, `sex`, `gender`, `homeworld`, `species`).
* `list`: listas (`films`, `vehicles`, `starships`).

---

# Intro a tidyverse: conjunto starwars

Los **datos de tipo lista** (aparecen con un icono distinto en el menú de variables) son el dato más flexible de `R`: permiten **concatenar datos de cualquier tipo PERO también de cualquier longitud**.

Por ejemplo en `starwars` tenemos guardados las películas de cada personaje en modo lista en la variable `starwars$films`. Por ejemplo, podemos extraer las películas en las que aparecen los tres primeros personajes, basta con ejecutar (del conjunto starwars –&gt; accedemos a la variable films con `$`)


```r
starwars$films[1:2]
```

```
&gt; [[1]]
&gt; [1] "The Empire Strikes Back" "Revenge of the Sith"    
&gt; [3] "Return of the Jedi"      "A New Hope"             
&gt; [5] "The Force Awakens"      
&gt; 
&gt; [[2]]
&gt; [1] "The Empire Strikes Back" "Attack of the Clones"   
&gt; [3] "The Phantom Menace"      "Revenge of the Sith"    
&gt; [5] "Return of the Jedi"      "A New Hope"
```

El paquete `{purrr}` contienen multitud de herramientas para **aplicar de forma sencilla funciones a cada elemento de una lista**.

---

# dplyr: manipulando datos

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://dadosdelaplace.github.io/courses-ECI-2022/img/dplyr.png" alt="Cheet sheet de las opciones del paquete dplyr para la manipulación de datos extraída de https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf" width="63%" /&gt;
&lt;p class="caption"&gt;Cheet sheet de las opciones del paquete dplyr para la manipulación de datos extraída de https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf&lt;/p&gt;
&lt;/div&gt;

---

# Pipeline (tuberías) %&gt;%

En este entorno de trabajo tendremos un **operador clave**: el **operador pipeline (%&gt;%)**, el cual lo debemos interpretar como una **tubería conectada a los datos por el que pasan operaciones**, de una forma legible. Con el **pipeline %&gt;%** podremos escribir (y leer) la concetanción de órdenes de forma sencilla y **léxicamente interpertable**


```r
# Idea
datos %&gt;%
  filtro(...) %&gt;%
  ordeno(...) %&gt;%
  selecciono(...) %&gt;%
  modifico(...) %&gt;%
  agrupo(...) %&gt;%
  resumo(...) %&gt;%
  visualizo(...)
```

&amp;nbsp;

Dicho operador depende del paquete `{magrittr}`: para evitar esta dependencia (cuantos menos paquetes, mejor), desde la **versión 4.1.0 de R** disponemos de un operador nativo de R, el **operador |&gt;** (disponible además fuera de tidyverse).

---

# Visualizar el flujo de datos

Existe una **reciente herramienta** que nos va a permitir **entender mejor y visualizar el flujo de trabajo** en `{tidyverse}`: &lt;https://tidydatatutor.com/&gt;. 
Basta con poner el código que queremos ejecutar, y nos **muestra visualmente las operaciones en los datos**.

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/tidytutor3.jpg" alt = "course-ECI" align = "right" width = "450" style = "margin-top: 1vh;margin-right: 0.5rem;margin-left: 0.5rem;"&gt;

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/tidytutor4.jpg" alt = "course-ECI" align = "right" width = "450" style = "margin-top: 1vh;margin-right: 0.5rem;margin-left: 0.5rem;"&gt;

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/tidytutor5.jpg" alt = "course-ECI" align = "right" width = "400" style = "margin-top: 1vh;margin-right: 0.5rem;margin-left: 0.5rem;"&gt;

---

# Filtrar filas: filter()

.pull-left[

Una de las **operaciones más comunes** es **filtrar registros en base a alguna condición**: con `filter()` se seleccionarán solo individuos que cumplan ciertas condiciones.



```r
# Idea
starwars %&gt;%
  filtro(cond1, cond2, ...)
```

&amp;nbsp;

Por ejemplo, vamos a **filtrar aquellos personajes con ojos marrones** (cumpliendo la condición `eye_color == "brown"`)


```r
starwars %&gt;%
* filter(eye_color == "brown")
```

```
&gt; # A tibble: 21 x 14
&gt;    name     height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Leia Or~    150  49   brown      light      brown           19   fema~ femin~
&gt;  2 Biggs D~    183  84   black      light      brown           24   male  mascu~
&gt;  3 Han Solo    180  80   brown      fair       brown           29   male  mascu~
&gt;  4 Yoda         66  17   white      green      brown          896   male  mascu~
&gt;  5 Boba Fe~    183  78.2 black      fair       brown           31.5 male  mascu~
&gt;  6 Lando C~    177  79   black      dark       brown           31   male  mascu~
&gt;  7 Arvel C~     NA  NA   brown      fair       brown           NA   male  mascu~
&gt;  8 Wicket ~     88  20   brown      brown      brown            8   male  mascu~
&gt;  9 Quarsh ~    183  NA   black      dark       brown           62   &lt;NA&gt;  &lt;NA&gt;  
&gt; 10 Shmi Sk~    163  NA   black      fair       brown           72   fema~ femin~
&gt; # ... with 11 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/filter1.jpg" alt="Flujo de https://tidydatatutor.com/" width="150%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]

---

# Filtrar filas: filter()

.pull-left[

El operador de comparación `==` puede ser cambiado por otros:


* `!=`: parte de la izq distinta la dcha.
* `&lt;`, `&gt;`: menor, mayor que...
* `&lt;=`, `&gt;=`: menor o igual, mayor igual que...
* `%in%`: si los valores pertenecen a una lista finita de opciones permitidas.
* `between(variable, val1, val2)`: si los valores (normalmente continuos) son mayores que `val1` y menores que `val2`


```r
starwars %&gt;%
  filter(eye_color != "brown")
```

```
&gt; # A tibble: 66 x 14
&gt;    name     height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Luke Sk~    172    77 blond      fair       blue            19   male  mascu~
&gt;  2 C-3PO       167    75 &lt;NA&gt;       gold       yellow         112   none  mascu~
&gt;  3 R2-D2        96    32 &lt;NA&gt;       white, bl~ red             33   none  mascu~
&gt;  4 Darth V~    202   136 none       white      yellow          41.9 male  mascu~
&gt;  5 Owen La~    178   120 brown, gr~ light      blue            52   male  mascu~
&gt;  6 Beru Wh~    165    75 brown      light      blue            47   fema~ femin~
&gt;  7 R5-D4        97    32 &lt;NA&gt;       white, red red             NA   none  mascu~
&gt;  8 Obi-Wan~    182    77 auburn, w~ fair       blue-gray       57   male  mascu~
&gt;  9 Anakin ~    188    84 blond      fair       blue            41.9 male  mascu~
&gt; 10 Wilhuff~    180    NA auburn, g~ fair       blue            64   male  mascu~
&gt; # ... with 56 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```



]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/filter2.jpg" alt="Flujo de https://tidydatatutor.com/" width="150%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]

---

# Filtrar filas: filter()

.pull-left[


```r
# con ojos marrones o azules o rojos
starwars %&gt;% 
  filter(eye_color %in% c("brown", "blue"))
```


```
&gt; # A tibble: 5 x 4
&gt;   name               height  mass eye_color
&gt;   &lt;chr&gt;               &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;    
&gt; 1 Luke Skywalker        172    77 blue     
&gt; 2 Leia Organa           150    49 brown    
&gt; 3 Owen Lars             178   120 blue     
&gt; 4 Beru Whitesun lars    165    75 blue     
&gt; 5 Biggs Darklighter     183    84 brown
```


```r
# con estatura entre 120 y 160 cm
starwars %&gt;%
  filter(between(height, 120, 160))
```


```
&gt; # A tibble: 5 x 4
&gt;   name        height  mass eye_color
&gt;   &lt;chr&gt;        &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;    
&gt; 1 Leia Organa    150    49 brown    
&gt; 2 Mon Mothma     150    NA blue     
&gt; 3 Nien Nunb      160    68 black    
&gt; 4 Watto          137    NA yellow   
&gt; 5 Gasgano        122    NA black
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/filter3.jpg" alt="Flujo de https://tidydatatutor.com/" width="150%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]

---


# Filtrar filas: filter()

.pull-left[

Las condiciones se pueden **concatenar**, pudiendo en pocas líneas realizar un filtro complejo

* `a &amp; b`: solo devolverá `TRUE` cuando se cumpla tanto `a` como `b`.
* `a | b`: devolverá `TRUE` cuando se cumpla al menos una de ellas (a y no b, b y no a, o ambas).

Por ejemplo, seleccionamos los **personajes con ojos marrones Y ADEMÁS NO humanos**, o los personajes con más de 60 años.


```r
starwars %&gt;%
  filter((eye_color == "brown" &amp;
            species != "Human") |
           birth_year &gt; 60)
```

```
&gt; # A tibble: 18 x 14
&gt;    name     height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 C-3PO       167    75 &lt;NA&gt;       gold       yellow           112 none  mascu~
&gt;  2 Wilhuff~    180    NA auburn, g~ fair       blue              64 male  mascu~
&gt;  3 Chewbac~    228   112 brown      unknown    blue             200 male  mascu~
&gt;  4 Jabba D~    175  1358 &lt;NA&gt;       green-tan~ orange           600 herm~ mascu~
&gt;  5 Yoda         66    17 white      green      brown            896 male  mascu~
&gt;  6 Palpati~    170    75 grey       pale       yellow            82 male  mascu~
&gt;  7 Wicket ~     88    20 brown      brown      brown              8 male  mascu~
&gt;  8 Qui-Gon~    193    89 brown      fair       blue              92 male  mascu~
&gt;  9 Finis V~    170    NA blond      fair       blue              91 male  mascu~
&gt; 10 Quarsh ~    183    NA black      dark       brown             62 &lt;NA&gt;  &lt;NA&gt;  
&gt; 11 Shmi Sk~    163    NA black      fair       brown             72 fema~ femin~
&gt; 12 Mace Wi~    188    84 none       dark       brown             72 male  mascu~
&gt; 13 Ki-Adi-~    198    82 white      pale       yellow            92 male  mascu~
&gt; 14 Eeth Ko~    171    NA black      brown      brown             NA male  mascu~
&gt; 15 Cliegg ~    183    NA brown      fair       blue              82 male  mascu~
&gt; 16 Dooku       193    80 white      fair       brown            102 male  mascu~
&gt; 17 Bail Pr~    191    NA black      tan        brown             67 male  mascu~
&gt; 18 Jango F~    183    79 black      tan        brown             66 male  mascu~
&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/filter5.jpg" alt="Flujo de https://tidydatatutor.com/" width="150%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;


]

---

# Ejercicios con filter() 

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: selecciona del conjunto de `starwars` solo los personajes que sean humanos (`species == "Human"`)

* 📝 **Ejercicio 2**: selecciona del conjunto de `starwars` solo los personajes cuyo peso esté entre 65 y 90 kg.

* 📝 **Ejercicio 3**: selecciona del conjunto de `starwars` los personajes con ojos marrones o rojos.

* 📝 **Ejercicio 4**: selecciona del conjunto de `starwars` los personajes no humanos, hombres y que midan más de 170 cm, o los personajes con ojos marrones o rojos.

]

.panel[.panel-name[Sol. Ej. 1]


```r
starwars %&gt;%
  filter(species == "Human")
```

```
&gt; # A tibble: 35 x 14
&gt;    name     height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Luke Sk~    172    77 blond      fair       blue            19   male  mascu~
&gt;  2 Darth V~    202   136 none       white      yellow          41.9 male  mascu~
&gt;  3 Leia Or~    150    49 brown      light      brown           19   fema~ femin~
&gt;  4 Owen La~    178   120 brown, gr~ light      blue            52   male  mascu~
&gt;  5 Beru Wh~    165    75 brown      light      blue            47   fema~ femin~
&gt;  6 Biggs D~    183    84 black      light      brown           24   male  mascu~
&gt;  7 Obi-Wan~    182    77 auburn, w~ fair       blue-gray       57   male  mascu~
&gt;  8 Anakin ~    188    84 blond      fair       blue            41.9 male  mascu~
&gt;  9 Wilhuff~    180    NA auburn, g~ fair       blue            64   male  mascu~
&gt; 10 Han Solo    180    80 brown      fair       brown           29   male  mascu~
&gt; # ... with 25 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

]

.panel[.panel-name[Sol. Ej. 2]


```r
starwars %&gt;%
  filter(between(mass, 65, 90))
```

```
&gt; # A tibble: 32 x 14
&gt;    name     height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Luke Sk~    172    77 blond      fair       blue            19   male  mascu~
&gt;  2 C-3PO       167    75 &lt;NA&gt;       gold       yellow         112   none  mascu~
&gt;  3 Beru Wh~    165    75 brown      light      blue            47   fema~ femin~
&gt;  4 Biggs D~    183    84 black      light      brown           24   male  mascu~
&gt;  5 Obi-Wan~    182    77 auburn, w~ fair       blue-gray       57   male  mascu~
&gt;  6 Anakin ~    188    84 blond      fair       blue            41.9 male  mascu~
&gt;  7 Han Solo    180    80 brown      fair       brown           29   male  mascu~
&gt;  8 Greedo      173    74 &lt;NA&gt;       green      black           44   male  mascu~
&gt;  9 Wedge A~    170    77 brown      fair       hazel           21   male  mascu~
&gt; 10 Palpati~    170    75 grey       pale       yellow          82   male  mascu~
&gt; # ... with 22 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

]

.panel[.panel-name[Sol. Ej. 3]


```r
starwars %&gt;%
  filter(eye_color %in% c("brown", "red"))
```

```
&gt; # A tibble: 26 x 14
&gt;    name     height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 R2-D2        96  32   &lt;NA&gt;       white, bl~ red             33   none  mascu~
&gt;  2 Leia Or~    150  49   brown      light      brown           19   fema~ femin~
&gt;  3 R5-D4        97  32   &lt;NA&gt;       white, red red             NA   none  mascu~
&gt;  4 Biggs D~    183  84   black      light      brown           24   male  mascu~
&gt;  5 Han Solo    180  80   brown      fair       brown           29   male  mascu~
&gt;  6 Yoda         66  17   white      green      brown          896   male  mascu~
&gt;  7 Boba Fe~    183  78.2 black      fair       brown           31.5 male  mascu~
&gt;  8 IG-88       200 140   none       metal      red             15   none  mascu~
&gt;  9 Bossk       190 113   none       green      red             53   male  mascu~
&gt; 10 Lando C~    177  79   black      dark       brown           31   male  mascu~
&gt; # ... with 16 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

]

.panel[.panel-name[Sol. Ej. 4]


```r
starwars %&gt;%
  filter((species != "Human" &amp;
            sex == "Male" &amp;
            height &gt; 170) |
           eye_color %in% c("brown", "red"))
```

```
&gt; # A tibble: 26 x 14
&gt;    name     height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 R2-D2        96  32   &lt;NA&gt;       white, bl~ red             33   none  mascu~
&gt;  2 Leia Or~    150  49   brown      light      brown           19   fema~ femin~
&gt;  3 R5-D4        97  32   &lt;NA&gt;       white, red red             NA   none  mascu~
&gt;  4 Biggs D~    183  84   black      light      brown           24   male  mascu~
&gt;  5 Han Solo    180  80   brown      fair       brown           29   male  mascu~
&gt;  6 Yoda         66  17   white      green      brown          896   male  mascu~
&gt;  7 Boba Fe~    183  78.2 black      fair       brown           31.5 male  mascu~
&gt;  8 IG-88       200 140   none       metal      red             15   none  mascu~
&gt;  9 Bossk       190 113   none       green      red             53   male  mascu~
&gt; 10 Lando C~    177  79   black      dark       brown           31   male  mascu~
&gt; # ... with 16 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

]

]

---

# Rebanadas de los datos: slice()

También podemos **seleccionar filas por su posición** con `slice()`.


```r
# slice: extraemos filas por índice de fila.
*starwars %&gt;% slice(1)
```

```
&gt; # A tibble: 1 x 14
&gt;   name      height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt; 1 Luke Sky~    172    77 blond      fair       blue              19 male  mascu~
&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;
```

Podemos **extraer varias a la vez**, incluso **usar una secuencia de índices a extraer**, por ejemplo solo las filas pares.


```r
# filas pares hasta la octava
starwars %&gt;%
  slice(seq(2, 8, by = 2)) 
```

```
&gt; # A tibble: 4 x 14
&gt;   name      height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt; 1 C-3PO        167    75 &lt;NA&gt;       gold       yellow         112   none  mascu~
&gt; 2 Darth Va~    202   136 none       white      yellow          41.9 male  mascu~
&gt; 3 Owen Lars    178   120 brown, gr~ light      blue            52   male  mascu~
&gt; 4 R5-D4         97    32 &lt;NA&gt;       white, red red             NA   none  mascu~
&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;
```




---

# Rebanadas de los datos: slice()

.pull-left[

Disponemos además de opciones por defecto

* `slice_head(n = ...)`: extraer las n primeras filas.
* `slice_tail(n = ...)`: extraer las n últimas filas.
* `slice_sample(n = ...)`: extrae n filas elegidas aleatoriamente.
* `slice_min(var, n = ...)` y `slice_max(var, n = ...)`: **extrae las n filas con menor/mayor de una variable** (si hay empate, mostrará todas salvo que `with_ties = FALSE`). 



```r
# los 3 más bajitos
starwars %&gt;%
  slice_min(height, n = 3) 
```

```
&gt; # A tibble: 3 x 14
&gt;   name      height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt; 1 Yoda          66    17 white      green      brown            896 male  mascu~
&gt; 2 Ratts Ty~     79    15 none       grey, blue unknown           NA male  mascu~
&gt; 3 Wicket S~     88    20 brown      brown      brown              8 male  mascu~
&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/filter6.jpg" alt="Flujo de https://tidydatatutor.com/" width="150%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;


]

---

# Reordenar filas: rearrange()

Otra operación habitual en las filas es **ordenar las filas en función del valor de alguna de las variables** con `arrange()`,  pasándole como argumento el nombre de la variable que usaremos para la ordenación. Por defecto la ordenación es de menor a mayor pero podemos invertirlo usando `desc()`.


```r
datos %&gt;%
  filtro(cond1, cond2) %&gt;%
* ordeno(var1, desc(var2))
```
Por ejemplo, vamos a **ordenar** los personajes por altura, de bajitos a altos, y en caso de empate, por peso (pero al revés, de pesados a ligeros).



```r
starwars %&gt;%
* arrange(height, desc(mass))
```

```
&gt; # A tibble: 87 x 14
&gt;    name     height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Yoda         66    17 white      green      brown            896 male  mascu~
&gt;  2 Ratts T~     79    15 none       grey, blue unknown           NA male  mascu~
&gt;  3 Wicket ~     88    20 brown      brown      brown              8 male  mascu~
&gt;  4 Dud Bolt     94    45 none       blue, grey yellow            NA male  mascu~
&gt;  5 R2-D2        96    32 &lt;NA&gt;       white, bl~ red               33 none  mascu~
&gt;  6 R4-P17       96    NA none       silver, r~ red, blue         NA none  femin~
&gt;  7 R5-D4        97    32 &lt;NA&gt;       white, red red               NA none  mascu~
&gt;  8 Sebulba     112    40 none       grey, red  orange            NA male  mascu~
&gt;  9 Gasgano     122    NA none       white, bl~ black             NA male  mascu~
&gt; 10 Watto       137    NA black      blue, grey yellow            NA male  mascu~
&gt; # ... with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

---

# Eliminar filas

La misma lógica que hemos usado para seleccionar filas podemos usarla para **eliminar filas**:

* `filter(!condicion)`: filtramos aquellas filas que NO CUMPLEN la condición (eliminando las que sí).
* `slice(-indices)`: eliminamos las filas que ocupan los indices.

Por ejemplo, vamos a eliminar las 80 primeras filas.


```r
# eliminamos las 80 primeras filas
starwars %&gt;%
  slice(-(1:80)) 
```

```
&gt; # A tibble: 7 x 14
&gt;   name      height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt; 1 Tion Med~    206    80 none       grey       black             NA male  mascu~
&gt; 2 Finn          NA    NA black      dark       dark              NA male  mascu~
&gt; 3 Rey           NA    NA brown      light      hazel             NA fema~ femin~
&gt; 4 Poe Dame~     NA    NA brown      light      brown             NA male  mascu~
&gt; 5 BB8           NA    NA none       none       black             NA none  mascu~
&gt; 6 Captain ~     NA    NA unknown    unknown    unknown           NA &lt;NA&gt;  &lt;NA&gt;  
&gt; 7 Padmé Am~    165    45 brown      light      brown             46 fema~ femin~
&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;
```

---

# Eliminar datos ausentes (NA)

Podemos también **eliminar los registros ausentes** en alguna de sus variables con `drop_na()`. Si no especificamos variables, elimina todos los registros que tenga alguno de sus campos ausente.


```r
starwars %&gt;%
  drop_na()
```

```
&gt; # A tibble: 29 x 14
&gt;    name     height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Luke Sk~    172    77 blond      fair       blue            19   male  mascu~
&gt;  2 Darth V~    202   136 none       white      yellow          41.9 male  mascu~
&gt;  3 Leia Or~    150    49 brown      light      brown           19   fema~ femin~
&gt;  4 Owen La~    178   120 brown, gr~ light      blue            52   male  mascu~
&gt;  5 Beru Wh~    165    75 brown      light      blue            47   fema~ femin~
&gt;  6 Biggs D~    183    84 black      light      brown           24   male  mascu~
&gt;  7 Obi-Wan~    182    77 auburn, w~ fair       blue-gray       57   male  mascu~
&gt;  8 Anakin ~    188    84 blond      fair       blue            41.9 male  mascu~
&gt;  9 Chewbac~    228   112 brown      unknown    blue           200   male  mascu~
&gt; 10 Han Solo    180    80 brown      fair       brown           29   male  mascu~
&gt; # ... with 19 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

Podemos indicarle que nos elimine filas con datos ausentes fijándonos solo en **algunos campos en concreto**.


```r
starwars %&gt;%
  drop_na(mass, height, sex, gender, birth_year)
```

---

# Eliminar duplicados: distinct()

Otra opción es **eliminar filas duplicadas** con `distinct()`, pasándole como argumentos el nombre de las variables que usaremos para quitar duplicados, por ejemplo, personajes con igual par de color de pelo y ojos.

Por defecto, solo extrae las columnas en base a las cuales hemos eliminado duplicados. Si queremos que nos mantenga todas deberemos explicitarlo con `.keep_all = TRUE`.


```r
# Elimina filas con igual (color_pelo, color_ojos)
starwars %&gt;%
  distinct(hair_color, eye_color)
```

```
&gt; # A tibble: 35 x 2
&gt;    hair_color    eye_color
&gt;    &lt;chr&gt;         &lt;chr&gt;    
&gt;  1 blond         blue     
&gt;  2 &lt;NA&gt;          yellow   
&gt;  3 &lt;NA&gt;          red      
&gt;  4 none          yellow   
&gt;  5 brown         brown    
&gt;  6 brown, grey   blue     
&gt;  7 brown         blue     
&gt;  8 black         brown    
&gt;  9 auburn, white blue-gray
&gt; 10 auburn, grey  blue     
&gt; # ... with 25 more rows
```
  
---

# Añadir filas: bind_rows()

Si quisiéramos añadir un nuevo registro manualmente, podremos hacerlo con `bind_rows()`, asegurándonos que las **variables en el nuevo registro son las mismas que en el original**. Por ejemplo, vamos a añadir al fichero original los 3 primeros registros (al final).


```r
starwars_nuevo &lt;-
* bind_rows(starwars, starwars[1:3, ])
dim(starwars)
```

```
&gt; [1] 87 14
```

```r
dim(starwars_nuevo)
```

```
&gt; [1] 90 14
```

---


# Ejercicios

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: selecciona solo los personajes que sean humanos y de ojos marrones, para después ordernarlos en altura descendente y peso ascendente.

* 📝 **Ejercicio 2**:  extrae 3 registros aleatoriamente. Vuelve a hacerlo para comprobar que salen diferentes.

* 📝 **Ejercicio 3**:  extrae el 10% de los registros aleatoriamente, llamando a `slice_sample()` asignando valor al argumento `prop`

* 📝 **Ejercicio 4**: selecciona los 3 personajes más mayores y los 3 personajes más bajitos.

* 📝 **Ejercicio 5**: para saber que valores únicos hay en el color de pelo, elimina duplicados por dicha variable `hair_color`, eliminando antes los ausentes de dicha variable


]

.panel[.panel-name[Sol. Ej. 1]


```r
# Podemos combinar varias acciones en pocas líneas
starwars %&gt;%
  filter(eye_color == "brown",
         species == "Human") %&gt;%
  arrange(height, desc(mass))
```

```
&gt; # A tibble: 17 x 14
&gt;    name     height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Leia Or~    150  49   brown      light      brown           19   fema~ femin~
&gt;  2 Cordé       157  NA   brown      light      brown           NA   fema~ femin~
&gt;  3 Shmi Sk~    163  NA   black      fair       brown           72   fema~ femin~
&gt;  4 Padmé A~    165  45   brown      light      brown           46   fema~ femin~
&gt;  5 Dormé       165  NA   brown      light      brown           NA   fema~ femin~
&gt;  6 Lando C~    177  79   black      dark       brown           31   male  mascu~
&gt;  7 Han Solo    180  80   brown      fair       brown           29   male  mascu~
&gt;  8 Biggs D~    183  84   black      light      brown           24   male  mascu~
&gt;  9 Jango F~    183  79   black      tan        brown           66   male  mascu~
&gt; 10 Boba Fe~    183  78.2 black      fair       brown           31.5 male  mascu~
&gt; 11 Gregar ~    185  85   black      dark       brown           NA   male  mascu~
&gt; 12 Mace Wi~    188  84   none       dark       brown           72   male  mascu~
&gt; 13 Raymus ~    188  79   brown      light      brown           NA   male  mascu~
&gt; 14 Bail Pr~    191  NA   black      tan        brown           67   male  mascu~
&gt; 15 Dooku       193  80   white      fair       brown          102   male  mascu~
&gt; 16 Arvel C~     NA  NA   brown      fair       brown           NA   male  mascu~
&gt; 17 Poe Dam~     NA  NA   brown      light      brown           NA   male  mascu~
&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;
```

]

.panel[.panel-name[Sol. Ej. 2]


```r
starwars %&gt;%
  slice_sample(n = 3)
```

```
&gt; # A tibble: 3 x 14
&gt;   name      height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt; 1 Roos Tar~    224    82 none       grey       orange            NA male  mascu~
&gt; 2 Wicket S~     88    20 brown      brown      brown              8 male  mascu~
&gt; 3 Ackbar       180    83 none       brown mot~ orange            41 male  mascu~
&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;
```


```r
starwars %&gt;%
  slice_sample(n = 3)
```

```
&gt; # A tibble: 3 x 14
&gt;   name      height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt; 1 Saesee T~    188    NA none       pale       orange            NA male  mascu~
&gt; 2 Lama Su      229    88 none       grey       black             NA male  mascu~
&gt; 3 Beru Whi~    165    75 brown      light      blue              47 fema~ femin~
&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;
```


]

.panel[.panel-name[Sol. Ej. 3]


```r
starwars %&gt;%
  slice_sample(prop = 0.1)
```

```
&gt; # A tibble: 8 x 14
&gt;   name      height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt; 1 Nien Nunb    160    68 none       grey       black           NA   male  mascu~
&gt; 2 BB8           NA    NA none       none       black           NA   none  mascu~
&gt; 3 Ric Olié     183    NA brown      fair       blue            NA   &lt;NA&gt;  &lt;NA&gt;  
&gt; 4 Anakin S~    188    84 blond      fair       blue            41.9 male  mascu~
&gt; 5 Arvel Cr~     NA    NA brown      fair       brown           NA   male  mascu~
&gt; 6 Wilhuff ~    180    NA auburn, g~ fair       blue            64   male  mascu~
&gt; 7 Darth Va~    202   136 none       white      yellow          41.9 male  mascu~
&gt; 8 Obi-Wan ~    182    77 auburn, w~ fair       blue-gray       57   male  mascu~
&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;
```

]

.panel[.panel-name[Sol. Ej. 4]



```r
starwars %&gt;%
  slice_max(birth_year, n = 3)
```

```
&gt; # A tibble: 3 x 14
&gt;   name      height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt; 1 Yoda          66    17 white      green      brown            896 male  mascu~
&gt; 2 Jabba De~    175  1358 &lt;NA&gt;       green-tan~ orange           600 herm~ mascu~
&gt; 3 Chewbacca    228   112 brown      unknown    blue             200 male  mascu~
&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;
```


```r
starwars %&gt;%
  slice_min(height, n = 3)
```

```
&gt; # A tibble: 3 x 14
&gt;   name      height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt; 1 Yoda          66    17 white      green      brown            896 male  mascu~
&gt; 2 Ratts Ty~     79    15 none       grey, blue unknown           NA male  mascu~
&gt; 3 Wicket S~     88    20 brown      brown      brown              8 male  mascu~
&gt; # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;
```
]

.panel[.panel-name[Sol. Ej. 5]



```r
starwars %&gt;%
  drop_na(hair_color) %&gt;%
  distinct(hair_color)
```

```
&gt; # A tibble: 12 x 1
&gt;    hair_color   
&gt;    &lt;chr&gt;        
&gt;  1 blond        
&gt;  2 none         
&gt;  3 brown        
&gt;  4 brown, grey  
&gt;  5 black        
&gt;  6 auburn, white
&gt;  7 auburn, grey 
&gt;  8 white        
&gt;  9 grey         
&gt; 10 auburn       
&gt; 11 blonde       
&gt; 12 unknown
```

]

]

---




# Seleccionar columnas: select()

.pull-left[

La opción más sencilla para **seleccionar variables** es `select()`, con argumentos los nombres de columnas (¡SIN COMILLAS!).


```r
# Idea
datos %&gt;%
  filtro(cond1, cond2) %&gt;%
  ordeno(var1, desc(var2)) %&gt;%
  selecciono(col1, col2, ...)
```

Seleccionamos por ejemplo la columna `hair_color`


```r
# seleccionamos 1 columna
starwars %&gt;%
* select(hair_color)
```

```
&gt; # A tibble: 87 x 1
&gt;    hair_color   
&gt;    &lt;chr&gt;        
&gt;  1 blond        
&gt;  2 &lt;NA&gt;         
&gt;  3 &lt;NA&gt;         
&gt;  4 none         
&gt;  5 brown        
&gt;  6 brown, grey  
&gt;  7 brown        
&gt;  8 &lt;NA&gt;         
&gt;  9 black        
&gt; 10 auburn, white
&gt; # ... with 77 more rows
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/select1.jpg" alt="Flujo de https://tidydatatutor.com/" width="150%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]

---

# Seleccionar columnas: select()

.pull-left[

Como sucedía al filtrar, la función `select()` es bastante versatil y nos permite:

* Seleccionar **varias variables a la vez** (concatenando sus nombres)
* **Deseleccionar** columnas con `-`
* Seleccionar columnas que **comiencen por un prefijo** (`starts_with()`), **terminen** con un sufijo (`ends_with()`), **contengan** un texto (`contains()`) o cumplan una **expresión regular** (`matches()`)
* Seleccionar columnas de **un tipo** haciendo uso de `where(is.numeric)`, etc.


```r
# color de piel y de pelo (en ese orden)
starwars %&gt;%
  select(c(skin_color, hair_color))
```

```
&gt; # A tibble: 87 x 2
&gt;    skin_color  hair_color   
&gt;    &lt;chr&gt;       &lt;chr&gt;        
&gt;  1 fair        blond        
&gt;  2 gold        &lt;NA&gt;         
&gt;  3 white, blue &lt;NA&gt;         
&gt;  4 white       none         
&gt;  5 light       brown        
&gt;  6 light       brown, grey  
&gt;  7 light       brown        
&gt;  8 white, red  &lt;NA&gt;         
&gt;  9 light       black        
&gt; 10 fair        auburn, white
&gt; # ... with 77 more rows
```

]


.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/select2.jpg" alt="Flujo de https://tidydatatutor.com/" width="150%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]

---

# Seleccionar columnas: select()

.pull-left[


```r
# desde name hasta hair_color
starwars %&gt;% select(c(name:hair_color))
```


```
&gt; # A tibble: 5 x 4
&gt;   name           height  mass hair_color
&gt;   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;     
&gt; 1 Luke Skywalker    172    77 blond     
&gt; 2 C-3PO             167    75 &lt;NA&gt;      
&gt; 3 R2-D2              96    32 &lt;NA&gt;      
&gt; 4 Darth Vader       202   136 none      
&gt; 5 Leia Organa       150    49 brown
```


```r
# nombre acaba en "color"
starwars %&gt;%  select(ends_with("color"))
```


```
&gt; # A tibble: 5 x 3
&gt;   hair_color skin_color  eye_color
&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;    
&gt; 1 blond      fair        blue     
&gt; 2 &lt;NA&gt;       gold        yellow   
&gt; 3 &lt;NA&gt;       white, blue red      
&gt; 4 none       white       yellow   
&gt; 5 brown      light       brown
```

]

.pull-right[


```r
# empiezan por h
starwars %&gt;% select(starts_with("h"))
```


```
&gt; # A tibble: 5 x 3
&gt;   height hair_color homeworld
&gt;    &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;    
&gt; 1    172 blond      Tatooine 
&gt; 2    167 &lt;NA&gt;       Tatooine 
&gt; 3     96 &lt;NA&gt;       Naboo    
&gt; 4    202 none       Tatooine 
&gt; 5    150 brown      Alderaan
```


```r
# Solo columnas numéricas
starwars %&gt;% select(where(is.numeric))
```


```
&gt; # A tibble: 5 x 3
&gt;   height  mass birth_year
&gt;    &lt;int&gt; &lt;dbl&gt;      &lt;dbl&gt;
&gt; 1    172    77       19  
&gt; 2    167    75      112  
&gt; 3     96    32       33  
&gt; 4    202   136       41.9
&gt; 5    150    49       19
```

]

---

# Recolocar columnas: relocate()

Fíjate que con `select()` podrías además recolocar columnas, indícandole el orden, ayudándote también del selector `everything()`


```r
starwars %&gt;%
  select(c(species, name, birth_year, everything()))
```

Para facilitar la recolocación tenemos una función para ello, `relocate()`,  indicándole en `.after` o `.before` detrás o delante de qué columnas queremos moverlas.


```r
starwars %&gt;% relocate(species, .before = name)
```

```
&gt; # A tibble: 87 x 14
&gt;    species name    height  mass hair_color skin_color eye_color birth_year sex  
&gt;    &lt;chr&gt;   &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;
&gt;  1 Human   Luke S~    172    77 blond      fair       blue            19   male 
&gt;  2 Droid   C-3PO      167    75 &lt;NA&gt;       gold       yellow         112   none 
&gt;  3 Droid   R2-D2       96    32 &lt;NA&gt;       white, bl~ red             33   none 
&gt;  4 Human   Darth ~    202   136 none       white      yellow          41.9 male 
&gt;  5 Human   Leia O~    150    49 brown      light      brown           19   fema~
&gt;  6 Human   Owen L~    178   120 brown, gr~ light      blue            52   male 
&gt;  7 Human   Beru W~    165    75 brown      light      blue            47   fema~
&gt;  8 Droid   R5-D4       97    32 &lt;NA&gt;       white, red red             NA   none 
&gt;  9 Human   Biggs ~    183    84 black      light      brown           24   male 
&gt; 10 Human   Obi-Wa~    182    77 auburn, w~ fair       blue-gray       57   male 
&gt; # ... with 77 more rows, and 5 more variables: gender &lt;chr&gt;, homeworld &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

---

# Extraer columnas: pull()

.pull-left[

Si observas la salida de los `select()`, sigue siendo una tabla `tibble`, nos preserva la naturaleza de nuestros datos.


```r
starwars %&gt;% select(name)
```

```
&gt; # A tibble: 87 x 1
&gt;    name              
&gt;    &lt;chr&gt;             
&gt;  1 Luke Skywalker    
&gt;  2 C-3PO             
&gt;  3 R2-D2             
&gt;  4 Darth Vader       
&gt;  5 Leia Organa       
&gt;  6 Owen Lars         
&gt;  7 Beru Whitesun lars
&gt;  8 R5-D4             
&gt;  9 Biggs Darklighter 
&gt; 10 Obi-Wan Kenobi    
&gt; # ... with 77 more rows
```

]

.pull-right[

A veces no querremos dicha estructura sino **extraer literalmente la columna en un vector**, algo que podemos hacer con `pull()`


```r
starwars %&gt;% pull(name)
```

```
&gt;  [1] "Luke Skywalker"        "C-3PO"                 "R2-D2"                
&gt;  [4] "Darth Vader"           "Leia Organa"           "Owen Lars"            
&gt;  [7] "Beru Whitesun lars"    "R5-D4"                 "Biggs Darklighter"    
&gt; [10] "Obi-Wan Kenobi"        "Anakin Skywalker"      "Wilhuff Tarkin"       
&gt; [13] "Chewbacca"             "Han Solo"              "Greedo"               
&gt; [16] "Jabba Desilijic Tiure" "Wedge Antilles"        "Jek Tono Porkins"     
&gt; [19] "Yoda"                  "Palpatine"             "Boba Fett"            
&gt; [22] "IG-88"                 "Bossk"                 "Lando Calrissian"     
&gt; [25] "Lobot"                 "Ackbar"                "Mon Mothma"           
&gt; [28] "Arvel Crynyd"          "Wicket Systri Warrick" "Nien Nunb"            
&gt; [31] "Qui-Gon Jinn"          "Nute Gunray"           "Finis Valorum"        
&gt; [34] "Jar Jar Binks"         "Roos Tarpals"          "Rugor Nass"           
&gt; [37] "Ric Olié"              "Watto"                 "Sebulba"              
&gt; [40] "Quarsh Panaka"         "Shmi Skywalker"        "Darth Maul"           
&gt; [43] "Bib Fortuna"           "Ayla Secura"           "Dud Bolt"             
&gt; [46] "Gasgano"               "Ben Quadinaros"        "Mace Windu"           
&gt; [49] "Ki-Adi-Mundi"          "Kit Fisto"             "Eeth Koth"            
&gt; [52] "Adi Gallia"            "Saesee Tiin"           "Yarael Poof"          
&gt; [55] "Plo Koon"              "Mas Amedda"            "Gregar Typho"         
&gt; [58] "Cordé"                 "Cliegg Lars"           "Poggle the Lesser"    
&gt; [61] "Luminara Unduli"       "Barriss Offee"         "Dormé"                
&gt; [64] "Dooku"                 "Bail Prestor Organa"   "Jango Fett"           
&gt; [67] "Zam Wesell"            "Dexter Jettster"       "Lama Su"              
&gt; [70] "Taun We"               "Jocasta Nu"            "Ratts Tyerell"        
&gt; [73] "R4-P17"                "Wat Tambor"            "San Hill"             
&gt; [76] "Shaak Ti"              "Grievous"              "Tarfful"              
&gt; [79] "Raymus Antilles"       "Sly Moore"             "Tion Medon"           
&gt; [82] "Finn"                  "Rey"                   "Poe Dameron"          
&gt; [85] "BB8"                   "Captain Phasma"        "Padmé Amidala"
```

]

---

# Renombrar columnas: rename()

.pull-left[

A veces también podemos querer **modificar la «metainformación» de los datos**, renombrando las columnas. Para ello usaremos la función `rename()` poniendo **primero el nombre nuevo y luego el antiguo**. Como ejemplo, vamos a traducir el nombre de las columnas `name, height, mass` a castellano.


```r
starwars %&gt;% 
  rename(nombre = name,
         altura = height,
         peso = mass)
```

```
&gt; # A tibble: 87 x 14
&gt;    nombre   altura  peso hair_color skin_color eye_color birth_year sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Luke Sk~    172    77 blond      fair       blue            19   male  mascu~
&gt;  2 C-3PO       167    75 &lt;NA&gt;       gold       yellow         112   none  mascu~
&gt;  3 R2-D2        96    32 &lt;NA&gt;       white, bl~ red             33   none  mascu~
&gt;  4 Darth V~    202   136 none       white      yellow          41.9 male  mascu~
&gt;  5 Leia Or~    150    49 brown      light      brown           19   fema~ femin~
&gt;  6 Owen La~    178   120 brown, gr~ light      blue            52   male  mascu~
&gt;  7 Beru Wh~    165    75 brown      light      blue            47   fema~ femin~
&gt;  8 R5-D4        97    32 &lt;NA&gt;       white, red red             NA   none  mascu~
&gt;  9 Biggs D~    183    84 black      light      brown           24   male  mascu~
&gt; 10 Obi-Wan~    182    77 auburn, w~ fair       blue-gray       57   male  mascu~
&gt; # ... with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

]
.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/rename1.jpg" alt="Flujo de https://tidydatatutor.com/" width="150%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]

---

# Modificadores: at, if

Muchas de las funciones vistas pueden ir acompañadas de `at` o `if`, como `rename_if`, que nos permite hacer operaciones más personalizadas. Por ejemplo, vamos a renombrar solo las columnas que sean de tipo numérico, y además les aplicaremos la función `toupper()`, pasándolas a mayúsculas.


```r
starwars %&gt;%
  rename_if(is.numeric, toupper)
```

```
&gt; # A tibble: 87 x 14
&gt;    name     HEIGHT  MASS hair_color skin_color eye_color BIRTH_YEAR sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Luke Sk~    172    77 blond      fair       blue            19   male  mascu~
&gt;  2 C-3PO       167    75 &lt;NA&gt;       gold       yellow         112   none  mascu~
&gt;  3 R2-D2        96    32 &lt;NA&gt;       white, bl~ red             33   none  mascu~
&gt;  4 Darth V~    202   136 none       white      yellow          41.9 male  mascu~
&gt;  5 Leia Or~    150    49 brown      light      brown           19   fema~ femin~
&gt;  6 Owen La~    178   120 brown, gr~ light      blue            52   male  mascu~
&gt;  7 Beru Wh~    165    75 brown      light      blue            47   fema~ femin~
&gt;  8 R5-D4        97    32 &lt;NA&gt;       white, red red             NA   none  mascu~
&gt;  9 Biggs D~    183    84 black      light      brown           24   male  mascu~
&gt; 10 Obi-Wan~    182    77 auburn, w~ fair       blue-gray       57   male  mascu~
&gt; # ... with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

---

# Ejercicios: select() y rename()

.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: filtra el conjunto de personajes y quédate solo con aquellos que en la variable `height` no tengan un dato ausente.

* 📝 **Ejercicio 2**: con los datos obtenidos del filtro anterior, selecciona solo las variables `name`, `height`, así como todas aquellas variables que CONTENGAN la palabra `color` en su nombre.

* 📝 **Ejercicio 3**: con los datos obtenidos del ejercicio, traduce el nombre de las columnas a castellano

* 📝 **Ejercicio 4**: con los datos obtenidos del ejercicio, coloca la variable de color de pelo justo detrás de la variable de nombres.

* 📝 **Ejercicio 5**: con los datos obtenidos del ejercicio, comprueba cuántas modalidades únicas hay en la variable de color de pelo.

]

.panel[.panel-name[Sol. Ej. 1]

**IMPORTANTE**: todo lo que hagas en la tabla original, si el resultado final no se lo asignas `&lt;-` a otra variable, lo verás en consola pero no se guardará en ningún sitio. Lo que no guardes, no existe.



```r
starwars_NA &lt;- starwars %&gt;% drop_na(height)
starwars_NA 
```

```
&gt; # A tibble: 81 x 14
&gt;    name     height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Luke Sk~    172    77 blond      fair       blue            19   male  mascu~
&gt;  2 C-3PO       167    75 &lt;NA&gt;       gold       yellow         112   none  mascu~
&gt;  3 R2-D2        96    32 &lt;NA&gt;       white, bl~ red             33   none  mascu~
&gt;  4 Darth V~    202   136 none       white      yellow          41.9 male  mascu~
&gt;  5 Leia Or~    150    49 brown      light      brown           19   fema~ femin~
&gt;  6 Owen La~    178   120 brown, gr~ light      blue            52   male  mascu~
&gt;  7 Beru Wh~    165    75 brown      light      blue            47   fema~ femin~
&gt;  8 R5-D4        97    32 &lt;NA&gt;       white, red red             NA   none  mascu~
&gt;  9 Biggs D~    183    84 black      light      brown           24   male  mascu~
&gt; 10 Obi-Wan~    182    77 auburn, w~ fair       blue-gray       57   male  mascu~
&gt; # ... with 71 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

]

.panel[.panel-name[Sol. Ej. 2]


```r
starwars %&gt;%
  drop_na(height) %&gt;%
  select(c(name, height, contains("color")))
```

```
&gt; # A tibble: 81 x 5
&gt;    name               height hair_color    skin_color  eye_color
&gt;    &lt;chr&gt;               &lt;int&gt; &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;    
&gt;  1 Luke Skywalker        172 blond         fair        blue     
&gt;  2 C-3PO                 167 &lt;NA&gt;          gold        yellow   
&gt;  3 R2-D2                  96 &lt;NA&gt;          white, blue red      
&gt;  4 Darth Vader           202 none          white       yellow   
&gt;  5 Leia Organa           150 brown         light       brown    
&gt;  6 Owen Lars             178 brown, grey   light       blue     
&gt;  7 Beru Whitesun lars    165 brown         light       blue     
&gt;  8 R5-D4                  97 &lt;NA&gt;          white, red  red      
&gt;  9 Biggs Darklighter     183 black         light       brown    
&gt; 10 Obi-Wan Kenobi        182 auburn, white fair        blue-gray
&gt; # ... with 71 more rows
```

]

.panel[.panel-name[Sol. Ej. 3]



```r
starwars %&gt;%
  drop_na(height) %&gt;%
  select(c(name, height, contains("color"))) %&gt;%
  rename(nombre = name, altura = height,
         color_pelo = hair_color,
         color_piel = skin_color,
         color_ojos = eye_color)
```

```
&gt; # A tibble: 81 x 5
&gt;    nombre             altura color_pelo    color_piel  color_ojos
&gt;    &lt;chr&gt;               &lt;int&gt; &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;     
&gt;  1 Luke Skywalker        172 blond         fair        blue      
&gt;  2 C-3PO                 167 &lt;NA&gt;          gold        yellow    
&gt;  3 R2-D2                  96 &lt;NA&gt;          white, blue red       
&gt;  4 Darth Vader           202 none          white       yellow    
&gt;  5 Leia Organa           150 brown         light       brown     
&gt;  6 Owen Lars             178 brown, grey   light       blue      
&gt;  7 Beru Whitesun lars    165 brown         light       blue      
&gt;  8 R5-D4                  97 &lt;NA&gt;          white, red  red       
&gt;  9 Biggs Darklighter     183 black         light       brown     
&gt; 10 Obi-Wan Kenobi        182 auburn, white fair        blue-gray 
&gt; # ... with 71 more rows
```

]

.panel[.panel-name[Sol. Ej. 4]



```r
starwars %&gt;%
  drop_na(height) %&gt;%
  select(c(name, height, contains("color"))) %&gt;%
  rename(nombre = name, altura = height,
         color_pelo = hair_color,
         color_piel = skin_color,
         color_ojos = eye_color) %&gt;%
  relocate(color_pelo, .after = nombre)
```

```
&gt; # A tibble: 81 x 5
&gt;    nombre             color_pelo    altura color_piel  color_ojos
&gt;    &lt;chr&gt;              &lt;chr&gt;          &lt;int&gt; &lt;chr&gt;       &lt;chr&gt;     
&gt;  1 Luke Skywalker     blond            172 fair        blue      
&gt;  2 C-3PO              &lt;NA&gt;             167 gold        yellow    
&gt;  3 R2-D2              &lt;NA&gt;              96 white, blue red       
&gt;  4 Darth Vader        none             202 white       yellow    
&gt;  5 Leia Organa        brown            150 light       brown     
&gt;  6 Owen Lars          brown, grey      178 light       blue      
&gt;  7 Beru Whitesun lars brown            165 light       blue      
&gt;  8 R5-D4              &lt;NA&gt;              97 white, red  red       
&gt;  9 Biggs Darklighter  black            183 light       brown     
&gt; 10 Obi-Wan Kenobi     auburn, white    182 fair        blue-gray 
&gt; # ... with 71 more rows
```

]

.panel[.panel-name[Sol. Ej. 5]


```r
starwars %&gt;% drop_na(height) %&gt;% select(c(name, height, contains("color"))) %&gt;%
  rename(nombre = name, altura = height, color_pelo = hair_color,
         color_piel = skin_color, color_ojos = eye_color) %&gt;%
  relocate(color_pelo, .after = nombre) %&gt;% distinct(color_pelo)
```

```
&gt; # A tibble: 12 x 1
&gt;    color_pelo   
&gt;    &lt;chr&gt;        
&gt;  1 blond        
&gt;  2 &lt;NA&gt;         
&gt;  3 none         
&gt;  4 brown        
&gt;  5 brown, grey  
&gt;  6 black        
&gt;  7 auburn, white
&gt;  8 auburn, grey 
&gt;  9 white        
&gt; 10 grey         
&gt; 11 auburn       
&gt; 12 blonde
```

**IMPORTANTE**: recuerda que `distinct()` de mantener todas las columnas añadiendo `.keep_all = TRUE`.

]

]

---


# Modificar/crear variables: mutate()

.pull-left[

A veces queremos **modificar o crear  variables**. Para ello tenemos la función `mutate()`. 


```r
# Idea
datos %&gt;%
  filtro(cond1, cond2) %&gt;%
  ordeno(var1, desc(var2)) %&gt;%
  selecciono(col1, col2, ...) %&gt;%
  modifico(var_nueva = funcion(var_existentes))
```

Para empezar, vamos a crear una **nueva variable** `height_m` con la altura en centímetros.


```r
# altura en metros
starwars %&gt;%
  mutate(height_m = height / 100)
```


```
&gt; # A tibble: 87 x 4
&gt;    name                mass height height_m
&gt;    &lt;chr&gt;              &lt;dbl&gt;  &lt;int&gt;    &lt;dbl&gt;
&gt;  1 Luke Skywalker        77    172     1.72
&gt;  2 C-3PO                 75    167     1.67
&gt;  3 R2-D2                 32     96     0.96
&gt;  4 Darth Vader          136    202     2.02
&gt;  5 Leia Organa           49    150     1.5 
&gt;  6 Owen Lars            120    178     1.78
&gt;  7 Beru Whitesun lars    75    165     1.65
&gt;  8 R5-D4                 32     97     0.97
&gt;  9 Biggs Darklighter     84    183     1.83
&gt; 10 Obi-Wan Kenobi        77    182     1.82
&gt; # ... with 77 more rows
```



]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/mutate1.jpg" alt="Flujo de https://tidydatatutor.com/" width="150%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]

---

# Modificar/crear variables: mutate()

Otra opción es **quedarnos solo con las columnas nuevas** creadas con `transmute()`


```r
starwars %&gt;%
  transmute(height_m = height / 100)
```


```
&gt; # A tibble: 5 x 1
&gt;   height_m
&gt;      &lt;dbl&gt;
&gt; 1     1.72
&gt; 2     1.67
&gt; 3     0.96
&gt; 4     2.02
&gt; 5     1.5
```

También se pueden aplicar **funciones más complejas** como `if_else()` o `case_when()`


```r
starwars %&gt;%
  mutate(humano = if_else(species == "Human", "humano", "no humano"))
```


```
&gt; # A tibble: 87 x 5
&gt;    name               height  mass species humano   
&gt;    &lt;chr&gt;               &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;    
&gt;  1 Luke Skywalker        172    77 Human   humano   
&gt;  2 C-3PO                 167    75 Droid   no humano
&gt;  3 R2-D2                  96    32 Droid   no humano
&gt;  4 Darth Vader           202   136 Human   humano   
&gt;  5 Leia Organa           150    49 Human   humano   
&gt;  6 Owen Lars             178   120 Human   humano   
&gt;  7 Beru Whitesun lars    165    75 Human   humano   
&gt;  8 R5-D4                  97    32 Droid   no humano
&gt;  9 Biggs Darklighter     183    84 Human   humano   
&gt; 10 Obi-Wan Kenobi        182    77 Human   humano   
&gt; # ... with 77 more rows
```

---

# Recategorizar: case_when()

Una operación también muy habitual es querer **recategorizar nuestras variables**. Supongamos por ejemplo que queremos crear una **categoría en función de su altura**. Para ello podemos podemos usar  `case_when`, en el que le podemos indicar que valores asignamos en función de condiciones. Vamos a crear una variable nueva de altura

* Si `height &gt; 180` –&gt; serán `"altos"`.
* Si `height &lt;= 180` y `height &gt; 120` –&gt; serán `"bajos"`
* Si `height &lt;= 120` y `height &gt; 0` –&gt; serán `"enanos"`
* Si no se cumple lo anterior –&gt; serán `"ausentes"`


```r
starwars %&gt;%
  mutate(altura = case_when(height &gt; 180 ~ "altos",
                               height &gt; 120 ~ "bajos",
                               height &gt; 0 ~ "enanos",
                               TRUE ~ "ausentes"))
```


```
&gt; # A tibble: 87 x 4
&gt;    name               height  mass altura
&gt;    &lt;chr&gt;               &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; 
&gt;  1 Luke Skywalker        172    77 bajos 
&gt;  2 C-3PO                 167    75 bajos 
&gt;  3 R2-D2                  96    32 enanos
&gt;  4 Darth Vader           202   136 altos 
&gt;  5 Leia Organa           150    49 bajos 
&gt;  6 Owen Lars             178   120 bajos 
&gt;  7 Beru Whitesun lars    165    75 bajos 
&gt;  8 R5-D4                  97    32 enanos
&gt;  9 Biggs Darklighter     183    84 altos 
&gt; 10 Obi-Wan Kenobi        182    77 altos 
&gt; # ... with 77 more rows
```
  
---

# Ejercicios


.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: define una función llamada `IMC()`, que dados dos argumentos `peso` y `estatura` (en metros), nos devuelve el índice de masa corporal ($IMC = \frac{peso}{altura^2}$).
 
* 📝 **Ejercicio 2**: con esa función definida, añade a `starwars` una nueva columna que indique el IMC de cada personaje.

* 📝 **Ejercicio 3**: selecciona los 3 personajes con mayor IMC y los 3 con menos.

* 📝 **Ejercicio 4**: define una nueva variable llamada `edad` que nos recategorice la variable `birth_year`: `"menor"` para los que tengan menos de 18 años; `"adulto"` entre 18 y 65 años (ambos inclusive); `"mayor"` de 66 a 99 años; y `"centenario"` de 100 en adelante.

]

.panel[.panel-name[Sol. 1]

Primero definimos la función `IMC` (calcula el IMC dada estatura y peso).


```r
# Suponiendo a la altura ya en metros
IMC &lt;- function(peso, estatura) {
  
  IMC &lt;- peso / estatura^2
  return(IMC)
}

IMC(90, 1.60)
```

```
&gt; [1] 35.15625
```

```r
IMC(71, 1.73)
```

```
&gt; [1] 23.72281
```

]

.panel[.panel-name[Sol. 2]

La función definida como `IMC()` podemos ahora aplicarla dentro del `mutate()`.


```r
starwars %&gt;%
  mutate(height_m = height / 100,
         IMC = IMC(mass, height_m)) %&gt;%
  # Las movemos al inicio (por defecto las mete al final)
  relocate(height_m, IMC, .after = name)
```

```
&gt; # A tibble: 87 x 16
&gt;    name   height_m   IMC height  mass hair_color skin_color eye_color birth_year
&gt;    &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt;
&gt;  1 Luke ~     1.72  26.0    172    77 blond      fair       blue            19  
&gt;  2 C-3PO      1.67  26.9    167    75 &lt;NA&gt;       gold       yellow         112  
&gt;  3 R2-D2      0.96  34.7     96    32 &lt;NA&gt;       white, bl~ red             33  
&gt;  4 Darth~     2.02  33.3    202   136 none       white      yellow          41.9
&gt;  5 Leia ~     1.5   21.8    150    49 brown      light      brown           19  
&gt;  6 Owen ~     1.78  37.9    178   120 brown, gr~ light      blue            52  
&gt;  7 Beru ~     1.65  27.5    165    75 brown      light      blue            47  
&gt;  8 R5-D4      0.97  34.0     97    32 &lt;NA&gt;       white, red red             NA  
&gt;  9 Biggs~     1.83  25.1    183    84 black      light      brown           24  
&gt; 10 Obi-W~     1.82  23.2    182    77 auburn, w~ fair       blue-gray       57  
&gt; # ... with 77 more rows, and 7 more variables: sex &lt;chr&gt;, gender &lt;chr&gt;,
&gt; #   homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
&gt; #   starships &lt;list&gt;
```

]

.panel[.panel-name[Sol. 3]

 

```r
starwars_IMC &lt;- 
  starwars %&gt;%
  mutate(height_m = height / 100, IMC = IMC(mass, height_m))
starwars_IMC %&gt;% slice_max(IMC, n = 3)
```

```
&gt; # A tibble: 3 x 16
&gt;   name      height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt; 1 Jabba De~    175  1358 &lt;NA&gt;       green-tan~ orange           600 herm~ mascu~
&gt; 2 Dud Bolt      94    45 none       blue, grey yellow            NA male  mascu~
&gt; 3 Yoda          66    17 white      green      brown            896 male  mascu~
&gt; # ... with 7 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, height_m &lt;dbl&gt;, IMC &lt;dbl&gt;
```

```r
starwars_IMC %&gt;% slice_min(IMC, n = 3)
```

```
&gt; # A tibble: 3 x 16
&gt;   name      height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt; 1 Wat Tamb~    193    48 none       green, gr~ unknown           NA male  mascu~
&gt; 2 Adi Gall~    184    50 none       dark       blue              NA fema~ femin~
&gt; 3 Sly Moore    178    48 none       pale       white             NA &lt;NA&gt;  &lt;NA&gt;  
&gt; # ... with 7 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
&gt; #   vehicles &lt;list&gt;, starships &lt;list&gt;, height_m &lt;dbl&gt;, IMC &lt;dbl&gt;
```

]

.panel[.panel-name[Sol. 4]

 

```r
starwars %&gt;%
  mutate(edad =
           case_when(birth_year &lt; 18 ~ "menor",
                     between(birth_year, 18, 65) ~
                       "adulto",
                     between(birth_year, 66, 99) ~
                       "mayor",
                     TRUE ~ "centenario"))
```

```
&gt; # A tibble: 87 x 15
&gt;    name     height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Luke Sk~    172    77 blond      fair       blue            19   male  mascu~
&gt;  2 C-3PO       167    75 &lt;NA&gt;       gold       yellow         112   none  mascu~
&gt;  3 R2-D2        96    32 &lt;NA&gt;       white, bl~ red             33   none  mascu~
&gt;  4 Darth V~    202   136 none       white      yellow          41.9 male  mascu~
&gt;  5 Leia Or~    150    49 brown      light      brown           19   fema~ femin~
&gt;  6 Owen La~    178   120 brown, gr~ light      blue            52   male  mascu~
&gt;  7 Beru Wh~    165    75 brown      light      blue            47   fema~ femin~
&gt;  8 R5-D4        97    32 &lt;NA&gt;       white, red red             NA   none  mascu~
&gt;  9 Biggs D~    183    84 black      light      brown           24   male  mascu~
&gt; 10 Obi-Wan~    182    77 auburn, w~ fair       blue-gray       57   male  mascu~
&gt; # ... with 77 more rows, and 6 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;, edad &lt;chr&gt;
```

]

]

---


# Contar: count()

Tenemos además la función `count()` que nos permitirá contar los datos.


```r
# Idea
datos %&gt;%
  filtro(cond1, cond2) %&gt;%
  ordeno(var1, desc(var2)) %&gt;%
  selecciono(col1, col2, ...) %&gt;%
  modifico(var_nueva = funcion(var_existentes)) %&gt;%
  cuento(var1, var2)
```


Cuando lo usamos en solitario, `count()` nos devolverá simplemente el **número de registros**


```r
starwars %&gt;% count()
```

```
&gt; # A tibble: 1 x 1
&gt;       n
&gt;   &lt;int&gt;
&gt; 1    87
```

---

# Contar: count()

Cuando lo usamos pasándole como argumento una o varias variables, `count()` nos cuenta lo que se conoce en estadística como **frecuencias absolutas**: el número de elementos pertenecientes a cada una de las **modalidades**. En el caso por ejemplo del fichero de `starwars` `sex` tiene 4 modalidades `female, hermaphroditic, male, none`.


```r
starwars %&gt;% count(sex)
```

```
&gt; # A tibble: 5 x 2
&gt;   sex                n
&gt;   &lt;chr&gt;          &lt;int&gt;
&gt; 1 female            16
&gt; 2 hermaphroditic     1
&gt; 3 male              60
&gt; 4 none               6
&gt; 5 &lt;NA&gt;               4
```

Si pasamos varias variables nos calcula las **frecuencias absolutas n-dimensionales**


```r
starwars %&gt;% count(sex, gender)
```

```
&gt; # A tibble: 6 x 3
&gt;   sex            gender        n
&gt;   &lt;chr&gt;          &lt;chr&gt;     &lt;int&gt;
&gt; 1 female         feminine     16
&gt; 2 hermaphroditic masculine     1
&gt; 3 male           masculine    60
&gt; 4 none           feminine      1
&gt; 5 none           masculine     5
&gt; 6 &lt;NA&gt;           &lt;NA&gt;          4
```

---

# Paréntesis: estadística descriptiva

En estadística, como en probabilidad, podemos distinguir las variables en función de las modalidades permitidas en dos grandes categorías:

* **Variables categóricas (nominales o cualitativas)**. Son variables que representan categorías o cualidades. Ejemplos: color, forma, estado civil, religión, etc. Estas variables las podemos **subdividir en función de si admiten o no un orden**:
  - **Cualitativas ordinales**: aunque representen cualidades, tienen una jerarquía de orden. Ejemplos: suspenso-aprobado-notable, sano - herido leve - grave, etc.
  - **Cualitativas nominales**: no admiten (salvo problemas nuestros) una jerarquía de orden. Ejemplos: ateo-católico-musulmán, soltero-casado, homber-mujer, etc.

&amp;nbsp;

* **Variables cuantitativas**:  representan una **cantidad numérica** medible, una característica cuantificable matemáticamente. A su vez se pueden subdividir en dos grupos.
  - **Cuantitativas discretas**: se pueden **contar** y **enumerar (aunque sean infinitos)**, detrás de un valor puedo saber cuál viene después (personas, granos de arena, etc).
  - **Cuantitativas continuas**: no solo toman infinitos valores sino que entre dos valores cualesquiera, también hay infinitos términos, no se puede determinar el siguiente valor a uno dado (estaturas, pesos, temperatura, etc).

---

# Paréntesis: estadística descriptiva

En estadística llamamos **medidas de centralización** a aquellas medidas que nos indican en torno a qué **valores se concentran los datos**

* **Media**: medida de centralización basada en el valor que nos **minimiza el promedio de desviaciones al cuadrado**. La media es el valor que está más «cerca» de todos los puntos a la vez, pero **SOLO se puede calcular para variables cuantitativas**: solo podemos calcular medias de números.

* **Mediana**: medida de centralización definida como el **valor que ocupa el centro de los datos** cuando los **ordenamos de menor a mayor**, un valor que nos deja por debajo al menos el 50% y por encima al menos el 50%, y **SOLO se puede calcular para variables cuantitativas** o **variables cualitatives ordinales** (solo podemos calcular el valor de en medio en datos que permitan ser ordenados).

* **Moda**: medida de centralización definida como el **valor más repetido**. Al contrario que la media y la mediana, la moda **no tiene porque ser única**: podemos tener un empate. Si todos se repiten por igual, al no destacar ninguno, se dice que es **amodal**. Se puede **calcular para todo tipo de variables**.

---

# Paréntesis: estadística descriptiva

.pull-left[

Es importante saber las **diferencias entre las medidas de centralización** respecto a lo que en estadística se llama **robustez**

* La **media es muy poco robusta**: valores extremos la perturban muy fácil. Piensa en una baraja de cartas: si extraemos 10 ases, la media será 1. Si cambiamos uno por un 10, solo por cambiar el 10% de los datos la media casi se duplica.


```r
mean(c(1, 1, 1, 1, 1, 1, 1, 1, 1, 10))
```

```
&gt; [1] 1.9
```

* La **mediana es algo más robusta** pero la **moda es la más robusta**: para que cambie en el ejemplo se necesitarían cambiar más de la mitad de los datos Y ADEMÁS que los nuevos sean todos repetidos.

]

.pull-right[

![](https://www.bankinter.com/file_source/blog/Contents/A-Imagenes/Interior%20noticias/salario-medio-mas-frecuente.jpg)

La **falta de robustez** de la media es la razón por la que, a la hora de analizar por ejemplo datos tan desiguales como los salarios en España, el **salario medio** no nos aporta realmente información útil sobre la centralidad de los datos, ya que personas extremadamente ricas hacen que la media sea bastante más elevada que el **salario más frecuente**.

]

---

# Paréntesis: estadística descriptiva

De la misma manera podemos pedirle que nos calcule **medidas de dispersión** (varianza, desv. típica y cv), que nos indican cómo de **dispersos están los datos respecto a un centro**, normalmente la media, y **medidas de localización (percentiles)**, valores que nos parten los datos en trozos iguales)


&amp;nbsp;

El **coeficiente de variación (CV)** es una medida de dispersión adimensional: nos permita comparar entre variables para saber cuál es más dispersa.

---



# Agrupar: group_by()


Una de las funciones más potentes es `group_by()`  que nos permitirá **agrupar nuestros registros**


```r
# Idea
datos %&gt;%
  filtro() %&gt;%
  ordeno() %&gt;%
  selecciono() %&gt;%
  modifico() %&gt;%
  agrupo(var1, var2, ...) %&gt;%
  cuento(var) %&gt;%
* desagrupo()
```

Cuando aplicamos `group_by()` es importante entender que **NO MODIFICA los datos**: nos crea una variable de grupo que **modificará las acciones futuras que apliquemos**. Internamente, es como generar **múltiples subtablas**, y las operaciones aplicadas después se **aplicarán a cada una por separado**.

---

# Agrupar: group_by()

.pull-left[

Por ejemplo, vamos a **agrupar por las variables `sex` y `gender`**, y después aplicaremos `count()`: ya no realiza el conteo de filas en general, sino que cuenta los registros para cada par sexo-género distinto (realiza la acción en cada subtabla).


```r
starwars %&gt;%
* group_by(sex, gender) %&gt;%
  count() %&gt;%
* ungroup()
```

```
&gt; # A tibble: 6 x 3
&gt;   sex            gender        n
&gt;   &lt;chr&gt;          &lt;chr&gt;     &lt;int&gt;
&gt; 1 female         feminine     16
&gt; 2 hermaphroditic masculine     1
&gt; 3 male           masculine    60
&gt; 4 none           feminine      1
&gt; 5 none           masculine     5
&gt; 6 &lt;NA&gt;           &lt;NA&gt;          4
```

**IMPORTANTE**: siempre que agrupes, acuérdate de desagrupar con `ungroup()`.

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/group_1.jpg" alt="Flujo de https://tidydatatutor.com/" width="150%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/group_count.jpg" alt="Flujo de https://tidydatatutor.com/" width="150%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]

---

# Resumir: summarise()


La función `summarise()` unida a `group_by()` es de las más útiles de `{tidyverse}`: nos permite **sumarizar o resumir nuestros datos**.


```r
# Idea
datos %&gt;%
  filtro() %&gt;%
  selecciono() %&gt;%
* agrupo(var1, var2, ...) %&gt;%
  resumo() %&gt;%
* desagrupo()
```

Un ejemplo: vamos a calcular la **media de las alturas**. Si lo hacemos sin `group_by()` se hará de todos los personajes.


```r
starwars %&gt;% drop_na(height) %&gt;%
* summarise(media_altura = mean(height))
```

```
&gt; # A tibble: 1 x 1
&gt;   media_altura
&gt;          &lt;dbl&gt;
&gt; 1         174.
```

---

# Resumir: summarise()

.pull-left[


```r
# Idea
datos %&gt;%
  filtro() %&gt;%
  selecciono() %&gt;%
* agrupo(var1, var2, ...) %&gt;%
  resumo() %&gt;%
* desagrupo()
```

Si la misma acción la realizamos con un `group_by()` previo, la media de las alturas se hará ahora **de forma independiente, en cada subtabla por grupo creada**.


```r
starwars %&gt;% drop_na(height) %&gt;% group_by(sex) %&gt;% 
  summarise(media = mean(height)) %&gt;%
  ungroup()
```

```
&gt; # A tibble: 5 x 2
&gt;   sex            media
&gt;   &lt;chr&gt;          &lt;dbl&gt;
&gt; 1 female          169.
&gt; 2 hermaphroditic  175 
&gt; 3 male            179.
&gt; 4 none            131.
&gt; 5 &lt;NA&gt;            181.
```


]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/group_summarise.jpg" alt="Flujo de https://tidydatatutor.com/" width="150%" /&gt;
&lt;p class="caption"&gt;Flujo de https://tidydatatutor.com/&lt;/p&gt;
&lt;/div&gt;

]


---

# Resumir: summarise()

Podemos **resumir varias variables a la vez**, haciendo uso de la función `across()`

* primero indicamos **las variables a recorrer** (en este caso `height:mass`)
* después indicamos la función a aplicar (en este caso, la media `mean()`
* por último indicamos  argumentos extras si fuesen necesarios (en este caso, `na.rm = TRUE` para eliminar los ausentes en la media)


```r
starwars %&gt;%
* group_by(sex) %&gt;%
* summarise(medias = across(height:mass, mean, na.rm = TRUE)) %&gt;%
  ungroup()
```

```
&gt; # A tibble: 5 x 2
&gt;   sex            medias$height  $mass
&gt;   &lt;chr&gt;                  &lt;dbl&gt;  &lt;dbl&gt;
&gt; 1 female                  169.   54.7
&gt; 2 hermaphroditic          175  1358  
&gt; 3 male                    179.   81.0
&gt; 4 none                    131.   69.8
&gt; 5 &lt;NA&gt;                    181.   48
```

---

# Resumir: summarise()

Además la función `across()` podemos combinarla con `where()`, para que resuma las variables de un mismo tipo, por ejemplo `where(is.numeric)` selecciona solo las numéricas.


```r
starwars %&gt;%
  drop_na(height, mass) %&gt;%
  group_by(sex, gender) %&gt;%
  summarise(across(where(is.numeric), mean)) %&gt;%
  ungroup()
```

```
&gt; # A tibble: 5 x 5
&gt;   sex            gender    height   mass birth_year
&gt;   &lt;chr&gt;          &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;
&gt; 1 female         feminine    169.   54.7         NA
&gt; 2 hermaphroditic masculine   175  1358          600
&gt; 3 male           masculine   178.   81.0         NA
&gt; 4 none           masculine   140    69.8         NA
&gt; 5 &lt;NA&gt;           &lt;NA&gt;        178    48           NA
```

Algunas de las funciones más útiles dentro de `summarise()`:

* `sum()`, `mean()`, `median()`
* `min()`, `which.min()`, `max()`, `which.max()`
* `n()` (número de registros), `n_distinct()` (número de registros únicos).

---

# Resumir: skim()

En el paquete `{skimr}` tenemos una función `skim()` que noes permite **resumir rápidamente nuestras variables**, proporcionándonos los principales parámetros de centralización, dispersión y localización.


```r
library(skimr)
starwars %&gt;%
  select(name:gender) %&gt;%
  skim()
```

---

# Operaciones por filas: rowwise()

Una opción muy útil usada antes de una operación también es `rowwise()`: toda operación que venga después se aplicará **en cada fila por separado**. Por ejemplo, vamos a definir un conjunto dummy de notas.


```r
notas &lt;- tibble("mates" = sample(0:10, size = 4, replace = TRUE),
                "lengua" = sample(0:10, size = 4, replace = TRUE))
```




Si aplicamos la media directamente, en cada fila el valor `media_curso` es **idéntico ya que nos ha hecho la media global**.  En realidad a nosotros nos gustaría **sacar una media por registro, por alumno**. Para eso usaremos `rowwise()` antes del cálculo.


```r
# Aplicado por fila
notas %&gt;% rowwise() %&gt;% mutate(media_curso = mean(c(mates, lengua)))
```

```
&gt; # A tibble: 4 x 3
&gt; # Rowwise: 
&gt;   mates lengua media_curso
&gt;   &lt;int&gt;  &lt;int&gt;       &lt;dbl&gt;
&gt; 1     4      6         5  
&gt; 2     8      9         8.5
&gt; 3     8      3         5.5
&gt; 4     0      8         4
```

---

# Ejercicios


.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: con `group_by()` y `count()`, extrae cuántas personajes a cada especie de `starwars`

* 📝 **Ejercicio 2**: determina con `summarise()` y `n_distinct()` el número de especies distintas


* 📝 **Ejercicio 3**: tras eliminar ausentes de peso y altura, añade una nueva variable que nos calcule el IMC de cada personaje, y determina el IMC medio de nuestros datos desagregados por sexo.

* 📝 **Ejercicio 4**: obtén la edad mínima y máxima de cada sexo.

]

.panel[.panel-name[Sol. Ej. 1]


```r
starwars %&gt;% 
  group_by(species) %&gt;%
  count() %&gt;%
  ungroup()
```

```
&gt; # A tibble: 38 x 2
&gt;    species       n
&gt;    &lt;chr&gt;     &lt;int&gt;
&gt;  1 Aleena        1
&gt;  2 Besalisk      1
&gt;  3 Cerean        1
&gt;  4 Chagrian      1
&gt;  5 Clawdite      1
&gt;  6 Droid         6
&gt;  7 Dug           1
&gt;  8 Ewok          1
&gt;  9 Geonosian     1
&gt; 10 Gungan        3
&gt; # ... with 28 more rows
```

]

.panel[.panel-name[Sol. Ej. 2]


```r
starwars %&gt;%
  summarise(especies_distintas = n_distinct(species))
```

```
&gt; # A tibble: 1 x 1
&gt;   especies_distintas
&gt;                &lt;int&gt;
&gt; 1                 38
```

]

.panel[.panel-name[Sol. Ej. 3]



```r
starwars %&gt;%
  drop_na(height, mass) %&gt;%
  mutate(IMC = mass / (height/100)^2) %&gt;%
  group_by(sex) %&gt;%
  summarise(media_IMC = mean(IMC)) %&gt;%
  ungroup()
```

```
&gt; # A tibble: 5 x 2
&gt;   sex            media_IMC
&gt;   &lt;chr&gt;              &lt;dbl&gt;
&gt; 1 female              19.2
&gt; 2 hermaphroditic     443. 
&gt; 3 male                25.7
&gt; 4 none                32.7
&gt; 5 &lt;NA&gt;                15.1
```


]


.panel[.panel-name[Sol. Ej. 4]


```r
starwars %&gt;% drop_na(birth_year) %&gt;%
  group_by(sex) %&gt;%
  summarise(edad_min = min(birth_year),
            edad_max = max(birth_year))
```

```
&gt; # A tibble: 5 x 3
&gt;   sex            edad_min edad_max
&gt;   &lt;chr&gt;             &lt;dbl&gt;    &lt;dbl&gt;
&gt; 1 female               19       72
&gt; 2 hermaphroditic      600      600
&gt; 3 male                  8      896
&gt; 4 none                 15      112
&gt; 5 &lt;NA&gt;                 62       62
```


]

]

---

name: purr
class: center, middle

# Introducción al manejo de listas

## **Concatenando cualquier objeto**

&amp;nbsp;

Las listas son un tipo de objeto que permite incluir cualquier tipo de dato y longitud, y el paquete `{purrr}` de `{tidyverse}` permite su manejo como si fuesen vectores.

---

# Purrr: listas

Las **listas** son el tipo de dato **más flexible** ya que permite **concatenar variables de diferente tipo pero también de diferente longitud**, con estructuras totalmente heterógeneas.

Un ejemplo: vamos a crear una lista con un vector de textos (nombre de  padres), un valor lógico (si están casado o no) y un vector numérico (edades de los miembros que viven con nosotros)


```r
var1 &lt;- c("Paloma", "Gregorio")
var2 &lt;- TRUE
var3 &lt;- c(61, 62, 28)
```

Para reunirlas en un solo objeto de tipo lista basta con usar `list()`, indicándole si queremos el nombre de cada elemento.


```r
lista &lt;- list("nombres_padres" = var1, "casados" = var2, "edades_familia" = var3)
lista
```

```
&gt; $nombres_padres
&gt; [1] "Paloma"   "Gregorio"
&gt; 
&gt; $casados
&gt; [1] TRUE
&gt; 
&gt; $edades_familia
&gt; [1] 61 62 28
```

---

# Purrr: listas

* **Longitud**: las variables de tipo lista solo tienen una dimensión, como un vector (solo que en cada elemento hay a su vez otro objeto)


```r
length(lista)
```

```
&gt; [1] 3
```

Si los juntásemos con un data.frame o tibble, al tener distinta longitud, obtendríamos un error: 


```r
data.frame("nombres_padres" = var1,
           "casados" = var2,
           "edades_familia" = var3)
```

```
&gt; Error in data.frame(nombres_padres = var1, casados = var2, edades_familia = var3): arguments imply differing number of rows: 2, 1, 3
```

---
  
# Purrr: listas

  
Para **acceder a un elemento de la lista** tenemos dos opciones:


* **Acceder por índice**: con el operador `[[i]]` accedemos al elemento i-ésimo de la lista (con el corchete doble, en contraposición con el corchete simple que nos permite acceder a varios elementos a la vez)


* **Acceder por nombre**: con el operador `$` accedemos al elemento por su nombre


```r
# Accedemos por índice
lista[[1]]
```

```
&gt; [1] "Paloma"   "Gregorio"
```

```r
lista$progenitores
```

```
&gt; NULL
```

```r
lista[1:2]
```

```
&gt; $nombres_padres
&gt; [1] "Paloma"   "Gregorio"
&gt; 
&gt; $casados
&gt; [1] TRUE
```

---

# Purrr: listas

Una lista no se puede vectorizar de forma inmediata, por lo cualquier operación aritmética aplicada a una lista dará error.


```r
datos &lt;- list("a" = 1:5, "b" = 10:20)
datos
```

```
&gt; $a
&gt; [1] 1 2 3 4 5
&gt; 
&gt; $b
&gt;  [1] 10 11 12 13 14 15 16 17 18 19 20
```

```r
datos / 2
```

```
&gt; Error in datos/2: argumento no-numérico para operador binario
```

Para ello están disponibles las funciones del paquete `{purrr}`.

---

# Purrr: listas

La más sencilla es `map()`, que **recorre cada elemento de la lista** y nos aplica la función que le indiquemos.


```r
datos %&gt;% map(mean)
```

```
&gt; $a
&gt; [1] 3
&gt; 
&gt; $b
&gt; [1] 15
```

Puede ser una función predefinida o una propia


```r
datos %&gt;% map(function(x) { x / 2})
```

```
&gt; $a
&gt; [1] 0.5 1.0 1.5 2.0 2.5
&gt; 
&gt; $b
&gt;  [1]  5.0  5.5  6.0  6.5  7.0  7.5  8.0  8.5  9.0  9.5 10.0
```

---

# Purrr: listas

Si te fijas por defecto `map()` devuelve a su vez una lista


```r
datos %&gt;% map(mean)
```

```
&gt; $a
&gt; [1] 3
&gt; 
&gt; $b
&gt; [1] 15
```

¿Cómo indicarle que **queremos que nos devuelva un vector numérico** con las medias? Tenemos a nuestra disposición distintas funciones `map_xxx()`, como `map_dbl()`, para indicarle el formato de salida


```r
datos %&gt;% map_dbl(mean)
```

```
&gt;  a  b 
&gt;  3 15
```


---

name: joins
class: center, middle

# Relacionando datos

## **Cruzando tablas con joins**

&amp;nbsp;

No siempre tenemos la información en una sola tabla y a veces nos interesará cruzar las tablas por algún identificador como un DNI o un id.


---

# Relacionando datos: join

Un clásico de todo lenguaje que maneja datos son los famosos **join**: siempre que veamos un join, lo debemos imaginar es que estamos **cruzando una o variables tablas**, haciendo uso de una columna identificadora de cada una de ellas (por ejemplo, imagina que cruzamos datos de hacienda y de antecedentes penales, haciendo _join_ por la columna `DNI`).



&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://dadosdelaplace.github.io/courses-ECI-2022/img/sql-joins.jpg" alt="Esquema con los principales tipos de join, extraído de https://estradawebgroup.com/Post/-Que-es-y-para-que-sirve-SQL-Joins-/4278" width="60%" /&gt;
&lt;p class="caption"&gt;Esquema con los principales tipos de join, extraído de https://estradawebgroup.com/Post/-Que-es-y-para-que-sirve-SQL-Joins-/4278&lt;/p&gt;
&lt;/div&gt;


---

# Relacionando datos: join

.pull-left[


```r
tabla_1 %&gt;% 
  xxx_join(tabla_2)
```

Disponemos de distintos tipos de join:

* `inner_join()`: solo **sobreviven los registros cuyos id esté en ambas** tablas.
* `left_join()`: **mantiene todos los registros de la primera tabla**, y busca cuales tienen id también en la segunda (en caso de no tenerlo, se rellena con ausente los campos de la segunda tabla).
* `right_join()`: **mantiene todos los registros de la segunda tabla**, y busca cuales tienen id también en la primera (en caso de no tenerlo, se rellena con ausente los campos de la primera tabla).
* `anti_join()`: nos devuelve los **registros que estén en la primera tabla y no en la segunda**.

]


.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://dadosdelaplace.github.io/courses-ECI-2022/img/left_join.jpg" alt="Esquema del left join" width="50%" /&gt;
&lt;p class="caption"&gt;Esquema del left join&lt;/p&gt;
&lt;/div&gt;

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://dadosdelaplace.github.io/courses-ECI-2022/img/right_join.jpg" alt="Esquema del right join" width="50%" /&gt;
&lt;p class="caption"&gt;Esquema del right join&lt;/p&gt;
&lt;/div&gt;

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://dadosdelaplace.github.io/courses-ECI-2022/img/full_join.jpg" alt="Esquema del full join, extraído de https://r4ds.had.co.nz/relational-data.html#mutating-joins" width="50%" /&gt;
&lt;p class="caption"&gt;Esquema del full join, extraído de https://r4ds.had.co.nz/relational-data.html#mutating-joins&lt;/p&gt;
&lt;/div&gt;

]

---

# Relacionando datos: join

Para los ejemolos usaremos las tablas disponibles en el paquete `{nycflights13}`


```r
library(nycflights13)
```

* airlines: nombre de aerolíneas (con su abreviatura).
* airports: datos de aeropuertos (nombres, longitud, latitud, altitud, etc).
* flights: datos de vuelos.
* planes: datos de los aviones.
* weather: datos meteorológicos horarios de las estaciones LGA, JFK y EWR.


```r
# Seleccionamos antes columnas para que sea más corto
flights_filtrada &lt;- flights %&gt;%
  select(year:day, arr_time, carrier:dest)
flights_filtrada
```

```
&gt; # A tibble: 336,776 x 9
&gt;     year month   day arr_time carrier flight tailnum origin dest 
&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;
&gt;  1  2013     1     1      830 UA        1545 N14228  EWR    IAH  
&gt;  2  2013     1     1      850 UA        1714 N24211  LGA    IAH  
&gt;  3  2013     1     1      923 AA        1141 N619AA  JFK    MIA  
&gt;  4  2013     1     1     1004 B6         725 N804JB  JFK    BQN  
&gt;  5  2013     1     1      812 DL         461 N668DN  LGA    ATL  
&gt;  6  2013     1     1      740 UA        1696 N39463  EWR    ORD  
&gt;  7  2013     1     1      913 B6         507 N516JB  EWR    FLL  
&gt;  8  2013     1     1      709 EV        5708 N829AS  LGA    IAD  
&gt;  9  2013     1     1      838 B6          79 N593JB  JFK    MCO  
&gt; 10  2013     1     1      753 AA         301 N3ALAA  LGA    ORD  
&gt; # ... with 336,766 more rows
```

---

# Left join

.pull-left[

* `left_join()`: **mantiene todos los registros de la primera tabla**, y busca cuales tienen id también en la segunda (en caso de no tenerlo, se rellena con ausente los campos de la segunda tabla).


```r
flights_filtrada %&gt;%
  left_join(airlines)
```

]


.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://dadosdelaplace.github.io/courses-ECI-2022/img/left_join.jpg" alt="Esquema del left join" width="60%" /&gt;
&lt;p class="caption"&gt;Esquema del left join&lt;/p&gt;
&lt;/div&gt;

]


Queremos **TODAS las filas de los vuelos** con la información extra que tenemos de la aerolínea que opere los vuelos. El campo común que nos permite cruzarla, la **clave (key)**, es el código abreviado de las aerolíneas (`by = carrier`).


```r
flights_filtrada %&gt;% left_join(airlines, by = "carrier")
```

```
&gt; # A tibble: 336,776 x 10
&gt;     year month   day arr_time carrier flight tailnum origin dest  name          
&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;         
&gt;  1  2013     1     1      830 UA        1545 N14228  EWR    IAH   United Air Li~
&gt;  2  2013     1     1      850 UA        1714 N24211  LGA    IAH   United Air Li~
&gt;  3  2013     1     1      923 AA        1141 N619AA  JFK    MIA   American Airl~
&gt;  4  2013     1     1     1004 B6         725 N804JB  JFK    BQN   JetBlue Airwa~
&gt;  5  2013     1     1      812 DL         461 N668DN  LGA    ATL   Delta Air Lin~
&gt;  6  2013     1     1      740 UA        1696 N39463  EWR    ORD   United Air Li~
&gt;  7  2013     1     1      913 B6         507 N516JB  EWR    FLL   JetBlue Airwa~
&gt;  8  2013     1     1      709 EV        5708 N829AS  LGA    IAD   ExpressJet Ai~
&gt;  9  2013     1     1      838 B6          79 N593JB  JFK    MCO   JetBlue Airwa~
&gt; 10  2013     1     1      753 AA         301 N3ALAA  LGA    ORD   American Airl~
&gt; # ... with 336,766 more rows
```

---

# Left join

La tabla `airlines` tenía 2 columnas, una la clave y otra con el nombre `name` de la aerolínea. ¿Y si en flights hay algún vuelo operado por alguna aerolínea que no estuviese en esa segunda tabla `airlines`? Al estar haciendo `left_join()`, nos mantendrá todos los registros de la primera tabla pero si no los encuentra en la segunda, imputará ausente.


```r
# Eliminamos una aerolínea
airlines_sin_UA &lt;- airlines %&gt;% filter(!(carrier %in% c("UA")))
flights_filtrada %&gt;% left_join(airlines_sin_UA, by = "carrier")
```

```
&gt; # A tibble: 336,776 x 10
&gt;     year month   day arr_time carrier flight tailnum origin dest  name          
&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;         
&gt;  1  2013     1     1      830 UA        1545 N14228  EWR    IAH   &lt;NA&gt;          
&gt;  2  2013     1     1      850 UA        1714 N24211  LGA    IAH   &lt;NA&gt;          
&gt;  3  2013     1     1      923 AA        1141 N619AA  JFK    MIA   American Airl~
&gt;  4  2013     1     1     1004 B6         725 N804JB  JFK    BQN   JetBlue Airwa~
&gt;  5  2013     1     1      812 DL         461 N668DN  LGA    ATL   Delta Air Lin~
&gt;  6  2013     1     1      740 UA        1696 N39463  EWR    ORD   &lt;NA&gt;          
&gt;  7  2013     1     1      913 B6         507 N516JB  EWR    FLL   JetBlue Airwa~
&gt;  8  2013     1     1      709 EV        5708 N829AS  LGA    IAD   ExpressJet Ai~
&gt;  9  2013     1     1      838 B6          79 N593JB  JFK    MCO   JetBlue Airwa~
&gt; 10  2013     1     1      753 AA         301 N3ALAA  LGA    ORD   American Airl~
&gt; # ... with 336,766 more rows
```

---

# Right join


.pull-left[

* `right_join()`: **mantiene todos los registros de la segunda tabla**, y busca cuales id en la primera.


```r
tabla_1 %&gt;%
  right_join(tabla_2)
```

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://dadosdelaplace.github.io/courses-ECI-2022/img/right_join.jpg" alt="Esquema del right join" width="60%" /&gt;
&lt;p class="caption"&gt;Esquema del right join&lt;/p&gt;
&lt;/div&gt;

]


```r
tabla_1 &lt;- tibble("key_1" = 1:5, "valor" = paste0("x", 1:5))
tabla_2 &lt;- tibble("key_2" = 3:7, "valor" = paste0("x", 3:7))
```

.pull-left[


```r
# Left
tabla_1 %&gt;%
  left_join(tabla_2, by = c("key_1" = "key_2"))
```

```
&gt; # A tibble: 5 x 3
&gt;   key_1 valor.x valor.y
&gt;   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;  
&gt; 1     1 x1      &lt;NA&gt;   
&gt; 2     2 x2      &lt;NA&gt;   
&gt; 3     3 x3      x3     
&gt; 4     4 x4      x4     
&gt; 5     5 x5      x5
```
]

.pull-right[


```r
# Left
tabla_1 %&gt;%
  right_join(tabla_2, by = c("key_1" = "key_2"))
```

```
&gt; # A tibble: 5 x 3
&gt;   key_1 valor.x valor.y
&gt;   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;  
&gt; 1     3 x3      x3     
&gt; 2     4 x4      x4     
&gt; 3     5 x5      x5     
&gt; 4     6 &lt;NA&gt;    x6     
&gt; 5     7 &lt;NA&gt;    x7
```
]


---

# Claves y sufijos

* `by = c("var_t1" = "var_t2")`: le indicaremos en qué columna de cada tabla están las claves por las que vamos a cruzar (si se llaman igual, basta con `by = "var_t1"`).

.pull-left[


```r
# Left
tabla_1 %&gt;%
  left_join(tabla_2, by = c("key_1" = "key_2"))
```

```
&gt; # A tibble: 5 x 3
&gt;   key_1 valor.x valor.y
&gt;   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;  
&gt; 1     1 x1      &lt;NA&gt;   
&gt; 2     2 x2      &lt;NA&gt;   
&gt; 3     3 x3      x3     
&gt; 4     4 x4      x4     
&gt; 5     5 x5      x5
```
]

.pull-right[


```r
# Left
tabla_1 %&gt;%
  right_join(tabla_2, by = c("key_1" = "key_2"))
```

```
&gt; # A tibble: 5 x 3
&gt;   key_1 valor.x valor.y
&gt;   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;  
&gt; 1     3 x3      x3     
&gt; 2     4 x4      x4     
&gt; 3     5 x5      x5     
&gt; 4     6 &lt;NA&gt;    x6     
&gt; 5     7 &lt;NA&gt;    x7
```
]


Además podemos **cruzar por varias columnas a la vez** (interpretará como igual registro aquel que tenga el conjunto de claves igual), con `by = c("var1_t1" = "var1_t2", "var2_t1" = "var2_t2", ...)`


---

# Claves y sufijos


* `suffix`: si al unir dos tablas, hay columnas que se llaman igual, por defecto nos añade los sufijos `_x` y `_y`.


```r
# Left
tabla_1 %&gt;% left_join(tabla_2, by = c("key_1" = "key_2"))
```

```
&gt; # A tibble: 5 x 3
&gt;   key_1 valor.x valor.y
&gt;   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;  
&gt; 1     1 x1      &lt;NA&gt;   
&gt; 2     2 x2      &lt;NA&gt;   
&gt; 3     3 x3      x3     
&gt; 4     4 x4      x4     
&gt; 5     5 x5      x5
```

Dicho **sufijo podemos especificárselo** en `suffix`, que nos permita distingar la variable de una tabla y de otra.



```r
# Left
tabla_1 %&gt;% left_join(tabla_2, by = c("key_1" = "key_2"), suffix = c("_tab1", "_tab_2"))
```

```
&gt; # A tibble: 5 x 3
&gt;   key_1 valor_tab1 valor_tab_2
&gt;   &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;      
&gt; 1     1 x1         &lt;NA&gt;       
&gt; 2     2 x2         &lt;NA&gt;       
&gt; 3     3 x3         x3         
&gt; 4     4 x4         x4         
&gt; 5     5 x5         x5
```
]

---

# Inner, full y anti join

* `inner_join()` vs `full_join()`: solo los registros comunes vs todos de ambas.


```r
# Inner
tabla_1 %&gt;% inner_join(tabla_2, by = c("key_1" = "key_2"), suffix = c("_tab1", "_tab_2"))
```

```
&gt; # A tibble: 3 x 3
&gt;   key_1 valor_tab1 valor_tab_2
&gt;   &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;      
&gt; 1     3 x3         x3         
&gt; 2     4 x4         x4         
&gt; 3     5 x5         x5
```


```r
# full
tabla_1 %&gt;% full_join(tabla_2, by = c("key_1" = "key_2"), suffix = c("_tab1", "_tab_2"))
```

```
&gt; # A tibble: 7 x 3
&gt;   key_1 valor_tab1 valor_tab_2
&gt;   &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;      
&gt; 1     1 x1         &lt;NA&gt;       
&gt; 2     2 x2         &lt;NA&gt;       
&gt; 3     3 x3         x3         
&gt; 4     4 x4         x4         
&gt; 5     5 x5         x5         
&gt; 6     6 &lt;NA&gt;       x6         
&gt; 7     7 &lt;NA&gt;       x7
```

* `anti_join()`: los que están en la primera y no en la segunda.


```r
# antijoin
tabla_1 %&gt;%
  anti_join(tabla_2, by = c("key_1" = "key_2"), suffix = c("_tabla1", "_tabla_2"))
```

```
&gt; # A tibble: 2 x 2
&gt;   key_1 valor
&gt;   &lt;int&gt; &lt;chr&gt;
&gt; 1     1 x1   
&gt; 2     2 x2
```

---

# Ejercicios


.panelset[
.panel[.panel-name[Ejercicios]


* 📝 **Ejercicio 1**: del paquete `{nycflights13}` cruza la tabla `flights` con `airlines`. Queremos mantener todos los registros de vuelo, añadiendo la información de las aerolíneas a la tabla de aviones. 

* 📝 **Ejercicio 2**: a la tabla obtenida del apartado anterior, cruza con los datos de los aviones en `planes`, pero incluyendo solo aquellos vuelos de los que tengamos información de sus aviones (y viceversa). 

* 📝 **Ejercicio 3**: repite el ejercicio anterior pero conservando ambas variables `year` (en una es el año del vuelo, en la otra es el año de construcción del avión).

]

.panel[.panel-name[Sol. Ej. 1]


```r
flights %&gt;% left_join(airlines, by = "carrier")
```

```
&gt; # A tibble: 336,776 x 20
&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
&gt;  1  2013     1     1      517            515         2      830            819
&gt;  2  2013     1     1      533            529         4      850            830
&gt;  3  2013     1     1      542            540         2      923            850
&gt;  4  2013     1     1      544            545        -1     1004           1022
&gt;  5  2013     1     1      554            600        -6      812            837
&gt;  6  2013     1     1      554            558        -4      740            728
&gt;  7  2013     1     1      555            600        -5      913            854
&gt;  8  2013     1     1      557            600        -3      709            723
&gt;  9  2013     1     1      557            600        -3      838            846
&gt; 10  2013     1     1      558            600        -2      753            745
&gt; # ... with 336,766 more rows, and 12 more variables: arr_delay &lt;dbl&gt;,
&gt; #   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
&gt; #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;,
&gt; #   name &lt;chr&gt;
```

]

.panel[.panel-name[Sol. Ej. 2]


```r
flights %&gt;% left_join(airlines, by = "carrier") %&gt;%
  inner_join(planes, by = "tailnum")
```

```
&gt; # A tibble: 284,170 x 28
&gt;    year.x month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
&gt;     &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
&gt;  1   2013     1     1      517            515         2      830            819
&gt;  2   2013     1     1      533            529         4      850            830
&gt;  3   2013     1     1      542            540         2      923            850
&gt;  4   2013     1     1      544            545        -1     1004           1022
&gt;  5   2013     1     1      554            600        -6      812            837
&gt;  6   2013     1     1      554            558        -4      740            728
&gt;  7   2013     1     1      555            600        -5      913            854
&gt;  8   2013     1     1      557            600        -3      709            723
&gt;  9   2013     1     1      557            600        -3      838            846
&gt; 10   2013     1     1      558            600        -2      849            851
&gt; # ... with 284,160 more rows, and 20 more variables: arr_delay &lt;dbl&gt;,
&gt; #   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
&gt; #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;,
&gt; #   name &lt;chr&gt;, year.y &lt;int&gt;, type &lt;chr&gt;, manufacturer &lt;chr&gt;, model &lt;chr&gt;,
&gt; #   engines &lt;int&gt;, seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt;
```
]

.panel[.panel-name[Sol. Ej. 2]


```r
flights %&gt;% left_join(airlines, by = "carrier") %&gt;%
  inner_join(planes, by = "tailnum",
             suffix = c("_vuelo", "_const"))
```

```
&gt; # A tibble: 284,170 x 28
&gt;    year_vuelo month   day dep_time sched_dep_time dep_delay arr_time
&gt;         &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
&gt;  1       2013     1     1      517            515         2      830
&gt;  2       2013     1     1      533            529         4      850
&gt;  3       2013     1     1      542            540         2      923
&gt;  4       2013     1     1      544            545        -1     1004
&gt;  5       2013     1     1      554            600        -6      812
&gt;  6       2013     1     1      554            558        -4      740
&gt;  7       2013     1     1      555            600        -5      913
&gt;  8       2013     1     1      557            600        -3      709
&gt;  9       2013     1     1      557            600        -3      838
&gt; 10       2013     1     1      558            600        -2      849
&gt; # ... with 284,160 more rows, and 21 more variables: sched_arr_time &lt;int&gt;,
&gt; #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,
&gt; #   dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;,
&gt; #   time_hour &lt;dttm&gt;, name &lt;chr&gt;, year_const &lt;int&gt;, type &lt;chr&gt;,
&gt; #   manufacturer &lt;chr&gt;, model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, speed &lt;int&gt;,
&gt; #   engine &lt;chr&gt;
```
]

]

---

class: inverse center middle

# Bloque III: Introducción al dataviz en R.

&amp;nbsp;

.left[

### 👉 [Dataviz: Introducción histórica.](#intro-historica)

### 👉 [Introducción a ggplot2](#intro-ggplot2)

### 👉 [La importancia de visualizar datos](#importancia-dataviz)

### 👉 [Profundizando en ggplot2](#importancia-dataviz)

]

---

name: intro-historica
class: center, middle

# Dataviz: introducción histórica

## **La historia de los gráficos estadísticos**

&amp;nbsp;

La aparición de gráficos estadísticos es relativamente reciente en la ciencia (hasta la Edad Media solo se acercaban a la idea los mapas)

---

# Breve historia del dataviz


## Punto de partida: los mapas

&lt;img src = "https://images-na.ssl-images-amazon.com/images/I/713JiiOHrEL.jpg" alt = "atlas" align = "right" width = "230" style = "margin-top: 0.1vh;margin-right: 0.5rem;margin-left: 0.5rem;"&gt;

Podríamos considerar los **mapas** como las primeras **visualización de datos**, con la representación de nuestra realidad en **superficies bidimensionales**. Las propias palabras _chart_ y _cartography_ derivan del mismo origen latino, _charta_, así como otros términos matemáticos relacionados como contornos, niveles, curvas, escalas o dominios &lt;sup&gt;2&lt;/sup&gt;, aunque el primer uso datado de coordenadas parece venir de los egipcios. &lt;sup&gt;3&lt;/sup&gt;

Parte de esta introducción está basada en:

.footnote[[1] [«Gramática de las gráficas: pistas para mejorar las representaciones de datos» de Joaquín Sevilla](http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)

[2] [«Presentation Graphics» de Leland Wilkinson. International Encyclopedia of the Social &amp; Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

[3] [«Quantitative Graphics in Statistics: A Brief History» de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)]

---

# Breve historia de la estadística

.pull-left[

* Del (neo)latín «statisticum collegium»: consejo de **Estado**.
* Del alemán «statistik» (ciencia del **Estado**, intoducido por G. Achenwall).

&amp;nbsp;

**Origen**: una herramienta para la **administración** eficiente del Estado, pero **sin intención de comunicar ni de convertir el dato en información**.

#### Primeros usos: elaboración de censos

Los **primeros usos** documentados de la estadística fueron la elaboración de **censos** por parte de **mesopotámicos, chinos y egipcios**, con tres fines:

* Cobrar **impuestos** (un saludo, Willyrex).
* Reparto de **tierras** y optimización de su uso.
* **Reclutamiento de soldados**.

]

.pull-right[

## Estadística en la guerra

Según Tucídides, conceptos estadísticos como la **moda** datan del **siglo V a.C.**: para asaltar la muralla de la ciudad de Platea, ponían a contar a varios soldados el número de ladrillos vistos en la muralla, quedándose con el **conteo más repetido (la moda, el más frecuente)**, permitiendo el cálculo de la altura de la muralla.

&lt;img src="./img/peloponeso.jpg" width="70%" style="display: block; margin: auto;" /&gt;

]

---

# ¿Qué han hecho los romanos por nosotros?



.pull-left[

Precisamente por el tamaño de su Imperio, fueron los **romanos** quienes hicieron un uso más intenso de la estadística:

* **Censos** (elaborados por la censura, que elaboraba no solo el censo sino la supervisión de la moralidad pública).
* Primeras **tablas de natalidad/mortalidad**
* Primeros **catastros** (registros oficiales de propiedades, primeros impuestos)

&lt;img src="./img/catastro.jpg" width="60%" style="display: block; margin: auto;" /&gt;

]

.pull-right[

&lt;img src="https://www.publico.es/tremending/wp-content/uploads/2019/02/lifeofbrian3.jpg" width="95%" style="display: block; margin: auto auto auto 0;" /&gt;

]

---

# Breve historia de la estadística

.pull-left[

## **ÁRABES**

Autores de los **primeros tratados de estadística**, como el manuscrito de **Al-Kindi (801-873)**, que usó la distribución de **frecuencias de palabras** para el desarrollo de métodos de cifrado y descifrado de **mensajes encriptados**.

]

.pull-right[

## **MÉXICO**

Ya en el **año 1116, el rey Xólotl** implementó un **censo** que consistía en la **estimación de piedras**, tirando cada súbdito una a un montón (Nepohualco).
]


&amp;nbsp;

.pull-left[

## **INGLATERRA**

Desde el siglo XII se realiza la **Prueba del Pyx**, considerado uno de los **primeros controles de calidad**: se extre una de las monedas acuñadas y se deposita en una caja, para un año después comprobar su calidad y pureza.

]

.pull-right[

## **ITALIA**

En paralelo al **auge de los primeros «sistemas financieros» en Italia**, «La Nuova Crónica» de G. Villani fue considerado durante mucho tiempo el primer tratado de estadística (hasta el descubrimiento de los trabajos de Al-Kindi).

]

---

# Navegación y astronomía

Y es de aquella época medieval, en la que la navegación y la astronomía empezaban a tomar relevancia científica, cuando aparece la que se considera la primera gráfica (aunque no propiamente estadística) &lt;sup&gt;3&lt;/sup&gt;, representando el **movimiento cíclico de los planetas** (entre los siglos X y XI)

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/dataviz_historico_1.png" alt="Gráfica extraída de Beniger y Robyn (1978)" width="60%" /&gt;
&lt;p class="caption"&gt;Gráfica extraída de Beniger y Robyn (1978)&lt;/p&gt;
&lt;/div&gt;

[3] [«Quantitative Graphics in Statistics: A Brief History» de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)

 
---

# Navegación y astronomía

Con una motivación similar, en torno a 1360 el matemático **Nicole Oresme** diseñó el **primer gráfico de barras** (no estadístico), con la idea de **visualizar a la vez dos magnitudes físicas teóricas**.


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/dataviz_historico_2.jpeg" alt="Gráfica extraída de Friendly y Valero-Mora (2010), de «Tractatus De Latitudinibus Formarum»" width="30%" /&gt;
&lt;p class="caption"&gt;Gráfica extraída de Friendly y Valero-Mora (2010), de «Tractatus De Latitudinibus Formarum»&lt;/p&gt;
&lt;/div&gt;

[5] [«The First (Known) Statistical Graph: Michael Florent van Langren and the 'Secret' of Longitude» de M. Friendly y P. M. Valero-Mora. The American Statistician (2010)](https://www.researchgate.net/publication/227369016_The_First_Known_Statistical_Graph_Michael_Florent_van_Langren_and_the_Secret_of_Longitude)

 
---

# Primer gráfico estadístico

La mayoría de expertos, como Tufte &lt;sup&gt;6,7&lt;/sup&gt;, consideran **este gráfico** casi longitudinal como la **primera visualización de datos** de la historia, hecha por **van Langren** en 1644, representando la **distancia (en longitud) entre Toledo y Roma** (un poco mal medida ya que la distancia real es de 16.5º).

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/longitud_dataviz.jpg" alt="Gráfica original extraída de Friendly y Valero-Mora (2010)" width="45%" /&gt;
&lt;p class="caption"&gt;Gráfica original extraída de Friendly y Valero-Mora (2010)&lt;/p&gt;
&lt;/div&gt;

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/dataviz_historico_3.jpeg" alt="Adaptación extraída de Friendly y Valero-Mora (2010)" width="45%" /&gt;
&lt;p class="caption"&gt;Adaptación extraída de Friendly y Valero-Mora (2010)&lt;/p&gt;
&lt;/div&gt;

[6] [«Visual explanations: images and quantities, evidence and narrative» de E. Tufte](https://archive.org/details/visualexplanatio00tuft)

[7] [«PowerPoint is evil» de E. Tufte](https://www.wired.com/2003/09/ppt2/)

---

# ¿Qué es una gráfica estadística?

¿Por qué ese gráfico se considera la primera visualización estadística de la historia? ¿Qué es lo que hace que una visualización sea una gráfica estadística? **¿Cuál es la frontera entre una ilustración y una gráfica (de datos)?**

&amp;nbsp;

Esas mismas preguntas se hizo **Joaquín Sevilla** en su manual &lt;sup&gt;1&lt;/sup&gt;, argumentando que deben cumplir **3 requisitos**:

1. Que se base en el esquema de composición de **eje métrico** (proceso de medida): **no cualquier dibujo que incluya números** lo podemos denominar «gráfica estadística». 

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/mapa_sevilla.jpg" alt="INFOGRAFÍA extraída del manual de Joaquín Sevilla" width="55%" /&gt;
&lt;p class="caption"&gt;INFOGRAFÍA extraída del manual de Joaquín Sevilla&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/grafica_dinero_sevilla.jpg" alt="GRÁFICA extraída del manual de Joaquín Sevilla" width="53%" /&gt;
&lt;p class="caption"&gt;GRÁFICA extraída del manual de Joaquín Sevilla&lt;/p&gt;
&lt;/div&gt;

]

[1] [«Gramática de las gráficas: pistas para mejorar las representaciones de datos» de Joaquín Sevilla](http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)


---

# Vizfail

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/persona_dataviz.jpg" alt="Ejemplo de metáfora visual mal ejecutada" width="99%" /&gt;
&lt;p class="caption"&gt;Ejemplo de metáfora visual mal ejecutada&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

* La figura elegida (una persona caminando) no guarda relación alguna con lo que se pretende representar.

* Los sectores señalados no tienen relación con el ítem a representar, lo que dificulta su interpretación

* Los colores no dan información de ningún tipo.

* La forma hace imposible la comparación entre áreas (salvo que leas el % adjunto).

* La suma total supera el 100% ¿?

* **Sin la fuente de los datos**.

]

---

# ¿Qué es una gráfica estadística?

Ese **proceso de medida** en el que una gráfica se debe apoyar lo ilustra muy bien Alberto Cairo &lt;sup&gt;8&lt;/sup&gt; con esta **infografía**.


* ¿Sabrías decir en 5 segundos en que región el empleo ha crecido más? ¿Y menos?
* ¿Sabrías decir en 5 segundos si la variación ha sido mayor en Madrid, La Rioja o Canarias?

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/mapa_cairo_esp.jpg" alt="INFOGRAFÍA extraída de Alberto Cairo" width="65%" /&gt;
&lt;p class="caption"&gt;INFOGRAFÍA extraída de Alberto Cairo&lt;/p&gt;
&lt;/div&gt;

[8] «The Functional Art: an introduction to information graphics and visualization» de Alberto Cairo.

---

# ¿Qué es una gráfica estadística?


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/mapa_cairo_2.jpg" alt="GRÁFICA extraída de Alberto Cairo" width="90%" /&gt;
&lt;p class="caption"&gt;GRÁFICA extraída de Alberto Cairo&lt;/p&gt;
&lt;/div&gt;

La principal diferencia entre otro tipo de comunicación visual y una **gráfica estadística** radica en proporcionar **herramientas de medida**.

---

# ¿Qué es una gráfica estadística?

1. Que se base en el esquema de composición de **eje métrico**

2. Debe incluir **información cuantitativa** (debe visualizar datos)

3. La relación de representatividad debería **ser reversible**: los **datos deberían poder «recuperarse»** a partir de la gráfica (una gráfica estadística es un tipo particular de **aplicación** matemática).


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/sevilla_densidad.jpg" alt="Gráfica extraída del manual de Joaquín Sevilla" width="50%" /&gt;
&lt;p class="caption"&gt;Gráfica extraída del manual de Joaquín Sevilla&lt;/p&gt;
&lt;/div&gt;

[1] [«Gramática de las gráficas: pistas para mejorar las representaciones de datos» de Joaquín Sevilla](http://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)


---

# ¿Qué es una gráfica estadística?

Hay muchas formas de hacer una gráfica estadística, y **no suele pasar** por hacer un gráfico de tartas. Los **diagramas de tartas o sectores** tiene un problema de reversibilidad:

* Si hay **muchas variables**: salvo que conozcas el montante total y tengas un transportador de ángulos a mano, es muy complicado que obtengas información.

* Si hay **pocas variables**: ¿aporta algo distinto (y/o mejor) que una tabla?


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/sectores_sevilla.jpg" alt="Gráfica extraída del manual de Joaquín Sevilla" width="40%" /&gt;
&lt;p class="caption"&gt;Gráfica extraída del manual de Joaquín Sevilla&lt;/p&gt;
&lt;/div&gt;

---

# ¿Qué es una gráfica estadística?

El principal problema de un **diagrama de sectores** es que la posible información está contenido en los **ángulos**, pero nuestra interpretación la realizamos a través de la **comparación de áreas** (nuestros ojos no miden bien ángulos), las cuales dependen no solo del ángulo sino del radio.

Algo similar sucede con los mal llamados **gráficos tridimensionales** (son bidimensionales con perspectiva en realidad): los valores más cercanos aparecen sobredimensionados, siendo prácticamente imposible la reversibilidad.


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/sectores_3D_sevilla.jpg" alt="Gráfica extraída del manual de Joaquín Sevilla" width="70%" /&gt;
&lt;p class="caption"&gt;Gráfica extraída del manual de Joaquín Sevilla&lt;/p&gt;
&lt;/div&gt;

---

# Vizfail

Además, dado que un diagrama de sectores solo permite una **visualización relativa** de los datos, no son comparables con otros diagramas de tartas.

&lt;img src="https://pbs.twimg.com/media/BgDR4urIMAAnHmG?format=jpg&amp;name=medium" width="78%" style="display: block; margin: auto;" /&gt;

Gráfica extraída de &lt;https://twitter.com/Dave_Andrade/status/432576336872624129?t=FGjLtxE8V1BJR_QdXdtZgQ&amp;s=19&gt;

---

# Historia de la estadística: navegación y astronomía

.pull-left[

### T. Brahe

Uno de los primeros usos «modernos» de la estadística fue en la **navegación y la astronomía**, siendo Tycho Brahe de los primeros en utilizar la estadística para **reducir los errores** observacionales.
]

.pull-right[

### E. Wright

Fue el primero en usar en 1599 lo que hoy llamamos **mediana** en su libro «Certaine errors in navigation», aplicada a la navegación.

]

.pull-left[

### G. Galileo

Aunque la fama se la llevó **Gauss**, fue el primero en plantear una idea similar a la que hoy llamamos **método de mínimos cuadrados**: los valores más probables serían aquellos que minimizaran los errores.

]

.pull-right[
### C. F. Gauss y A. M. Legendre

El **método de los mínimos cuadrados**, en el que basan modelos actuales como la regresión, fue desarrollado por **Legendre y Gauss** (el último lo aplicó a la detección más probable del planeta enano Ceres).

]

---

# Historia de la estadística: demografía, epidemiología y fisiología

.pull-left[

#### J. Graunt

Autor de «Natural and Political Observations Made upon the Bills of Mortality» (1662), uno de los primeros trabajos en los que ya se hablaba de **exceso de mortalidad** a partir de las primeras tablas de natalidad y mortalidad, **estimando la población de Londres**.
]

.pull-right[

#### G. Neumann

Las **fakes news** ya existían en el siglo XVII: Gaspar Neumann también un precursor en el **análisis estadístico de tablas de mortalidad**, para desmentir bulos (ejemplo: desmontó la creencia de que en los años acabados en siete morían más personas).
]


Son precisamente las tablas de Graunt las que usó **Christiaan Huygens** (pionero en teoría de probabilidad con su «De ratiociniis in ludo aleae» en 1656) para generar la **primera gráfica de densidad** de una distribución continua, visualizando la **esperanza de vida** (en función de la edad).


---

# Primer gráfico de densidad

Son precisamente las tablas de Graunt las que usó **Christiaan Huygens** (pionero en teoría de probabilidad con su «De ratiociniis in ludo aleae» en 1656) para generar la **primera gráfica de densidad** de una distribución continua, visualizando la **esperanza de vida** (en función de la edad).


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://omeka.lehigh.edu/files/fullsize/65fc32c11a768f1d3263a99caca28dff.jpg" alt="Primera función de densidad, extraída de https://omeka.lehigh.edu/exhibits/show/data_visualization/vital_statistics/huygen" width="50%" /&gt;
&lt;p class="caption"&gt;Primera función de densidad, extraída de https://omeka.lehigh.edu/exhibits/show/data_visualization/vital_statistics/huygen&lt;/p&gt;
&lt;/div&gt;

---

# El gran boom: los gráficos de Playfair

La figura que cambió el dataviz fue, sin lugar a dudas, el economista y político **William Playfair (1759-1823)**. En 1786 publicó el **«Atlas político y comercial»** con 44 gráficas (43 series temporales y el **diagrama de barras más famoso**, aunque no el primero).

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_1.jpg" alt="Gráficas de Playfair, extraídas de Funkhouser y Walker (1935)" width="85%" /&gt;
&lt;p class="caption"&gt;Gráficas de Playfair, extraídas de Funkhouser y Walker (1935)&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_2.jpg" alt="Gráficas de Playfair, extraídas de Funkhouser y Walker (1935)" width="35%" /&gt;
&lt;p class="caption"&gt;Gráficas de Playfair, extraídas de Funkhouser y Walker (1935)&lt;/p&gt;
&lt;/div&gt;

]

[10] [«Atlas político y comercial» de William Playfair (1786)](https://www.amazon.es/Playfairs-Commercial-Political-Statistical-Breviary/dp/0521855543)

[11] [«Playfair and his charts» de H. Gray Funkhouser and  Helen M. Walker (1935)](https://www.jstor.org/stable/45366440)

---

# El gran boom: los gráficos de Playfair

Playfair no solo fue el primero en usar el dataviz para entender (y no solo describir) la realidad: fue el primero en usar **conceptos modernos** como el _grid_ o el color como un elemento no solo estético.

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_3.jpg" alt="Gráficas de Playfair, extraídas de https://friendly.github.io/HistDataVis" width="99%" /&gt;
&lt;p class="caption"&gt;Gráficas de Playfair, extraídas de https://friendly.github.io/HistDataVis&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_4.png" alt="Gráficas de Playfair, extraídas de la wikipedia." width="99%" /&gt;
&lt;p class="caption"&gt;Gráficas de Playfair, extraídas de la wikipedia.&lt;/p&gt;
&lt;/div&gt;

]

[10] [«Atlas político y comercial» de William Playfair (1786)](https://www.amazon.es/Playfairs-Commercial-Political-Statistical-Breviary/dp/0521855543)

---

# Primer gráfico de barras

Playfair es además el **autor del gráfico de barras más famoso** (aunque no fue el primero, pero sí el que sentó un precedente, quien lo hizo _mainstream_).

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_5.jpg" alt="Gráficas de Playfair de importaciones (barras grises) y exportaciones (negras) de Escocia en 1781, extraídas de la wikipedia." width="95%" /&gt;
&lt;p class="caption"&gt;Gráficas de Playfair de importaciones (barras grises) y exportaciones (negras) de Escocia en 1781, extraídas de la wikipedia.&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_6.jpg" alt="Primer diagrama de barras (Philippe Buache y Guillaume de L’Isle), visualizando los niveles del Sena desde 1732 hasta 1766, extraída de https://friendly.github.io/HistDataVis" width="95%" /&gt;
&lt;p class="caption"&gt;Primer diagrama de barras (Philippe Buache y Guillaume de L’Isle), visualizando los niveles del Sena desde 1732 hasta 1766, extraída de https://friendly.github.io/HistDataVis&lt;/p&gt;
&lt;/div&gt;

]

[10] [«Atlas político y comercial» de William Playfair (1786)](https://www.amazon.es/Playfairs-Commercial-Political-Statistical-Breviary/dp/0521855543)

---

# El gran boom: los gráficos de Playfair


Playfair además fue el primero en **combinar gráficos en la misma visualización**

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_7.jpg" alt="Gráfica de Playfair, visualizando 3 series temporales: precios (barras)f a quarter of wheat (the histogram bars), salarios (línea) y time-line con reinados, extraída de https://friendly.github.io/HistDataVis." width="92%" /&gt;
&lt;p class="caption"&gt;Gráfica de Playfair, visualizando 3 series temporales: precios (barras)f a quarter of wheat (the histogram bars), salarios (línea) y time-line con reinados, extraída de https://friendly.github.io/HistDataVis.&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/playfair_8.jpg" alt="Gráfica de Playfair, visualizando un time-line histórico, extraída de https://friendly.github.io/HistDataVis." width="92%" /&gt;
&lt;p class="caption"&gt;Gráfica de Playfair, visualizando un time-line histórico, extraída de https://friendly.github.io/HistDataVis.&lt;/p&gt;
&lt;/div&gt;
]

[12] [«A Letter on Our Agricultural Distresses, Their Causes and Remedies» de William Playfair (1821)](http://onlinebooks.library.upenn.edu/webbin/book/lookupid?key=ha009726110)

[13] [«An Inquiry Into the Permanent Causes of the Decline and Fall of Powerful and Wealthy Nations» de William Playfair (1821)](https://www.amazon.com/Permanent-Powerful-Nations-Prosperity-Prolonged/dp/140691830X)



---

# Gráficos combinados en mapas

**Minard** fue además el primero en 1858 que se atrevió a **incorporar gráficas en mapas**, mostrando la proporción de consumo de carne (ternera, cerdo, cordero) proporcionado por el mercado central de París.

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/minard.png" alt="Mapa con diagramas de sectores de Minard, extraída de https://friendly.github.io/HistDataVis." width="43%" /&gt;
&lt;p class="caption"&gt;Mapa con diagramas de sectores de Minard, extraída de https://friendly.github.io/HistDataVis.&lt;/p&gt;
&lt;/div&gt;


---

# Mapas figurativos de Minard

Minard fue el autor del famoso «Carte figurative des pertes successives en hommes de l'Armée Française dans la campagne de Russie 1812-1813», según Tufte «el mejor gráfico estadístico jamás dibujado», publicado en 1869 sobre la **desastrosa campaña rusa de las tropas de Napoleón en 1812**, mostrando 3 variables en un gráfico bidimensional

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/minard_2.png" alt="Gráfico de Minard sobre el avance de las tropas de Napoleón hacia Rusia, extraída de https://friendly.github.io/HistDataVis." width="73%" /&gt;
&lt;p class="caption"&gt;Gráfico de Minard sobre el avance de las tropas de Napoleón hacia Rusia, extraída de https://friendly.github.io/HistDataVis.&lt;/p&gt;
&lt;/div&gt;


---

# Primera función de distribución

Años antes, en  1821, el **matemático J. B. J. Fourier** publicó  el primer **gráfico de una distribución acumulada** (la población de Paris en 1817 por grupos de edad), aunque nacieron para ser leídas al revés de lo usual actualmente (de derecha a izquierda).

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/fourier_dataviz.jpg" alt="Primera función de distribución acumulada, extraída de Beniger y Robyn (1978)." width="57%" /&gt;
&lt;p class="caption"&gt;Primera función de distribución acumulada, extraída de Beniger y Robyn (1978).&lt;/p&gt;
&lt;/div&gt;

---

# Primer diagrama de dispersión

Según Sevilla &lt;sup&gt;1&lt;/sup&gt;, se considera al astrónomo británico **John Frederick William Herschel** el primero que publicó un **diagrama de dispersión o scatterplot** en 1833, visualizando el movimiento de la estrella doble Virginis (tiempo en el eje horizontal, posición angular en el eje vertical)


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/herschel.jpg" alt="Primer scatterplot, extraído de https://friendly.github.io/HistDataVis." width="36%" /&gt;
&lt;p class="caption"&gt;Primer scatterplot, extraído de https://friendly.github.io/HistDataVis.&lt;/p&gt;
&lt;/div&gt;

[15] [«On the investigation of the orbits of revolving double stars: being a supplement to a paper entitled micrometrical measures of 364 double stars», de John F. W. Herschel (1833)](https://adsabs.harvard.edu/full/1833MmRAS...5..171H)

---

# Primera pirámide poblacional

La **primera pirámide de población** (en realidad es un doble histograma de población, en función de dos variables, edad y sexo), fue publicada por **Francis Amasa Walker**, superintendente del censo de EE.UU., en 1874.

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/walker_piramide.jpg" alt="Primera pirámide de población, extraída de https://www.depauw.edu/learn/dew/wpaper/workingpapers/DePauw2016-02-Barreto-DemographyEconomics.pdf" width="55%" /&gt;
&lt;p class="caption"&gt;Primera pirámide de población, extraída de https://www.depauw.edu/learn/dew/wpaper/workingpapers/DePauw2016-02-Barreto-DemographyEconomics.pdf&lt;/p&gt;
&lt;/div&gt;


---

# Primer gráfico de mosaico

Walker también fue el autor del **primera gráfico de mosaico** en 1874, visualizando la población de Missouri por origen racial, según el censo de 1870

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/walker_mosaico.jpg" alt="Primer gráfico de mosaico, extraído de https://friendly.github.io/HistDataVis." width="75%" /&gt;
&lt;p class="caption"&gt;Primer gráfico de mosaico, extraído de https://friendly.github.io/HistDataVis.&lt;/p&gt;
&lt;/div&gt;

---

# El boom de la estadística: epidemiología y bioestadística

.pull-left[

#### F. Galton

Primo de Charles Darwin, inventor de los **silbatos para perretes**, de los mapas de predicción meteorológica y la persona que acuñó el concepto de **regresión** (y el de eugenesia :/).

&lt;img src="https://www.bogleheads.org/w/images/thumb/9/95/Screen_Shot_2012-01-03_at_7.36.29_AM.png/600px-Screen_Shot_2012-01-03_at_7.36.29_AM.png" width="93%" style="display: block; margin: auto;" /&gt;


]

.pull-right[

&lt;img src="./img/galton_1.jpg" width="58%" style="display: block; margin: auto;" /&gt;

&lt;img src="./img/galton_2.png" width="58%" style="display: block; margin: auto;" /&gt;

]



---

# El boom de la estadística: epidemiología y bioestadística

.pull-left[

#### John Snow

Se le considera uno de los pioneros de la **epidemiología moderna** y la **estadística espacial**: aunque los **diagramas de Voronoi** tardarían años en ser formalizados, John Snow aplicó el mismo concepto para mitigar la **epidemia de cólera en Londres**, con su **mapa con diagrama de barras**, localizando el foco en la conocida fuente de Broad Street.

]

.pull-right[

&lt;img src="https://media.revistagq.com/photos/5cc84a91c46d3a2b7435d7cf/2:3/w_1799,h_2699,c_limit/pelo%20jon%20snow.jpg" width="100%" style="display: block; margin: auto;" /&gt;

]

---


# El boom de la estadística: epidemiología y bioestadística


.pull-left[

#### John Snow

Se le considera uno de los pioneros de la **epidemiología moderna** y la **estadística espacial**: aunque los **diagramas de Voronoi** tardarían años en ser formalizados, John Snow aplicó el mismo concepto para mitigar la **epidemia de cólera en Londres**, con su **mapa con diagrama de barras**, localizando el foco en la conocida fuente de Broad Street.


[📚 «El mapa fantasma», Steven Johnson, sobre la historia de John Snow](https://capitanswing.com/libros/el-mapa-fantasma/)


]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://s1.eestatic.com/2016/04/22/reportajes/reportajes_119248513_3987143_854x640.jpg" alt="John Snow, el epidemiólogo" width="100%" /&gt;
&lt;p class="caption"&gt;John Snow, el epidemiólogo&lt;/p&gt;
&lt;/div&gt;

]

---

# Nacimiento de la estadística espacial

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/snow_mapa.jpg" alt="Mapa de Londres, mostrando los casos de cólera del 19 de agosto al 30 de septiembre de 1854, extraído de https://friendly.github.io/HistDataVis." width="77%" /&gt;
&lt;p class="caption"&gt;Mapa de Londres, mostrando los casos de cólera del 19 de agosto al 30 de septiembre de 1854, extraído de https://friendly.github.io/HistDataVis.&lt;/p&gt;
&lt;/div&gt;

---

# Cólera en Londres

Esa **epidemia de cólera** en Londres fue una catástrofe en términos humanos pero supuso un verdadero auge de la **bioestadística y visualización de datos**. Unos años antes que Snow, **William Farr** ya usaba el dataviz para **monitorizar las muertes diarias** de cólera (abajo, cólera en azul, diarre en amarillo), en función del tiempo meteorológico (arriba)


&lt;img src="./img/farr_colera.png" width="48%" style="display: block; margin: auto;" /&gt;

[16] [«General Register Office, Report on the Mortality of Cholera in England, 1848–49» publicado en 1852](https://wellcomecollection.org/works/pajtrpez/items?canvas=9)


---

# Primer diagrama de área polar

Fue también Farr al que se le atribuye el primer **diagrama de área polar o radial**, cambiando por completo el **paradigma cartesiano** de la época: para visualizar la estacionalidad de la mortalidad en función de la temperatura, Farr decidió visualizarlo con coordenadas polares o esféricas.

&lt;img src="./img/farr_colera_2.png" width="48%" style="display: block; margin: auto;" /&gt;

[16] [«General Register Office, Report on the Mortality of Cholera in England, 1848–49» publicado en 1852](https://wellcomecollection.org/works/pajtrpez/items?canvas=9)


---

# Florence Nigthingale: una revolución

.pull-left[


* El 21 de octubre de 1854 **Florence Nigthingale** fue enviada para mejorar las **condiciones sanitarias** de los **soldados británicos en la guerra de Crimea**. 

* A su regreso se dedicó a demostrar que los **soldados fallecían por las condiciones sanitarias**: eran **muertes evitables**. Nigthingale es la creadora del famoso **diagrama de rosa**, permitiendo pintar tres variables a la vez y su estacionalidad.

* El 8 de febrero de 1955, The Times la describió como la **«ángel guardián» de los hospitales**, y al finalizar la contienda, fue recibida como una heroína, conocida como **«The Lady with the Lamp»** tras un poema de H. W. Longfellow publicado en 1857.

* Años después se convirtió en la **primera mujer en la Royal Statistical Society** y renunció a su puesto para crear las primeras escuelas de enfermería

]

.pull-right[

&lt;img src="https://www.researchgate.net/profile/Miguel-Guevara-4/publication/325622727/figure/fig1/AS:635977265582080@1528640204506/FIGURA-2-La-dama-con-la-lampara-1891-en-ingles-The-lady-with-the-lamp.png" width="90%" style="display: block; margin: auto;" /&gt;

]

---

# Los gráficos en espiral no son novedosos

**Florence Nigthingale** es la creadora del famoso **diagrama de rosa**, permitiendo pintar tres variables a la vez y su estacionalidad: **tiempo** (cada **gajo** es un mes), **nº de muertes** (**área** del gajo) y **causa** de la muerte (**color** del gajo: azules enfermedades infecciosas, rojas por heridas, negras otras causas).


&lt;img src="./img/rosa_nightingale.jpg" width="75%" style="display: block; margin: auto;" /&gt;

---

# La espiral de la polémica

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://www.memo.com.ar/files/image/30/30306/61e162fc784b3_715_896!.jpg?s=8418d87978ab79e1a76da127f6b37bb2&amp;d=1642160894" alt="Gráfica en espiral del New York Times" width="100%" /&gt;
&lt;p class="caption"&gt;Gráfica en espiral del New York Times&lt;/p&gt;
&lt;/div&gt;

]



.pull-right[

**¿A favor? ¿En contra?**

✖️ No es novedosa (la novedad tampoco debería ser un argumento a favor per se)

✔️ Las **coordenadas polares** son un **acierto**: los datos estacionales como los datos epidemiológicos o las temperaturas son precisamente los casos en los que está más justificado representar los datos en coordenadas polares o en espiral.

✖️ **No respeta la reversibilidad**: es más una ilustración que una gráfica estadística. La forma de llevarlo a cabo **infraestima los datos** actuales y, por su **distorsión de la realidad**, no permite **medir** precisamente el patrón estacional que se propone visualizar.

✔️ **Metáfora visual** de la pandemia.

✖️ Opinión personal: buena idea, buena como ilustración, error como gráfica estadística en su ejecución.
]

---

# La espiral de la polémica

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://www.memo.com.ar/files/image/30/30306/61e162fc784b3_715_896!.jpg?s=8418d87978ab79e1a76da127f6b37bb2&amp;d=1642160894" alt="Gráfica en espiral del New York Times" width="60%" /&gt;
&lt;p class="caption"&gt;Gráfica en espiral del New York Times&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://elartedeldato.com/blog/the-new-york-times-spiral-graph-en-r/featured-the_nyt_spiral_hu8f42fa4590b2c04399b29318317fd771_501398_720x0_resize_lanczos_3.png" alt="Mejora de la espiral realizada por Paula Casado https://elartedeldato.com/blog/the-new-york-times-spiral-graph-en-r/" width="100%" /&gt;
&lt;p class="caption"&gt;Mejora de la espiral realizada por Paula Casado https://elartedeldato.com/blog/the-new-york-times-spiral-graph-en-r/&lt;/p&gt;
&lt;/div&gt;

]

✖️ El **eje que recorre la espiral no aporta**, distrae de los datos a representar, **aumenta la distorsión producida** por la no linealidad de la espiral y duplica información, dificultando la comparación estacional.


---

# La espiral de la polémica


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://pbs.twimg.com/media/FIgzfW4XMAsWYMs?format=jpg&amp;name=large" alt="Misma idea, distinta ejecución, de https://twitter.com/abmakulec/status/1479496579040034822" width="90%" /&gt;
&lt;p class="caption"&gt;Misma idea, distinta ejecución, de https://twitter.com/abmakulec/status/1479496579040034822&lt;/p&gt;
&lt;/div&gt;

---

# La espiral de la polémica


.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://pbs.twimg.com/media/FIg4FiIXIAITUq6?format=jpg&amp;name=medium" alt="Mejora de https://twitter.com/abmakulec/status/1479496581439238152" width="100%" /&gt;
&lt;p class="caption"&gt;Mejora de https://twitter.com/abmakulec/status/1479496581439238152&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

✖️ La **inclusión de colores** codificando los datos hubiese mejorado el gráfico, máxime cuando no se añade ningún tipo de escala al gráfico (aunque mida la estacionalidad, para visualizar algo estacional es fundamental que precisamente los periodos puedan ser comparables para percibir ese patrón periódico)

]


El **uso de colores** no es solo algo estético: es una variable más, y la paleta elegida así como su uso es fundamental (por ejemplo, la inclusión de colores nos permite centrarnos en los oscuros, y comparar entre tonalidades).


---

# ¿Líneas rojas?

* Entender el contexto y respetar el dato

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://pbs.twimg.com/media/FIgZcF4X0AAzLnC?format=jpg&amp;name=medium" alt="Infografía extraída de https://twitter.com/storywithdata" width="60%" /&gt;
&lt;p class="caption"&gt;Infografía extraída de https://twitter.com/storywithdata&lt;/p&gt;
&lt;/div&gt;

(en lo de los diagramas de tartas discrepamos :P)

---

# Contexto

Una **buena idea** puede estar mejor o peor ejecutada, y la forma de llevarla a cabo es importante

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/semaforo.jpg" alt="Un semáforo no es una mala idea, la forma de instalarlo sí puede serlo. Imagen extraída del manual de Joaquín Sevilla" width="30%" /&gt;
&lt;p class="caption"&gt;Un semáforo no es una mala idea, la forma de instalarlo sí puede serlo. Imagen extraída del manual de Joaquín Sevilla&lt;/p&gt;
&lt;/div&gt;

---

# Fundamentos de la visualización de datos estadísticos

## **Recomendaciones**

[«The Functional Art: an introduction to information graphics and visualization» de Alberto Cairo](https://www.amazon.es/Functional-Art-Voices-That-Matter/dp/0321834739)


[«Gramática de las gráficas: pistas para mejorar las representaciones de datos» de Joaquín Sevilla](https://academica-e.unavarra.es/bitstream/handle/2454/15785/Gram%C3%A1tica.pdf)


[«A Brief History of Visualization» de Friendly et al. (2008)](https://www.researchgate.net/publication/226400313_A_Brief_History_of_Data_Visualization)

[«Quantitative Graphics in Statistics: A Brief History» de James R. Beniger y Dorothy L. Robyn. The American Statistician (1978)](https://www.jstor.org/stable/2683467)]

[«Presentation Graphics» de Leland Wilkinson. International Encyclopedia of the Social &amp; Behavioral Sciences](https://www.cs.uic.edu/~wilkinson/Publications/iesbs.pdf)

[«The Grammar of Graphics» de Leland Wilkinson](https://www.amazon.es/Grammar-Graphics-Statistics-Computing/dp/0387245448)


[«The Minard System: The Graphical Works of Charles-Joseph Minard» de Sandra Rendgen](https://www.amazon.es/gp/product/1616896337/ref=sw_img_1?smid=A1AT7YVPFBWXBL&amp;psc=1)


[«The Visual Display of Quantitative Information» de E. W. Tufte](https://www.amazon.es/Visual-Display-Quantitative-Information/dp/0961392142)

---

name: intro-ggplot2
class: center, middle

# Dataviz e introducción a ggplot2

## **La gramática de los gráficos**

&amp;nbsp;

El paquete `{ggplot2}` se basa en la idea propuesta en «Grammar of graphics» del recién fallecido Wilkinson.

---

## ggplot2: grammar of graphics (gg)

.pull-left[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://dadosdelaplace.github.io/courses-ECI-2022/img/telling-dataviz" alt="Imagen extraída de Reddit" width="70%" /&gt;
&lt;p class="caption"&gt;Imagen extraída de Reddit&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

Una de las **principales fortalezas** de `R` no solo es el manejo de datos con `{tidyverse}`, también la visualización con uno de sus paquetes: el paquete `{ggplot2}`.

La **visualización de datos** debería ser una parte fundamental de todo análisis de datos. No es solo una cuestión estética. La visualización de datos es fundamental para convertir el dato en información.

]


---

## ggplot2: grammar of graphics (gg)

.pull-left[

La idea de la filosofía detrás de `{ggplot2}` es entender los **gráficos como parte integrada del flujo de datos**, dotándoles de una **gramática**, basándose en la idea de 
[«The Grammar of Graphics» de Leland Wilkinson](https://www.amazon.es/Grammar-Graphics-Statistics-Computing/dp/0387245448).

El objetivo es empezar con un lienzo en blanco e ir **añadiendo capas a tu gráfico**, como harías por ejemplo en Photoshop, con la diferencia de que nuestras capas podemos **ligarlas al conjunto de datos**.

La ventaja de `{ggplot2}` es poder **mapear atributos estéticos** (color, forma, tamaño) de **objetos geométricos** (puntos, barras, líneas) en **función de los datos**, añadiendo transformaciones de los datos, resúmenes estadísticos y transformaciones de las coordenadas.


La **documentación** del paquete puedes consultarla en &lt;https://ggplot2-book.org/introduction.html&gt; 
]

.pull-right[

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://dadosdelaplace.github.io/courses-ECI-2022/img/grammar.jpg" alt="Idea detrás de la «Grammar of graphics» de Wilkinson" width="100%" /&gt;
&lt;p class="caption"&gt;Idea detrás de la «Grammar of graphics» de Wilkinson&lt;/p&gt;
&lt;/div&gt;
]


---

## ggplot2: grammar of graphics (gg)

.pull-left[


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://dadosdelaplace.github.io/courses-ECI-2022/img/grammar.jpg" alt="Idea detrás de la «Grammar of graphics» de Wilkinson" width="100%" /&gt;
&lt;p class="caption"&gt;Idea detrás de la «Grammar of graphics» de Wilkinson&lt;/p&gt;
&lt;/div&gt;

]

.pull-right[

Un gráfico se podrá componer de las siguientes **capas**

* **Datos**
* **Mapeado de elementos estéticos (aesthetics)**: ejes, color, forma, tamaño, etc (en función de los datos)
* **Elementos geométricos (geom)**: puntos, líneas, barras, polígonos, etc.
* **Componer gráficas (facet)**: visualizar varias gráficas a la vez.
* **Transformaciones estadísticas (stat)**: ordenar, resumir, agrupar, etc.
* **Sistema de coordenadas (coord)**: coordenadas, grids, etc.
* **Temas (theme)**: fuente, tamaño de letra, subtítulos, captions, leyenda, ejes, etc.

]

---

# Primer intento: scatter plot

Veamos un **primer intento** para entender la filosofía. Imagina que queremos dibujar un **scatter plot** o **diagrama de (dispersión) de puntos**.

&amp;nbsp;

Para ello vamos a usar el **conjunto de datos** `gapminder`, del paquete homónimo: un fichero con **datos de esperanzas de vida, poblaciones y renta per cápita** de distintos países en distintos momentos temporales.


```r
library(gapminder)
gapminder
```

```
&gt; # A tibble: 1,704 x 6
&gt;    country     continent  year lifeExp      pop gdpPercap
&gt;    &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
&gt;  1 Afghanistan Asia       1952    28.8  8425333      779.
&gt;  2 Afghanistan Asia       1957    30.3  9240934      821.
&gt;  3 Afghanistan Asia       1962    32.0 10267083      853.
&gt;  4 Afghanistan Asia       1967    34.0 11537966      836.
&gt;  5 Afghanistan Asia       1972    36.1 13079460      740.
&gt;  6 Afghanistan Asia       1977    38.4 14880372      786.
&gt;  7 Afghanistan Asia       1982    39.9 12881816      978.
&gt;  8 Afghanistan Asia       1987    40.8 13867957      852.
&gt;  9 Afghanistan Asia       1992    41.7 16317921      649.
&gt; 10 Afghanistan Asia       1997    41.8 22227415      635.
&gt; # ... with 1,694 more rows
```

---

# Primer intento: scatter plot

El fichero consta de 1704 registros y 6 variables: `country`, `continent`, `year`, `lifeExp` (esperanza de vida), `pop` (población)  y `gdpPercap` (renta per cápita).


```r
glimpse(gapminder)
```

```
&gt; Rows: 1,704
&gt; Columns: 6
&gt; $ country   &lt;fct&gt; "Afghanistan", "Afghanistan", "Afghanistan", "Afghanistan", ~
&gt; $ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, ~
&gt; $ year      &lt;int&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, ~
&gt; $ lifeExp   &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8~
&gt; $ pop       &lt;int&gt; 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12~
&gt; $ gdpPercap &lt;dbl&gt; 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, ~
```

Para empezar con algo sencillo **filtraremos solo los datos de 1997**

--


```r
gapminder_1997 &lt;- gapminder %&gt;% filter(year == 1997)
gapminder_1997
```

```
&gt; # A tibble: 142 x 6
&gt;    country     continent  year lifeExp       pop gdpPercap
&gt;    &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;
&gt;  1 Afghanistan Asia       1997    41.8  22227415      635.
&gt;  2 Albania     Europe     1997    73.0   3428038     3193.
&gt;  3 Algeria     Africa     1997    69.2  29072015     4797.
&gt;  4 Angola      Africa     1997    41.0   9875024     2277.
&gt;  5 Argentina   Americas   1997    73.3  36203463    10967.
&gt;  6 Australia   Oceania    1997    78.8  18565243    26998.
&gt;  7 Austria     Europe     1997    77.5   8069876    29096.
&gt;  8 Bahrain     Asia       1997    73.9    598561    20292.
&gt;  9 Bangladesh  Asia       1997    59.4 123315288      973.
&gt; 10 Belgium     Europe     1997    77.5  10199787    27561.
&gt; # ... with 132 more rows
```

---

# Primer intento: scatter plot

.pull-left[

Vamos a realizar un **diagrama de puntos**:

* **Eje X**: renta per cápita (variable `gdpPercap`)
* **Eje Y**: población (variable `pop`)

**¿Qué necesitamos?**

* **Datos**: el conjunto filtrado `gapminder_1997`.
* **Mapeado**: indicarle dentro de `aes()` (aesthetics) las variables a pintar en cada coordenada. Todo lo que esté **dentro de aes() dependerá de los datos** (en este caso `aes(x = gdpPercap, y = pop)`).



```r
*ggplot(gapminder_1997, aes(x = gdpPercap, y = pop))
```

* **Elegir una geometría**: optaremos por **puntos** con `geom_point()`.


```r
ggplot(gapminder_1997,
       aes(x = gdpPercap, y = pop)) +
  geom_point() #&lt;&lt; Geometría
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-338-1.png" width="100%" /&gt;
]

---


# Primer intento: scatter plot

.pull-left[

Vamos a profundizar en ese mapeado, cambiando el rol de los ejes:

* **Eje X**: población (variable `pop`)
* **Eje Y**: renta per cápita (variable `gdpPercap`)



```r
ggplot(gapminder_1997,
*      aes(y = gdpPercap, x = pop)) +
  geom_point() 
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-340-1.png" width="100%" /&gt;
]

---


# Primer intento: scatter plot

.pull-left[

La idea podemos repetirla enfrentando ahora la **esperanza de vida** frente a **la renta per cápita**.

* **Eje X**: esperanza de vida (variable `lifeExp`)
* **Eje Y**: renta per cápita (variable `gdpPercap`)



```r
ggplot(gapminder_1997,
*      aes(y = gdpPercap, x = lifeExp)) +
  geom_point()
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-342-1.png" width="100%" /&gt;
]

---

# Colores, tamaños y formas (constantes)

.pull-left[

Para **cambiar el color de los puntos**, indicaremos dentro de `geom_point()` el color de la geometría con `color = ...` (en este caso, el color del punto). Empezaremos por un **color fijo**, por ejemplo `"red"` (existen otros como `"blue"`, `"black"`, `"yellow"`, etc)


```r
# Color con palabra reservada
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
* geom_point(color = "red")
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-344-1.png" width="100%" /&gt;

]

---

# Colores, tamaños y formas (constantes)

.pull-left[

Los colores también podemos asignárselos por su **código hexadecimal**, consultando en la página &lt;https://htmlcolorcodes.com/es/&gt;, eligiendo el color que queramos. El código hexadecimal siempre comenzará con `#`



```r
# Color en hexadecimal
# https://htmlcolorcodes.com/es/
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
* geom_point(color = "#2EA2D8")
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-346-1.png" width="100%" /&gt;

]


---

# Colores, tamaños y formas (constantes)

.pull-left[
  
De la misma manera podemos **indicarle el tamaño de la geometría** (en este caso el **tamaño de los punto**) con `size = ...` (cuanto mayor sea el número, mayor será el tamaño de la geometría).


```r
# Color y tamaño
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
* geom_point(color = "#A02B85", size = 5)
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-348-1.png" width="100%" /&gt;

]
  
  

---

# Colores, tamaños y formas (constantes)

.pull-left[
  
También podemos jugar con la **transparencia del color** con `alpha = ...`: si `alpha = 1`, el color será totalmente opaco (por defecto); si `alpha = 0` será totalmente transparente.



```r
# Color, tamaño y transparencia
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(color = "#A02B85", size = 9,
*            alpha = 0.4)
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-350-1.png" width="100%" /&gt;

]
  
  
---

# Mapear aesthetics

.pull-left[
  
Hasta ahora los **parámetros estéticos** se los hemos pasado fijos y **constantes**. Pero la verdadera potencia y versatilidad de `ggplot` es entender todos esos parámetros como entendemos el mapeado coordenadas: podemos **mapear los atributos estéticos** en `aes()` para que dependan de variables de los datos

&amp;nbsp;

Por ejemplo, vamos a **asignar un color a cada dato en función de su continente**.


```r
# Tamaño fijo
# Color por continentes
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
*          color = continent)) +
  geom_point(size = 5)
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-352-1.png" width="100%" /&gt;

]
  
  
---


# Mapear aesthetics

.pull-left[
  
Podemos combinarlo con lo que hemos hecho anteriormente:


* **color** en función del **continente**.
* **tamaño** en función de la **población**
* **transparencia** fija del 70%


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
*          color = continent, size = pop)) +
  geom_point(alpha = 0.7)
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-354-1.png" width="100%" /&gt;

]
  
  
---

# Mapear aesthetics

.pull-left[
  
En lugar de jugar con el color, también podríamos añadir las variables en función de la **forma de la geometría** (en este caso la forma de los «puntos») con `shape = ...`.


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           shape = continent, size = pop)) +
  geom_point(alpha = 0.7)
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-356-1.png" width="100%" /&gt;

]
  

---

# Gráfico multidimensional en 2D

.pull-left[
  
Reflexionemos sobre el gráfico anterior:

* **color** en función del **continente**.
* **tamaño** en función de la **población**
* **transparencia** fija del 70%

Usando los datos hemos conseguido **dibujar en un gráfico bidimensional 4 variables** (`lifeExp` y `gdpPercap` en los ejes `\((X, Y)\)`), `continent` como color y `pop` como tamaño de la geometría) con muy pocas líneas de código.


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7)
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-358-1.png" width="100%" /&gt;

]
  
---

# Escala de los ejes

.pull-left[
  
A veces nos puede ser más conveniente **representar alguna de las variables** en otras escalas, por ejemplo en **escala logarítmica** (importante indicarlo en el gráfico), lo que podemos hacer facilmente con `scale_x_log10()` y/o `scale_y_log10()`.



```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  # Eje Y con escala logarítmica
* scale_y_log10()
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-360-1.png" width="100%" /&gt;

]

---

# Paletas de colores

.pull-left[

Si no indicamos nada, `R` selecciona automáticamente una **paleta de colores**, pero podemos indicarle alguna paleta concreta de varias maneras.

&amp;nbsp;

La primera y más inmediata es indicarle los **colores manualmente**: con `scale_color_manual` le podemos indicar un **vector de colores**.


```r
pal &lt;- c("#A02B85", "#2DE86B", "#4FB2CA",
         "#E8DA2D", "#E84C2D")
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.7) +
  scale_y_log10() +
  # Escala manual de colores
* scale_color_manual(values = pal)
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-362-1.png" width="100%" /&gt;

]

---

# Paletas de colores

.pull-left[

Otra opción es elegir alguna de las **paletas de colores disponibles** en el paquete `{ggthemes}`:

* `scale_color_economist()`: paleta de colores basada en los colores de The Economist.


```r
library(ggthemes)

# scale_color_economist()
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_economist()
```
  
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-364-1.png" width="100%" /&gt;

]

---

# Paletas de colores

.pull-left[

Otra opción es elegir alguna de las **paletas de colores disponibles** en el paquete `{ggthemes}`:

* `scale_color_excel()`: paleta de colores basada en los colores del Excel.


```r
library(ggthemes)
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_excel()
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-366-1.png" width="100%" /&gt;

]

---

# Paletas de colores

.pull-left[

Otra opción es elegir alguna de las **paletas de colores disponibles** en el paquete `{ggthemes}`:

* `scale_color_tableau()`: paleta de colores basada en los colores de Tableau.


```r
library(ggthemes)
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau()
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-368-1.png" width="100%" /&gt;

]

---

# Paletas de colores

.pull-left[

También existen **múltiples paquetes** que nos proporcionan **paletas de colores** basados en:

* **películas**: paquete `{harrypotter}` (repositorio de Github `aljrico/harrypotter`) usando `scale_color_hp_d()`.


```r
library(devtools)

install_github(repo = "https://github.com/aljrico/harrypotter")
library(harrypotter)

ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.9) +
  scale_y_log10() +
  scale_color_hp_d(option = "ravenclaw")
```

]

.pull-right[


&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://raw.githubusercontent.com/aljrico/harrypotter/master/readme_raw_files/palettes/ravenclaw.png" alt="Paleta basada en la casa Ravenclaw" width="21%" /&gt;
&lt;p class="caption"&gt;Paleta basada en la casa Ravenclaw&lt;/p&gt;
&lt;/div&gt;

&lt;img src="index_files/figure-html/unnamed-chunk-371-1.png" width="100%" /&gt;

]

---

# Paletas de colores

.pull-left[

También existen **múltiples paquetes** que nos proporcionan **paletas de colores** basados en:


* **cuadros**(paquete `{MetBrewer}` descargado desde el repositorio de Github `BlakeRMills/MetBrewer`).


```r
devtools::install_github("BlakeRMills/MetBrewer") 
library(MetBrewer)
MetBrewer::met.brewer("Renoir")
```

&lt;img src="index_files/figure-html/unnamed-chunk-373-1.png" width="60%" /&gt;


]


.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-374-1.png" width="100%" /&gt;

]

---

# Paletas de colores

.pull-left[

También existen **múltiples paquetes** que nos proporcionan **paletas de colores** basados en:


* **cuadros**(paquete `{MetBrewer}` descargado desde el repositorio de Github `BlakeRMills/MetBrewer`).


```r
devtools::install_github("BlakeRMills/MetBrewer") 
library(MetBrewer)
MetBrewer::met.brewer("Klimt")
```

&lt;img src="index_files/figure-html/unnamed-chunk-376-1.png" width="60%" /&gt;

]


.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-377-1.png" width="100%" /&gt;

]

---


# Geometrías (geom)

.pull-left[

Hemos jugado un poco con las formas, tamaños y colores, pero siempre ha sido un diagrama de dispersión con puntos. Al igual que hemos usado `geom_point()`, podríamos usar otras geometrías como **líneas** con `geom_line()`.


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
* geom_line(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau()
```
  
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-379-1.png" width="100%" /&gt;
]

---

# Geometrías (geom)

.pull-left[

Asignado los colores a la variable `continent`, automáticamente obtenemos cada curva separada por continente.


```r
# Separando por continente
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent)) +
  geom_line(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau()
```
  
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-381-1.png" width="100%" /&gt;
]

---

# Geometrías (geom)

.pull-left[

La **filosofía es siempre la misma**: dado que cada elemento lo podemos tratar de forma individual, pasar de un gráfico a otro es relativamente sencillo, sin más que cambiar `geom_point()` por `geom_line()`.

De la misma manera podemos dibujar un diagrama de dispersión con **formas hexagonales** con `geom_hex()`. Dado que ahora nuestra geometría **tiene volumen** tendremos dos parámetros: `color` para el contorno y `fill` para el **relleno**  (fíjate que también cambiamos `scale_color_tableau()` por `scale_fill_tableau()`)


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           fill = continent, size = pop)) +
* geom_hex(alpha = 0.8) +
  scale_y_log10() +
* scale_fill_tableau()
```
  
]

.pull-right[


&lt;img src="index_files/figure-html/unnamed-chunk-383-1.png" width="100%" /&gt;

]

---

# Geometrías (geom)

.pull-left[

Tenemos varias funciones de este tipo, como `geom_tile()`, que nos visualiza los datos con «mosaicos» (como baldosas), o `geom_text()`, con la podemos hacer que en lugar de una forma geométrica aparezcan **textos que tengamos en alguna variable**, que la pasaremos en `aes()` por el **parámetro label** (en este caso, la variable de la que tomará los nombres será `country`).



```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop, label = country)) +
* geom_text(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau()
```
  
]

.pull-right[


&lt;img src="index_files/figure-html/unnamed-chunk-385-1.png" width="100%" /&gt;

]

---

# Componer (facet)

.pull-left[

Hasta ahora hemos pintado una sola gráfica, **codificando información en colores y formas**. Pero también podemos **dividir/desagregar los gráficos (facetar) por variables**, pintando por ejemplo un **gráfico por continente**, mostrando todos los gráficos a la vez pero por separado, con `facet_wrap()`.


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(alpha = 0.9) +
  scale_y_log10() +
* facet_wrap(~ continent)
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-387-1.png" width="100%" /&gt;

]

---

# Componer (facet)

.pull-left[

También le podemos pasar **argumentos opcionales** para indicarle el **número de columnas o de filas** que queremos.


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(alpha = 0.9) +
  scale_y_log10() +
* facet_wrap(~ continent, nrow = 3)
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-389-1.png" width="100%" /&gt;

]

---

# Componer (facet)

.pull-left[

De esta manera podríamos incluso **visualizar el fichero de datos originales incluye hasta 5 variables** en un gráfico bidimensional:

* las variables `pop` y `lifeExp` en los **ejes**.
* la variable `gdpPercap` en el **tamaño**.
* la variable `continent` en el **color**.
* la variable `year` en la composición de `facet_wrap()`.


```r
library(MetBrewer)
ggplot(gapminder %&gt;% filter(year &gt; 1962),
       aes(y = lifeExp, x = pop,
           size = gdpPercap, color = continent)) +
  geom_point(alpha = 0.6) +
  scale_x_log10() +
  scale_colour_manual(values =
                        met.brewer("Klimt")) +
  facet_wrap(~ year)
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-391-1.png" width="100%" /&gt;

]

---

# Componer (facet)

.pull-left[

Con `facet_grid()` podemos incluso **organizar una cuadrícula en base a dos variables**, por ejemplo que haya una **fila por año** (vamos a usar la tabla original en los **años 1952, 1972, 1982 y 2002**) y una **columna por continente**.


```r
ggplot(gapminder %&gt;%
         filter(year %in% c(1952,  1972, 1982,  2002)),
       aes(y = gdpPercap, x = lifeExp)) +
  geom_point(alpha = 0.9) +
  scale_y_log10() +
  facet_grid(year ~ continent)
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-393-1.png" width="100%" /&gt;

]

---

# Coordenadas y tema

.pull-left[

Los gráficos pueden además **personalizarse añadiendo**, por ejemplo, *títulos y subtítulos** de la gráfica con `labs()`, asignando textos a `title, subtitle y caption`.


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
  labs(title = "EJEMPLO DE SCATTERPLOT CON GGPLOT2",
       subtitle =
         "Esperanza vida vs renta per cápita (1997)",
       caption = "J. Perez Liébana | Datos: gapminder")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-395-1.png" width="100%" /&gt;

]

---

# Coordenadas y tema

.pull-left[

También podemos **personalizar algunos aspectos extras**, como el **título que vamos a dar a los ejes** o el **título de las leyendas**.


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  # Eje Y con escala logarítmica
  scale_y_log10() +
  scale_color_tableau() +
* labs(x = "Esperanza de vida",
*      y = "Renta per cápita",
*      color = "Continente",
*      size = "Población",
       title = "EJEMPLO DE SCATTERPLOT CON GGPLOT2",
       subtitle =
         "Esperanza vida vs renta per cápita (1997)",
       caption = "J. Perez Liébana | Datos: gapminder")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-397-1.png" width="100%" /&gt;

]

---

# Coordenadas y tema

.pull-left[

También podemos **ocultar algún nombre de las leyendas** (o ambos) si ya es explícito de lo que se está hablando. Por ejemplo, vamos a indicarle que no queremos el nombre de la leyenda en continentes, haciendo `color = NULL` (la variable que codifica los continentes a `NULL`).


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
  labs(x = "Esperanza de vida",
       y = "Renta per cápita",
*      color = NULL,
       size = "Población",
       title = "EJEMPLO DE SCATTERPLOT CON GGPLOT2",
       subtitle =
         "Esperanza vida vs renta per cápita (1997)",
       caption = "J. Perez Liébana | Datos: gapminder")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-399-1.png" width="100%" /&gt;

]

---

# Coordenadas y tema

.pull-left[

Incluso podemos **ocultar la leyenda en sí de alguna de alguna de las variables** con `guides(size = "none")` (en este caso, `size = "none"` nos elimina la leyenda que codifica el tamaño de los puntos).


```r
ggplot(gapminder_1997,
       aes(y = gdpPercap, x = lifeExp,
           color = continent, size = pop)) +
  geom_point(alpha = 0.8) +
  scale_y_log10() +
  scale_color_tableau() +
* guides(size = "none") +
  labs(x = "Esperanza de vida",
       y = "Renta per cápita",
       color = NULL, size = "Población",
       title = "EJEMPLO DE SCATTERPLOT CON GGPLOT2",
       subtitle =
         "Esperanza vida vs renta per cápita (1997)",
       caption = "J. Perez Liébana | Datos: gapminder")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-401-1.png" width="100%" /&gt;
]

---

# Ejercicio

.panelset[
.panel[.panel-name[Ejercicios]

* 📝 **Ejercicio 1**: del conjunto `starwars` filtra solo los registros que no tenga ausente las columnas `mass, height, eye_color`. Dibuja un diagrama de puntos enfrentando `x = height` en el eje X e `y = mass` en el eje Y.
 
* 📝 **Ejercicio 2**: modifica el código  anterior para asignar el tamaño en función de `mass`.

* 📝 **Ejercicio 3**: modifica el código del gráfico anterior para asignar el color en función de su color de ojos guardado en `eye_color`. Antes procesa la variable para quedarte con colores reales: si hay dos colores, quédate con el primero; el color `"hazel"` pásalo a `"brown"`; los colores `"unknown"` pásalo a gris.

* 📝 **Ejercicio 4**: repite el gráfico anterior localizando ese dato con un peso extremadamente elevado (outlier), elimínalo y vuelve a repetir la visualización.

* 📝 **Ejercicio 5**: repite el gráfico anterior eliminando la leyenda del tamaño del punto y cambia el título de la leyenda del color de ojos a castellano. Añade además transparencia alpha = 0.6 a los puntos.

* 📝 **Ejercicio 6**: repite el gráfico modificando títulos de ejes (a castellano) con título, subtítulo y caption.
 
* 📝 **Ejercicio 7**: explicita los cortes en los ejes con `scale_x_continuous()` y `scale_y_continuous()`: el eje X de 60 a 240 (de 30 en 30 cada marca), el eje Y de 20 a 160 (de 20 en 2).
 
]

.panel[.panel-name[Sol. 1]

.pull-left[


```r
# Eliminamos NA
starwars_filtro &lt;-
  starwars %&gt;%
  drop_na(c(mass, height, eye_color))

# Visualizamos
ggplot(starwars_filtro,
       aes(x = height, y = mass)) +
  geom_point()
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-403-1.png" width="100%" /&gt;

]

]

.panel[.panel-name[Sol. 2]

.pull-left[


```r
ggplot(starwars_filtro,
       aes(x = height, y = mass, size = mass)) +
  geom_point()
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-405-1.png" width="100%" /&gt;

]

]

.panel[.panel-name[Sol. 3a]


```r
# Transformar colores
starwars_filtro &lt;-
   starwars_filtro %&gt;%
    mutate(eye_color =
             case_when(eye_color == "blue-gray" ~ "blue",
                       eye_color == "hazel" ~ "brown",
                       eye_color == "unknown" ~ "gray",
                       eye_color == "green, yellow" ~ "green",
                       TRUE ~ eye_color))
```

]

.panel[.panel-name[Sol. 3b]

.pull-left[


```r
# Visualizamos
ggplot(starwars_filtro,
       aes(x = height, y = mass,
           size = mass, color = eye_color)) +
  geom_point() +
  scale_color_manual(values =
                       c("black", "blue",
                         "brown", "gray",
                         "green", "orange",
                         "red", "white",
                         "yellow"))
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-408-1.png" width="100%" /&gt;

]

]

.panel[.panel-name[Sol. 4a]


```r
# Localizamos el valor y su nombre
starwars_filtro %&gt;% slice_max(mass, n = 5) %&gt;% pull(name)
```

```
&gt; [1] "Jabba Desilijic Tiure" "Grievous"              "IG-88"                
&gt; [4] "Darth Vader"           "Tarfful"
```

```r
# Filtramos
starwars_filtro &lt;- starwars_filtro %&gt;%
  filter(name != "Jabba Desilijic Tiure")
```

]

.panel[.panel-name[Sol. 4b]

.pull-left[


```r
ggplot(starwars_filtro,
       aes(x = height, y = mass,
           size = mass, color = eye_color)) +
  geom_point() +
  scale_color_manual(values =
                       c("black", "blue",
                         "brown", "gray",
                         "green", "orange",
                         "red", "white",
                         "yellow"))
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-411-1.png" width="100%" /&gt;

]

]

.panel[.panel-name[Sol. 5]

.pull-left[


```r
ggplot(starwars_filtro,
       aes(x = height, y = mass,
           size = mass, color = eye_color)) +
  geom_point(alpha = 0.6) +
  guides(size = "none") +
  scale_color_manual(values =
                       c("black", "blue",
                         "brown", "gray",
                         "green", "orange",
                         "red", "white",
                         "yellow")) +
  labs(color = "color de ojos")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-413-1.png" width="100%" /&gt;

]
]

.panel[.panel-name[Sol. 6]

.pull-left[


```r
ggplot(starwars_filtro,
       aes(x = height, y = mass,
           size = mass, color = eye_color)) +
  geom_point(alpha = 0.6) +
  guides(size = "none") +
  scale_color_manual(values =
                       c("black", "blue",
                         "brown", "gray",
                         "green", "orange",
                         "red", "white",
                         "yellow")) +
  labs(color = "color de ojos",
       x = "altura (cm)",
       y = "peso (kg)",
       title = "STARWARS",
       subtitle = "Diagrama de puntos altura vs peso",
       caption = "J. Perez Liébana | Datos: starwars")
```

]

.pull-left[

&lt;img src="index_files/figure-html/unnamed-chunk-415-1.png" width="100%" /&gt;

]

]

.panel[.panel-name[Sol. 7]

.pull-left[


```r
ggplot(starwars_filtro,
       aes(x = height, y = mass,
           size = mass, color = eye_color)) +
    geom_point(alpha = 0.6) +
    guides(size = "none") +
    scale_color_manual(values =
                           c("black", "blue",
                             "brown", "gray",
                             "green", "orange",
                             "red", "white",
                             "yellow")) +
  scale_y_continuous(breaks =
                       seq(20, 160, by = 20)) +
  scale_x_continuous(breaks =
                       seq(60, 240, by = 30)) +
  labs(color = "color de ojos",
       x = "altura (cm)",
       y = "peso (kg)",
       title = "STARWARS",
       subtitle = "Diagrama de puntos altura vs peso",
       caption = "J. Perez Liébana | Datos: starwars")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-417-1.png" width="100%" /&gt;

]

]

]

---


name: stats
class: center, middle


# Segundo intento: diagrama de barras

Vamos a visualizar en un **diagrama de barras** la **variable cualitativa** `species`, calculando primero el número de personajes de cada especie con `count()`  (filtrando primero los ausentes).


```r
starwars %&gt;%
  filter(!is.na(species)) %&gt;%
  count(species)
```

```
&gt; # A tibble: 37 x 2
&gt;    species       n
&gt;    &lt;chr&gt;     &lt;int&gt;
&gt;  1 Aleena        1
&gt;  2 Besalisk      1
&gt;  3 Cerean        1
&gt;  4 Chagrian      1
&gt;  5 Clawdite      1
&gt;  6 Droid         6
&gt;  7 Dug           1
&gt;  8 Ewok          1
&gt;  9 Geonosian     1
&gt; 10 Gungan        3
&gt; # ... with 27 more rows
```
  
---

# Diagrama de barras

.pull-left[

Para visualizar un **diagrama de barras** usaremos `geom_col()` en lugar de `geom_point()`, con `y = species` y `x = n` (las frecuencias)


```r
ggplot(starwars %&gt;%
         filter(!is.na(species)) %&gt;%
         count(species),
       aes(y = species, x = n)) +
* geom_col()
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-420-1.png" width="100%" /&gt;

]

---

# Diagrama de barras

.pull-left[

Podemos usar las **frecuencias** `\(n\)` también para codificar el color de las barras, añadiendo un **degradado de colores continuo**.


```r
ggplot(starwars %&gt;%
         filter(!is.na(species)) %&gt;%
         count(species),
       aes(y = species, x = n,
           fill = n)) +
  geom_col() +
* scale_fill_continuous_tableau() +
  labs(fill = "Frecuencia absoluta",
       x = "Número de personajes",
       y = "Especies")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-422-1.png" width="100%" /&gt;

]

---

# Factores

Al tener **muchas categorías** en `species` con muy pocos elementos, tenemos un **gráfico poco claro**, así que vamos a preprocesar antes la variable. En `R` las **variables cualitativas** se conoce como **factores**, y las posibles modalidades como **niveles**.

El paquete `{forcats}` de `{tidyverse}` contienen multitud de herramientas para su manejo. Veamos un **ejemplo sencillo** definiendo una variable estado que tome los valores `"sano"`, `"leve"` y `"grave"`:


```r
estado &lt;-
  c("grave", "leve", "sano", "sano", "sano", "grave",
    "grave", "leve", "grave", "sano", "sano")
estado
```

```
&gt;  [1] "grave" "leve"  "sano"  "sano"  "sano"  "grave" "grave" "leve"  "grave"
&gt; [10] "sano"  "sano"
```

La variable `estado` actualmente es de tipo `character`.


```r
class(estado)
```

```
&gt; [1] "character"
```

---

# Factores

**¿Cómo indicarle que es  cualitativa (factor?)** Haciendo uso de la función `as_factor` en `{forcats}`.


```r
library(tidyverse)
estado_fct &lt;- as_factor(estado)
estado_fct
```

```
&gt;  [1] grave leve  sano  sano  sano  grave grave leve  grave sano  sano 
&gt; Levels: grave leve sano
```

```r
class(estado_fct)
```

```
&gt; [1] "factor"
```

No solo ha cambiado la clase de la variable sino que ahora, debajo del valor guardado, nos aparece la frase `Levels: grave leve sano`: son las **modalidades o niveles de nuestra cualitativa**.

Imagina que ese día en el hospital no tuviésemos a nadie en estado grave: aunque ese día nuestra variable no tome dicho valor, el estado grave es un nivel permitido, así que aunque lo eliminemos, el nivel permanece.


```r
estado_fct[estado_fct %in% c("sano", "leve")]
```

```
&gt; [1] leve sano sano sano leve sano sano
&gt; Levels: grave leve sano
```

--- 

# Factores

Si queremos indicarle que **elimine un nivel no usado** en ese momento podemos hacerlo con `fct_drop()`


```r
fct_drop(estado_fct[estado_fct %in% c("sano", "leve")])
```

```
&gt; [1] leve sano sano sano leve sano sano
&gt; Levels: leve sano
```

Al igual que podemos eliminar niveles podemos **ampliar los niveles** existentes (aunque no existan datos de ese nivel en ese momento) con `fct_expand()`


```r
fct_expand(estado_fct, c("UCI", "fallecido"))
```

```
&gt;  [1] grave leve  sano  sano  sano  grave grave leve  grave sano  sano 
&gt; Levels: grave leve sano UCI fallecido
```

Para variables de tipo factor podemos contar los elementos de cada nivel de una manera sencilla con `fct_count()` (similar al `count()`).


```r
fct_count(estado_fct)
```

```
&gt; # A tibble: 3 x 2
&gt;   f         n
&gt;   &lt;fct&gt; &lt;int&gt;
&gt; 1 grave     4
&gt; 2 leve      2
&gt; 3 sano      5
```

---

# Factores

Si te fijas el **orden de los niveles** es por **orden de aparición** en la variable, pero podemos **ordenarlos por frecuencia** con `fct_infreq()`


```r
fct_infreq(estado_fct)
```

```
&gt;  [1] grave leve  sano  sano  sano  grave grave leve  grave sano  sano 
&gt; Levels: sano grave leve
```

A veces queremos **agrupar niveles**, por ejemplo, **no permitiendo niveles que no sucedan un mínimo de veces**. Con `fct_lump_min(estado_fct, min = 5)` le indicaremos que para que **exista el nivel debe de suceder al menos 3 veces** (las observaciones que no lo cumplan irán al nivel indicado en `other_level`; podemos hacer algo equivalente en función de su frecuencia relativa con `fct_lump_prop()`).


```r
fct_lump_min(estado_fct, min = 5, other_level = "otros")
```

```
&gt;  [1] otros otros sano  sano  sano  otros otros otros otros sano  sano 
&gt; Levels: sano otros
```

---

# Diagrama de barras

.pull-left[

Vamos a repetir el diagrama de barras anterior pero indicándole que nos convierta `species` a **factor**, y que nos **agrupe aquellas niveles que tengan menos de 2 personajes**.


```r
ggplot(starwars %&gt;%
         filter(!is.na(species)) %&gt;%
         mutate(species =
                  fct_lump_min(species, min = 3,
                               other_level =
                                 "Otras especies")) %&gt;%
         count(species),
       aes(y = species, x = n, fill = n)) +
  geom_col() +
  scale_fill_continuous_tableau() +
  labs(fill = "Frecuencia absoluta",
       x = "Número de personajes", y = "Especies")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-433-1.png" width="100%" /&gt;

]

---

# Mosaicos o treemaps

.pull-left[

Otra opción habitual son los **mosaicos o treemaps**, representando en una **cuadrícula cada una de las categorías**, cuya **área sea proprocional a las veces que aparece**. Lo haremos con `{treemapify}`: los parámetros dentro de `aes()` serán `area` (asociado a la frecuencia absoluta), `fill` (color del relleno) y `label` (nombre). Usaremos una de las paletas de colores de cuadros vistas, en este caso `MetBrewer::met.brewer("Renoir")`.


```r
library(treemapify)
library(MetBrewer)
ggplot(starwars %&gt;% drop_na(species) %&gt;%
         mutate(species =
                      fct_lump_min(species, min = 2,
                                   other_level = "otras")) %&gt;%
         count(species),
       aes(area = n, fill = species, label = species)) +
* geom_treemap() +
  scale_fill_manual(values =
                      met.brewer("Renoir")) +
  labs(fill = "Especies")
```

]

.pull-right[


&lt;img src="index_files/figure-html/unnamed-chunk-435-1.png" width="100%" /&gt;

]

---

# Mosaicos o treemaps

.pull-left[

Con `geom_treemap_text()` podemos además escribir el **nombre de los niveles**, pudiendo **eliminar la leyenda**.


```r
library(treemapify)
library(MetBrewer)
ggplot(starwars %&gt;% drop_na(species) %&gt;%
         mutate(species =
                      fct_lump_min(species, min = 2,
                                   other_level = "otras")) %&gt;%
         count(species),
       aes(area = n, fill = species, label = species)) +
  geom_treemap() +
  geom_treemap_text(colour = "white", 
                    place = "centre",
                    size = 17) +
  scale_fill_manual(values = met.brewer("Renoir")) +
  labs(fill = "Especies") +
  guides(fill = "none")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-437-1.png" width="100%" /&gt;

]

---

# Ejercicio

.panelset[
.panel[.panel-name[Ejercicios]

* 📝 **Ejercicio 1**: visualiza un **diagrama de barras vertical** con `gapminder`, al que le pasaremos la variable `gdpPercap` a representar en el eje Y (la altura de las barras) y `year` en el eje X (tendremos una barra por año, con la altura del total mundial para ese año).

* 📝 **Ejercicio 2**: calcula la media de renta per cápita agrupada por continente y año, y guárdalo en `gapminder_por_continente`.

* 📝 **Ejercicio 3**: con `gapminder_por_continente` realiza un diagrama de barras, de forma que el color del relleno `fill` dependa del continente.

* 📝 **Ejercicio 4**: repite el gráfico anterior con `position = "dodge2"` dentro de la función `geom_col()`.

* 📝 **Ejercicio 5**: repite el gráfico anterio con `position = "fill"`,` que hará cada barra de igual longitud, permitiéndonos visualizar los datos en relativo.

* 📝 **Ejercicio 6**: añade `coord_flip()` para un **diagrama de barras horizontales**. Dale además un título, subtítulo y caption, y nombre en leyenda.

]

.panel[.panel-name[Sol. 1]

.pull-left[


```r
ggplot(gapminder,
     aes(y = gdpPercap, x = year)) +
  geom_col()
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-439-1.png" width="100%" /&gt;

]

]

.panel[.panel-name[Sol. 2]


```r
gapminder_por_continente &lt;-
  gapminder %&gt;% group_by(year, continent) %&gt;%
  summarise(sum_gdpPercap = mean(gdpPercap))
gapminder_por_continente
```

```
&gt; # A tibble: 60 x 3
&gt; # Groups:   year [12]
&gt;     year continent sum_gdpPercap
&gt;    &lt;int&gt; &lt;fct&gt;             &lt;dbl&gt;
&gt;  1  1952 Africa            1253.
&gt;  2  1952 Americas          4079.
&gt;  3  1952 Asia              5195.
&gt;  4  1952 Europe            5661.
&gt;  5  1952 Oceania          10298.
&gt;  6  1957 Africa            1385.
&gt;  7  1957 Americas          4616.
&gt;  8  1957 Asia              5788.
&gt;  9  1957 Europe            6963.
&gt; 10  1957 Oceania          11599.
&gt; # ... with 50 more rows
```

]

.panel[.panel-name[Sol. 3]

.pull-left[


```r
ggplot(gapminder_por_continente,
     aes(y = sum_gdpPercap, x = year,
         fill = continent)) +
  geom_col() +
  scale_fill_tableau()
```

Si te fijas, por defecto nos ha construido las **barras apiladas**
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-442-1.png" width="100%" /&gt;

]
  
]

.panel[.panel-name[Sol. 4]

.pull-left[


```r
ggplot(gapminder_por_continente,
     aes(y = sum_gdpPercap, x = year,
         fill = continent)) +
  geom_col(position = "dodge2") +
  scale_fill_tableau()
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-444-1.png" width="100%" /&gt;

]
]

.panel[.panel-name[Sol. 5]

.pull-left[


```r
ggplot(gapminder_por_continente,
     aes(y = sum_gdpPercap, x = year,
         fill = continent)) +
  geom_col(position = "fill") +
  scale_fill_tableau()
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-446-1.png" width="100%" /&gt;

]

]

.panel[.panel-name[Sol. 6]

.pull-left[


```r
ggplot(gapminder_por_continente,
     aes(y = sum_gdpPercap, x = year,
         fill = continent)) +
  geom_col() +
* coord_flip() +
  scale_fill_tableau() +
  labs(x = "Renta per cápita",
       y = "Año",
       color = "Continente",
       title = "EJEMPLO DE DIAGRAMA DE BARRAS",
       subtitle =
         "Barras horizontales (agrupadas por continente y año)",
       caption = "J. Perez Liébana | Datos: gapminder")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-448-1.png" width="100%" /&gt;

]


]

]

---

# CASO PRÁCTICO

## Visualización de datos continuos

&amp;nbsp;

Hasta ahora hemos visualizado variables cuantitaivas discretas o cualitativas: ¿cómo visualizar datos continuos?

---

# Ejemplo: percepción de la probabilidad

Vamos a analizar un **conjunto de datos** interesante, que contiene las respuestas a las preguntas...

**«¿Qué probabilidad (%) asignarías al término ...?**

&amp;nbsp;

Dicha pregunta se realizó para distintos términos como «almost no chance», «about even», «probable» o «almost certainly», con el objetivo de comprender **cómo la gente percibe el vocabulario** relativo a la probabilidad.

Los datos y gráficos están basados en el trabajo de [Zoni Nation](https://github.com/zonination/perceptions) y [data-to-viz.com](https://www.data-to-viz.com/story/OneNumOneCatSeveralObs.html)


```r
datos &lt;-
  read_csv("https://raw.githubusercontent.com/zonination/perceptions/master/probly.csv")
datos
```

```
&gt; # A tibble: 46 x 17
&gt;    `Almost Certainly` `Highly Likely` `Very Good Chan~` Probable Likely Probably
&gt;                 &lt;dbl&gt;           &lt;dbl&gt;             &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;
&gt;  1                 95              80                85       75     66       75
&gt;  2                 95              75                75       51     75       51
&gt;  3                 95              85                85       70     75       70
&gt;  4                 95              85                85       70     75       70
&gt;  5                 98              95                80       70     70       75
&gt;  6                 95              99                85       90     75       75
&gt;  7                 85              95                65       80     40       45
&gt;  8                 97              95                75       70     70       80
&gt;  9                 95              95                80       70     65       80
&gt; 10                 90              85                90       70     75       70
&gt; # ... with 36 more rows, and 11 more variables: `We Believe` &lt;dbl&gt;,
&gt; #   `Better Than Even` &lt;dbl&gt;, `About Even` &lt;dbl&gt;, `We Doubt` &lt;dbl&gt;,
&gt; #   Improbable &lt;dbl&gt;, Unlikely &lt;dbl&gt;, `Probably Not` &lt;dbl&gt;,
&gt; #   `Little Chance` &lt;dbl&gt;, `Almost No Chance` &lt;dbl&gt;, `Highly Unlikely` &lt;dbl&gt;,
&gt; #   `Chances Are Slight` &lt;dbl&gt;
```

---

# Convirtiendo a tidy data

.panelset[
.panel[.panel-name[Ejercicio]

1. Vamos a visualizar con un diagrama de barras la **media de las probabilidades** que la gente ha asignado a cada término. Pero antes debemos de **transformar el dataset a tidydata** con `pivot_longer()`, para que tenga el formato adecuado para `ggplot2()`

2. Tras la transformación a un formato adecuado para `ggplot2()`, vamos a **seleccionar los términos** `Almost No Chance`, `Chances Are Slight`, `Improbable`, `About Even`, `Probable` y `Almost Certainly`.

3. Además vamos a **reordenar los niveles de factor** de la variable `termino` con `fct_reorder()` (del paquete `{forcats}`) en función de sus probabilidades.


]

.panel[.panel-name[Paso 1]


```r
datos_pivot &lt;-
  datos %&gt;%
  pivot_longer(cols = everything(),
               names_to = "termino", values_to = "prob")
datos_pivot
```

```
&gt; # A tibble: 782 x 2
&gt;    termino           prob
&gt;    &lt;chr&gt;            &lt;dbl&gt;
&gt;  1 Almost Certainly    95
&gt;  2 Highly Likely       80
&gt;  3 Very Good Chance    85
&gt;  4 Probable            75
&gt;  5 Likely              66
&gt;  6 Probably            75
&gt;  7 We Believe          66
&gt;  8 Better Than Even    55
&gt;  9 About Even          50
&gt; 10 We Doubt            40
&gt; # ... with 772 more rows
```

]

.panel[.panel-name[Paso 2]


```r
datos_final &lt;-
  datos_pivot %&gt;%
  filter(termino %in% c("Almost No Chance", "Chances Are Slight",
                        "Improbable", "About Even",
                        "Probable", "Almost Certainly"))
datos_final
```

```
&gt; # A tibble: 276 x 2
&gt;    termino             prob
&gt;    &lt;chr&gt;              &lt;dbl&gt;
&gt;  1 Almost Certainly      95
&gt;  2 Probable              75
&gt;  3 About Even            50
&gt;  4 Improbable            20
&gt;  5 Almost No Chance       5
&gt;  6 Chances Are Slight    25
&gt;  7 Almost Certainly      95
&gt;  8 Probable              51
&gt;  9 About Even            50
&gt; 10 Improbable            49
&gt; # ... with 266 more rows
```

]

.panel[.panel-name[Paso 3]


```r
datos_final &lt;-
  datos_final %&gt;%
  mutate(termino = fct_reorder(termino, prob))
datos_final
```

```
&gt; # A tibble: 276 x 2
&gt;    termino             prob
&gt;    &lt;fct&gt;              &lt;dbl&gt;
&gt;  1 Almost Certainly      95
&gt;  2 Probable              75
&gt;  3 About Even            50
&gt;  4 Improbable            20
&gt;  5 Almost No Chance       5
&gt;  6 Chances Are Slight    25
&gt;  7 Almost Certainly      95
&gt;  8 Probable              51
&gt;  9 About Even            50
&gt; 10 Improbable            49
&gt; # ... with 266 more rows
```

]

]


---

# Diagrama de barras de las medias


.panelset[
.panel[.panel-name[Ejercicio]


1. Tras preprocesar los datos, calcula las medias de las probabilidades agrupadas por la variable `termino` (con `group_by()` y `summarise()`)

2. Usamos `geom_col()` para visualizar dichas medias como un diagrama de barras.

]

.panel[.panel-name[Paso 1]


```r
datos_resumen &lt;-
  datos_final %&gt;%
  group_by(termino) %&gt;%
  summarise(media = mean(prob))
datos_resumen
```

```
&gt; # A tibble: 6 x 2
&gt;   termino            media
&gt;   &lt;fct&gt;              &lt;dbl&gt;
&gt; 1 Almost No Chance    5.63
&gt; 2 Chances Are Slight 14.1 
&gt; 3 Improbable         18.0 
&gt; 4 About Even         49.6 
&gt; 5 Probable           71.5 
&gt; 6 Almost Certainly   92.6
```

]

.panel[.panel-name[Paso 2]

.pull-left[


```r
ggplot(datos_resumen,
       aes(x = termino, y = media, fill = termino)) +
  geom_col()
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-455-1.png" width="100%" /&gt;

]

]

]

---

# Paleta de colores

.pull-left[

Con `scale_fill_brewer()` vamos a darle una **paleta de colores divergente** al relleno, de rojo (poca probabilidad) a azul (mucha probabilidad) con `scale_fill_brewer(palette = "RdBu")`. Además definiremos un tema para los siguientes gráficos.


```r
library(showtext)
font_add_google(family = "Roboto",
                name = "Roboto")
showtext_auto()

theme_set(theme_minimal(base_family = "Roboto"))
theme_update(
plot.background =
    element_rect(fill = "white",
                 color = "white"),
  plot.title =
  element_text(color = "black",
               face = "bold", size = 27))

ggplot(datos_resumen,
       aes(x = termino, y = media, fill = termino)) +
  geom_col(alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  labs(fill = "Términos",
       y = "Probabilidad (%)",
       title = "Percepción de la probabilidad")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-457-1.png" width="100%" /&gt;


]

]


---

# Visualizando puntos: geom_quasirandom

.panelset[
.panel[.panel-name[Ejercicio]

1. Dado el conjunto sin resumir, el conjunto `datos_final`, define una cabecera de `ggplot()` con

* `termino` en el eje x
* `prob` en el eje y
* `termino` en el color

2. La función `geom_quasirandom()` del paquete `{ggbeeswarm}` nos permite visualizar los datos en puntos, desperdigados de forma «aleatoria» a lo ancho. A la cabecera anterior añade `geom_quasirandom()` con:

* tamaño igual a 3.5
* anchura igual a 0.5 (lo que se desperdigan respecto al centro los datos)
* transparencia del 70%

3. Añade con `scale_color_brewer(palette = "RdBu")` una paleta de colores divergente.

4. Añade el título de la leyenda (de `color`), título y títulos de ejes, con `labs(...)`.

]

.panel[.panel-name[Paso 1]


```r
ggplot(datos_final,
       aes(x = termino, y = prob,
           color = termino))
```

&lt;img src="index_files/figure-html/unnamed-chunk-458-1.png" width="100%" /&gt;

]

.panel[.panel-name[Paso 2]

.pull-left[


```r
library(ggbeeswarm)
ggplot(datos_final,
       aes(x = termino, y = prob,
           color = termino)) +
  geom_quasirandom(size = 3.5, width = 0.5,
                   alpha = 0.7)
```

]


.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-460-1.png" width="100%" /&gt;

]

]

.panel[.panel-name[Paso 3]

.pull-left[


```r
ggplot(datos_final,
       aes(x = termino, y = prob,
           color = termino)) +
  geom_quasirandom(size = 3.5, width = 0.5,
                   alpha = 0.7) +
  scale_color_brewer(palette = "RdBu")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-462-1.png" width="100%" /&gt;
]

]

.panel[.panel-name[Paso 4]

.pull-left[


```r
ggplot(datos_final,
       aes(x = termino, y = prob,
           color = termino)) +
  geom_quasirandom(size = 3.5, width = 0.5,
                   alpha = 0.7) +
  scale_color_brewer(palette = "RdBu") +
  labs(color = "Términos", x = "Términos",
       y = "Probabilidad (%)",
       title = "Percepción de la probabilidad")
```

]
  
.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-464-1.png" width="100%" /&gt;

]      
 
]
]


---

# Visualizando puntos: geom_quasirandom

.panelset[
.panel[.panel-name[Ejercicio]

Repite el gráfico con el conjunto de `starwars`:

1. Filtra los ausentes en `height` y `species`, y recategoriza la variable `species` en humanos o no humanos. 

2. Tras el preprocesado visualiza con `geom_quasirandom()` la estatura (variable continua) de cada uno de los dos grupos.

3. Además indica con `scale_x_discrete()` las etiquetas de nuestras categorías (que por defecto aparecen en inglés, `FALSE` vs `TRUE`)

4. Elimina el título de las leyendas del color y el relleno. Añade además títulos para el eje X e Y, y título de la gráfica.

]


.panel[.panel-name[Paso 1]


```r
starwars_altura &lt;-
  starwars %&gt;%
  drop_na(height, species) %&gt;%
  mutate(human = as_factor(species == "Human"))
starwars_altura
```

```
&gt; # A tibble: 78 x 15
&gt;    name     height  mass hair_color skin_color eye_color birth_year sex   gender
&gt;    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
&gt;  1 Luke Sk~    172    77 blond      fair       blue            19   male  mascu~
&gt;  2 C-3PO       167    75 &lt;NA&gt;       gold       yellow         112   none  mascu~
&gt;  3 R2-D2        96    32 &lt;NA&gt;       white, bl~ red             33   none  mascu~
&gt;  4 Darth V~    202   136 none       white      yellow          41.9 male  mascu~
&gt;  5 Leia Or~    150    49 brown      light      brown           19   fema~ femin~
&gt;  6 Owen La~    178   120 brown, gr~ light      blue            52   male  mascu~
&gt;  7 Beru Wh~    165    75 brown      light      blue            47   fema~ femin~
&gt;  8 R5-D4        97    32 &lt;NA&gt;       white, red red             NA   none  mascu~
&gt;  9 Biggs D~    183    84 black      light      brown           24   male  mascu~
&gt; 10 Obi-Wan~    182    77 auburn, w~ fair       blue-gray       57   male  mascu~
&gt; # ... with 68 more rows, and 6 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
&gt; #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;, human &lt;fct&gt;
```

]

.panel[.panel-name[Paso 2]

.pull-left[


```r
library(ggbeeswarm)
ggplot(starwars_altura,
       aes(x = human, y = height,
           fill = human, color = human)) +
  geom_quasirandom(size = 4.5, width = 0.5, alpha = 0.5)
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-467-1.png" width="100%" /&gt;

]

]


.panel[.panel-name[Paso 3]

.pull-left[


```r
library(ggbeeswarm)
ggplot(starwars_altura,
       aes(x = human, y = height,
           fill = human, color = human)) +
  geom_quasirandom(size = 4.5, width = 0.5, alpha = 0.5) +
  scale_x_discrete(labels = c("NO", "SÍ"))
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-469-1.png" width="100%" /&gt;

]

]

.panel[.panel-name[Paso 4]


.pull-left[


```r
library(ggbeeswarm)
ggplot(starwars_altura,
       aes(x = human, y = height,
           fill = human, color = human)) +
  geom_quasirandom(size = 4.5, width = 0.5, alpha = 0.5) +
  scale_x_discrete(labels = c("NO", "SÍ")) +
  guides(color = "none", fill = "none") +
  labs(x = "¿Son humanos?",
       y = "Altura (cm)",
       title = "ALTURA DE LOS PERSONAJES DE STARWARS")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-471-1.png" width="100%" /&gt;
]

]
]

---

# Gráficos de cajas y bigotes

Otra opción para visualizar datos continuos son con los famosos **gráficos de cajas y bigotes** con `geom_boxplot()`

.pull-left[


```r
ggplot(datos_final,
       aes(x = termino, y = prob, fill = termino)) +
  geom_boxplot(alpha = 0.8) +
  scale_fill_brewer(palette = "RdBu") +
  labs(fill = "Términos",
       y = "Probabilidad (%)",
       title = "Percepción de la probabilidad")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-473-1.png" width="100%" /&gt;

]

---

# Gráficos de cajas y bigotes

.pull-left[

&lt;img src="index_files/figure-html/unnamed-chunk-474-1.png" width="100%" /&gt;

]

.pull-right[

Un **diagrama de caja y bigotes o box plot** es un gráfico que resume algunos datos estadísticos en relación a la **mediana** y **medidas de posición** (percentiles)

* Los **lados** inferior y superior de la caja representan el **primer y tercer cuartil**: la **altura de la caja** es igual al **rango intercuartílico** (dentro están el 50% de los datos centrales en torno a la mediana=.

* La **línea gruesa** que divide la caja marca la **mediana**.

* Las **líneas (bigotes)** que salen de las cajas llegan hasta el primer/último dato que no supere 1.5 veces el rango intercuartílico (diferencia entre tercer y primer cuartil). Los **puntos alejados** representan los **datos atípicos o outliers**.

]

---

# Gráficos de cajas y bigotes

.pull-left[

Podemos añadir, además del gráfico resumido, los propios datos con `geom_jitter()`, que nos añadirá los puntos como una especie de «gotelé aleatorio» (la altura es la de los datos pero la anchura la disemina)


```r
ggplot(datos_final,
       aes(x = termino, y = prob,
           color = termino, fill = termino)) +
  geom_boxplot(alpha = 0.8) +
  geom_jitter(alpha = 0.25, size = 1.5) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none", fill = "none")
  labs(fill = "Términos",
       y = "Probabilidad (%)",
       title = "Percepción de la probabilidad")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-476-1.png" width="100%" /&gt;

```
&gt; $fill
&gt; [1] "Términos"
&gt; 
&gt; $y
&gt; [1] "Probabilidad (%)"
&gt; 
&gt; $title
&gt; [1] "Percepción de la probabilidad"
&gt; 
&gt; attr(,"class")
&gt; [1] "labels"
```

]

---

# Gráficos de cajas y bigotes

.pull-left[

Con `coord_flip()` podemos **invertir los ejes**


```r
ggplot(datos_final,
       aes(x = termino, y = prob,
           color = termino, fill = termino)) +
  geom_boxplot(alpha = 0.8) +
  geom_jitter(alpha = 0.25, size = 1.5) +
  coord_flip() +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none", fill = "none") +
  labs(fill = "Términos",
       y = "Probabilidad (%)",
       title = "Percepción de la probabilidad")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-478-1.png" width="100%" /&gt;

]


]

---

# Histograma, densidad y violín

.pull-left[

Una opción también muy habitual son los **histogramas**  (que no diagrama de barras). El histograma **segmenta en tramos el conjunto de posibles valores** y representa la frecuencia de cada uno de esos segmentos. Para pintarlos podemos hacerlo con `geom_histogram()` (por ejemplo, para las probabilidades de `termino == "Probable"`)


```r
ggplot(datos_pivot %&gt;%
         filter(termino == "Probable"),
       aes(x = prob)) +
* geom_histogram(alpha = 0.4) +
  labs(fill = "Términos",
       y = "Probabilidad (%)",
       title = "Percepción de probabilidad")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-480-1.png" width="100%" /&gt;

]

---

# Histograma, densidad y violín

.panelset[
.panel[.panel-name[Ejercicio]

1. Sin filtrer los datos, codifica el color y el relleno en función de la variable `termino`, componiendo con `facet_wrap()` en función de dicha variable.

2. Añade `scale_fill_viridis_d()` y `scale_fill_viridis_d()` para las escalas de colores y rellenos. Elimina el nombre de las leyendas de `color` y `fill`.

3. Modifica la variable `termino` con `fct_reorder` para reordenar los términos en función de sus probabilidades.

4. Por defecto nos pinta 30 barras pero podemos indicarle que pinte más o menos, por ejemplo 10 barras con `bins = 10` dentro de `geom_histogram()`.

]

.panel[.panel-name[Paso 1]

.pull-left[


```r
ggplot(datos_pivot,
       aes(x = prob, color = termino,
           fill = termino)) +
  geom_histogram(alpha = 0.4) +
* facet_wrap(~ termino,
             scale = "free_y") +
  labs(fill = "Términos",
       y = "Probabilidad (%)",
       title = "Percepción de probabilidad")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-482-1.png" width="100%" /&gt;

]

]

.panel[.panel-name[Paso 2]

.pull-left[


```r
ggplot(datos_pivot,
       aes(x = prob, color = termino,
           fill = termino)) +
  geom_histogram(alpha = 0.4) +
* scale_fill_viridis_d() +
* scale_color_viridis_d() +
  facet_wrap(~ termino,
             scale = "free_y") +
  guides(color = "none",
*        fill = "none") +
  labs(fill = "Términos",
       y = "Probabilidad (%)",
       title = "Percepción de probabilidad")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-484-1.png" width="100%" /&gt;

]
]

.panel[.panel-name[Paso 3]

.pull-left[


```r
datos_pivot &lt;-
  datos_pivot %&gt;%
  mutate(termino =
*          fct_reorder(termino, prob))

ggplot(datos_pivot,
       aes(x = prob, color = termino,
           fill = termino)) +
  geom_histogram(alpha = 0.4) +
  scale_fill_viridis_d() + 
  scale_color_viridis_d() + 
  facet_wrap(~ termino,
             scale = "free_y") +
  guides(color = "none",
         fill = "none") +
  labs(fill = "Términos",
       y = "Probabilidad (%)",
       title = "Percepción de probabilidad")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-486-1.png" width="100%" /&gt;

]

]

.panel[.panel-name[Paso 4]

.pull-left[


```r
ggplot(datos_pivot,
       aes(x = prob, color = termino,
           fill = termino)) +
  geom_histogram(alpha = 0.4,
*                bins = 10) +
  scale_fill_viridis_d() + 
  scale_color_viridis_d() + 
  facet_wrap(~ termino,
             scale = "free_y") +
  guides(color = "none",
         fill = "none") + 
  labs(fill = "Términos",
       y = "Probabilidad (%)",
       title = "Percepción de probabilidad")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-488-1.png" width="100%" /&gt;

]

]

]


---

# Histograma, densidad y violín

.pull-left[

Los **histogramas** en realidad son una **aproximación discreta** de los **gráficos de densidad** (asumiendo que los intervalos se pudieran ir haciendo tan pequeños como queramos, generado una curva continua). Las densidades mejoran la robustez al histograma que puede variar mucho en función de los tramos de agregación elegidos. 

Basta cambiar `geom_histogram()` por `geom_density()`


```r
ggplot(datos_final,
       aes(x = prob, color = termino,
           fill = termino)) +
* geom_density(alpha = 0.4) +
  scale_fill_brewer(palette = "RdBu") +
  scale_color_brewer(palette = "RdBu") +
  guides(color = "none") +
  labs(fill = "Términos",
       y = "Probabilidad (%)",
       title = "Percepción de probabilidad")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-490-1.png" width="100%" /&gt;


]

---

# Histograma, densidad y violín

.pull-left[

A veces puede ser interesante **superponer las densidades**, lo cual lo podemos hacer con `geom_density_ridges()`, del paquete `{ggridges}`.


```r
library(ggridges)
ggplot(datos_pivot %&gt;%
         mutate(termino =
                  fct_reorder(termino, prob)),
       aes(y = termino, x = prob,
           fill = termino)) +
* geom_density_ridges(alpha = 0.4) +
  scale_fill_viridis_d() +
  scale_color_viridis_d() +
  guides(color = "none", fill = "none")  +
  labs(fill = "Términos",
       y = "Probabilidad (%)",
       title = "Percepción de la probabilidad")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-492-1.png" width="100%" /&gt;


]


---

class: center, middle

# CASO PRÁCTICO

## VISUALIZANDO DATOS DE NETFLIX

&amp;nbsp;

Vamos a profundizar en la personalización de nuestro gráfico


---

# Datos

En esta ocasión vamos a usar los **datos de Netflix** proporcionados por [El Arte del Dato](https://elartedeldato.com/blog/como-anadir-una-anotacion-en-ggplot/), página en la que se basará esta visualización: **visualizaremos** el **número de películas y series de instituto** que se han estrenado en **Netflix en cada año**. Los datos provienen originalmente de [Kaggle](https://www.kaggle.com/shivamb/netflix-shows),


```r
netflix &lt;-
  read_csv('https://raw.githubusercontent.com/elartedeldato/datasets/main/netflix_titles.csv')
netflix
```

```
&gt; # A tibble: 7,787 x 12
&gt;    show_id type    title director   cast  country date_added release_year rating
&gt;    &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;             &lt;dbl&gt; &lt;chr&gt; 
&gt;  1 s1      TV Show 3%    &lt;NA&gt;       João~ Brazil  August 14~         2020 TV-MA 
&gt;  2 s2      Movie   7:19  Jorge Mic~ Demi~ Mexico  December ~         2016 TV-MA 
&gt;  3 s3      Movie   23:59 Gilbert C~ Tedd~ Singap~ December ~         2011 R     
&gt;  4 s4      Movie   9     Shane Ack~ Elij~ United~ November ~         2009 PG-13 
&gt;  5 s5      Movie   21    Robert Lu~ Jim ~ United~ January 1~         2008 PG-13 
&gt;  6 s6      TV Show 46    Serdar Ak~ Erda~ Turkey  July 1, 2~         2016 TV-MA 
&gt;  7 s7      Movie   122   Yasir Al ~ Amin~ Egypt   June 1, 2~         2019 TV-MA 
&gt;  8 s8      Movie   187   Kevin Rey~ Samu~ United~ November ~         1997 R     
&gt;  9 s9      Movie   706   Shravan K~ Divy~ India   April 1, ~         2019 TV-14 
&gt; 10 s10     Movie   1920  Vikram Bh~ Rajn~ India   December ~         2008 TV-MA 
&gt; # ... with 7,777 more rows, and 3 more variables: duration &lt;chr&gt;,
&gt; #   listed_in &lt;chr&gt;, description &lt;chr&gt;
```


---

# Proyecto

Cuando se empieza a programar para un trabajo concreto de `R` es recomendable crearnos lo que se conoce como un **proyecto de trabajo**: en lugar de ir abriendo ventanas sueltas para programar, podemos agruparlos en proyectos, de forma que podamos acceder a ellos de forma **ordenada**

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/crear_proyecto1.jpg" alt = "course-ECI" align = "left" width = "220" style = "margin-top: 5vh;margin-right: 0.5rem;margin-left: 0.5rem;"&gt;

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/crear_proyecto2.jpg" alt = "course-ECI" align = "middle" width = "220" style = "margin-top: 5vh;margin-right: 0.5rem;margin-left: 0.5rem;"&gt;

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/crear_proyecto3.jpg" alt = "course-ECI" align = "right" width = "250" style = "margin-top: 5vh;margin-right: 0.5rem;margin-left: 0.5rem;"&gt;

&lt;img src = "https://dadosdelaplace.github.io/courses-ECI-2022/img/crear_proyecto4.jpg" alt = "course-ECI" align = "right" width = "250" style = "margin-top: 5vh;margin-right: 0.5rem;margin-left: 0.5rem;"&gt;

---

# Preprocesamiento

Para visualizar vamos a filtrar las **películas y series de instituto**, usando la función `str_detect()` (del paquete `{stringr}`), que nos devolverá `TRUE` si detecta en la variable `description` (pasándola a mayúsculas por si acaso) el patrón de texto `"HIGH SCHOOL"`.


```r
netflix_hs &lt;- netflix %&gt;%
  filter(str_detect(toupper(description), "HIGH SCHOOL"))
netflix_hs 
```

```
&gt; # A tibble: 150 x 12
&gt;    show_id type  title     director cast  country date_added release_year rating
&gt;    &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;             &lt;dbl&gt; &lt;chr&gt; 
&gt;  1 s8      Movie 187       Kevin R~ Samu~ United~ November ~         1997 R     
&gt;  2 s32     Movie #FriendB~ Rako Pr~ Adip~ Indone~ May 21, 2~         2018 TV-G  
&gt;  3 s34     Movie #reality~ Fernand~ Nest~ United~ September~         2017 TV-14 
&gt;  4 s47     Movie 1 Chance~ Adam De~ Lexi~ United~ July 1, 2~         2014 TV-PG 
&gt;  5 s48     Movie 1 Mile t~ Leif Ti~ Bill~ United~ July 7, 2~         2017 TV-14 
&gt;  6 s56     Movie 100 Thin~ &lt;NA&gt;     Isab~ United~ November ~         2014 TV-Y  
&gt;  7 s58     Movie 100% Hal~ Jastis ~ Anis~ Indone~ January 7~         2020 TV-14 
&gt;  8 s148    Movie A Babysi~ Rachel ~ Tama~ United~ October 1~         2020 TV-PG 
&gt;  9 s251    Movie A Walk t~ Adam Sh~ Mand~ United~ July 1, 2~         2002 PG    
&gt; 10 s297    Movie Across T~ Julien ~ Sara~ Canada  April 1, ~         2015 TV-MA 
&gt; # ... with 140 more rows, and 3 more variables: duration &lt;chr&gt;,
&gt; #   listed_in &lt;chr&gt;, description &lt;chr&gt;
```

---

# Preprocesamiento

📝 Del conjunto original **elimina** aquellos registros de los que no tengamos su año de estreno, aquellos registros cuyo campo `date_added` esté ausente.

📝 Tras ello comprueba que efectivamente no queda ninguno ausente

--



```r
netflix_filtro &lt;- 
  netflix_hs %&gt;% filter(!is.na(date_added))

netflix_filtro %&gt;% filter(is.na(date_added))
```

```
&gt; # A tibble: 0 x 12
&gt; # ... with 12 variables: show_id &lt;chr&gt;, type &lt;chr&gt;, title &lt;chr&gt;,
&gt; #   director &lt;chr&gt;, cast &lt;chr&gt;, country &lt;chr&gt;, date_added &lt;chr&gt;,
&gt; #   release_year &lt;dbl&gt;, rating &lt;chr&gt;, duration &lt;chr&gt;, listed_in &lt;chr&gt;,
&gt; #   description &lt;chr&gt;
```

---

# Preprocesammiento

Tras dicho filtro vamos a añadir el **año en el que se estrenó**, con la función `year()` de `{lubridate}`, que nos devuelve el año de una fecha concreta. Esa fecha concreta la vamos a construir con `mdy()`.


```r
library(lubridate)
mdy("August 26, 2016")
```

```
&gt; [1] "2016-08-26"
```

```r
mdy("January 13, 2015")
```

```
&gt; [1] "2015-01-13"
```

---

# Preprocesammiento

📝 Añade una nueva columna a nuestros datos que contenga el año de estreno en Netflix (convirtiendo primero a fecha y luego extrayendo el año).

--


```r
netflix_final &lt;- 
  netflix_filtro %&gt;%
  mutate(year = year(mdy(date_added)))
```

---

# Análisis preliminar

Tras la depuración 

📝 Agrupa los datos por año (que tenemos en la nueva variable `year` creada)

📝 Cuenta el número de elementos en cada año.

--


```r
netflix_resumen &lt;- 
  netflix_final %&gt;%
* group_by(year) %&gt;%
  count() %&gt;%
* ungroup()
netflix_resumen
```

```
&gt; # A tibble: 9 x 2
&gt;    year     n
&gt;   &lt;dbl&gt; &lt;int&gt;
&gt; 1  2011     2
&gt; 2  2013     1
&gt; 3  2015     1
&gt; 4  2016     6
&gt; 5  2017    18
&gt; 6  2018    28
&gt; 7  2019    42
&gt; 8  2020    46
&gt; 9  2021     6
```

---

# Diagrama de barras

.panelset[
.panel[.panel-name[Ejercicio]

📝 Con estos datos ya estamos condiciones de poder hacer nuestro diagrama de barras. Realiza un diagrama de barras con el año en el eje X, el número de películas en cada una en el eje Y.

]

.panel[.panel-name[Solución]

.pull-left[


```r
ggplot(netflix_resumen,
       aes(x = year, y = n)) +
* geom_col()
```
]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-500-1.png" width="100%" /&gt;

]

]

]

---

# Diagrama de barras: color

.panelset[
.panel[.panel-name[Ejercicio]

📝 Repite el gráfico indicándole el color del RELLENO de las barras sea rojo (`"red"`)

]

.panel[.panel-name[Solución]

.pull-left[


```r
ggplot(netflix_resumen,
       aes(x = year, y = n)) +
* geom_col(fill = "red")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-502-1.png" width="100%" /&gt;

]

]

]


---

# Modificando la escala de los ejes

.pull-left[

Si te fijas solo nos ha mostrado algunos años en el eje X, así que le vamos a indicar la **escala concreta** que queremos en dicho eje con `scale_x_continuous()`, usando el argumento `breaks` en el que le indicaremos los valores donde queremos que «corte» el eje X (los corte serán los años guardados en `netflix_resumen$year`)


```r
ggplot(netflix_resumen, aes(x = year, y = n)) +
  geom_col(fill = "red") +
  scale_x_continuous(breaks =
*                      netflix_resumen$year)
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-504-1.png" width="100%" /&gt;

]

---

# Fechas en los ejes 

Cuando uno de los **ejes representa una fecha** podemos indicárselo con `scale_x_date()`, asigándole en `date_breaks` el lapso temporal que queremos en las marcas (por ejemplo, `date_breaks = '1 month'`). Como ejemplo, vamos a visualizar el número de películas y series generales estrenadas en Netflix desde el 1 de julio de 2020.

📝 Antes filtra tu conjunto original `netflix` para quedarte solo con los registros posteriroes al 1 de julio de 2020, agrupalos por fecha

--


```r
netflix_julio_2022 &lt;-
  netflix %&gt;%
  mutate(date_added = mdy(date_added)) %&gt;%
* filter(date_added &gt; as.Date("2020-07-01"))
```
  
---

# Fechas en los ejes 

.panelset[
.panel[.panel-name[Ejercicio]

📝 Visualiza en un diagrama de barras las películas agrupadas por fecha de `netflix_julio_2022`, con `geom_col()`, y añade `scale_x_date(date_breaks = '1 month')`

] 

.panel[.panel-name[Solución]

.pull-left[


```r
ggplot(netflix_julio_2022 %&gt;%
         group_by(date_added) %&gt;% count(),
       aes(x = date_added, y = n)) +
  geom_col(fill = "red") +
* scale_x_date(date_breaks = '1 month')
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-507-1.png" width="100%" /&gt;

]

]

]

---

# Personalizando tema

.panelset[
.panel[.panel-name[Ejercicio]

📝 Lo primero que vamos a hacer para personalizar es **añadir título, subtítulo y caption**.

]

.panel[.panel-name[Solución]

.pull-left[


```r
ggplot(netflix_resumen,
       aes(x = year, y = n)) +
  geom_col(fill = "red") +
  scale_x_continuous(breaks = netflix_resumen$year) +
* labs(title = "NETFLIX",
       subtitle = "Películas y series de instituto",
       caption =
         "Basada en El Arte del Dato (https://elartedeldato.com) | Datos: Kaggle")
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-509-1.png" width="100%" /&gt;

]

]

]

---

# Fuente propia

En este caso, al ser datos de Netflix, la propia palabara de es una marca por sí misma, y quizás nos interese **usar alguna fuente de Google** para cambiar la fuente por defecto. En este caso vamos a usar la fuente de Netflix, la fuente `Bebas Neue`, y para poder usarla usaremos `font_add_google()`


```r
library(sysfonts)
library(showtext)
font_add_google(family = "Bebas Neue",
                name = "Bebas Neue")
showtext_auto()
```

---

# Fuente propia

Tras ello vamos a **personalizar totalmente nuestro tema**. Lo primero que haremos será «resetear» el tema que podamos tener por defecto  con `theme_minimal()`. Tras dicho reseteo, le indicaremos con `theme()`

* `legend.position = "none"`: sin leyenda.
* `plot.title = element_text(family = "Bebas Neue", color = "red", size = 50)`: le indicaremos la fuente, el color y el tamaño de nuestro título.


```r
gg &lt;- ggplot(netflix_resumen, aes(x = year, y = n)) +
  geom_col(fill = "red") +
  scale_x_continuous(breaks = netflix_resumen$year) +
  theme_minimal() +
  theme(legend.position = "none",
        plot.title =
          element_text(family = "Bebas Neue",
                       color = "red", size = 80)) +
  labs(title = "NETFLIX",
       subtitle = "Películas y series de instituto",
       caption = "Basada en El Arte del Dato (https://elartedeldato.com) | Datos: Kaggle")
gg
```

---

# Fuente propia

&lt;img src="index_files/figure-html/unnamed-chunk-512-1.png" width="100%" /&gt;

---

# Color de fondo

.pull-left[

Tras cambiar la fuente del título vamos a indicarle que el fondo del gráfico sea todo negro.


```r
gg &lt;- 
  gg +
  theme(panel.background =
          element_rect(fill = "black"),
        plot.background =
          element_rect(fill = "black", 
                       color = "black"))
gg
```

]

.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-514-1.png" width="100%" /&gt;

]

---

# Grid

.pull-left[

También vamos a personalizar el grid horizontal (el que marca las alturas del eje y), indicándole color y tamaño.


```r
gg &lt;- gg +
  theme(panel.grid.major.y =
          element_line(size = 0.1,
                       color = "white"),
        panel.grid.minor.y = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())
gg
```

]


.pull-right[

&lt;img src="index_files/figure-html/unnamed-chunk-516-1.png" width="100%" /&gt;

]

---

# Fuentes de textos

.pull-left[

Vamos a personalizar también la **fuente del subtítulo y caption** y los textos de los ejes.


```r
font_add_google(family = "Permanent Marker",
                name = "Permanent Marker")
showtext_auto()
gg &lt;- gg + 
  theme(plot.subtitle =
          element_text(family = "Permanent Marker",
                       size = 21, color = "white"),
        plot.caption =
          element_text(family = "Permanent Marker",
                       color = "white", size = 19),
        axis.text = 
          element_text(size = 15,
                       family = "Permanent Marker",
                       color = "white"))
gg
```

]

.pull-right[


&lt;img src="index_files/figure-html/unnamed-chunk-518-1.png" width="100%" /&gt;

]

---

# Márgenes

Vamos a darle un poco de aire **añadiendo márgenes**


```r
gg &lt;- gg +
  theme(plot.margin =
          margin(t = 4, r = 4,
                 b = 4, l = 8, "pt"))
gg
```

---

# Gráfico casi final

&lt;img src="index_files/figure-html/unnamed-chunk-520-1.png" width="50%" style="display: block; margin: auto;" /&gt;

---

# Anotaciones

Por último con `annotate()` podemos añadir anotaciones al gráfico, por ejemplo, escribiendo el mes de enero en la última barra para remarcar que solo llega hasta enero de 2021, con una fina curva como «flecha».


```r
gg &lt;- gg  +
  annotate("text", label = "(hasta enero)", 
           x = 2021, y = 11,
           hjust = 0.3, vjust = 0,
           family = "Permanent Marker",
           size = 5, color='white', angle = 20) +
  annotate("curve",
           x = 2021, y = 9,
           xend = 2021, yend = 5,
           color = "white")
gg
```

---

# Tachán

&lt;img src="index_files/figure-html/unnamed-chunk-522-1.png" width="50%" style="display: block; margin: auto;" /&gt;


---

class: inverse center middle

# Bloque IV: Introducción a Rmarkdown

&amp;nbsp;


![](https://media.giphy.com/media/l4FsBtAJVk3gQcfh6/giphy.gif)


---



# Qué es R Markdown?

1. ["Un marco de creación para la ciencia de datos."](https://rmarkdown.rstudio.com/lesson-1.html) (✔️)

1. [Un formato de documento (`.Rmd`).](https://bookdown.org/yihui/rmarkdown/) (✔️)

1. [Un paquete R llamado `rmarkdown`.](https://rmarkdown.rstudio.com/docs/) (✔️)

1. ["Un formato de archivo para hacer documentos dinámicos con R.."](https://rmarkdown.rstudio.com/articles_intro.html) (✔️)

1. ["Una herramienta para integrar prosa, código y resultados."](https://r4ds.had.co.nz/communicate-intro.html) (✔️)

1. ["Un documento computacional."](http://radar.oreilly.com/2011/07/wolframs-computational-documen.html) (✔️)

1. Hechicería. (🧙‍♂️)



---

background-image: url(img/rmarkdown_wizards.png)
background-size: contain

---


class: inverse, middle, center

# Por qué R-Markdown?

---
class: bottom, center
background-image: url(https://media.giphy.com/media/11fDMHAzihB8D6/source.gif)

# `Crisis de reproducibilidad?` 

---

class: middle, center

# Cambia tu modelo mental

.pull-left[

### Source &amp;harr; output

&lt;img src="img/word.png" width="50%" /&gt;

]

.pull-right[

### Source &amp;rarr; output

&lt;img src="img/rmd-file.png" width="50%" /&gt;

]



---
class: middle, center

# Cambia tu modelo mental

.pull-left[

### Source &amp;harr; output

&lt;img src="img/haba-elise.jpg" width="50%" /&gt;

]

.pull-right[

### Source &amp;rarr; output

&lt;img src="img/doll.png" width="50%" /&gt;

]

---

class: middle, inverse, center

# Misma ~~Muñeca~~ Fuente

--

# Diferente ~~Vestido~~ Salida


---


class: middle, center

# `html_document`

&lt;img src="img/doll.png" width="40%" /&gt;


---
class: middle, center

# Qué hay adentro?

![](img/doc-make.jpg)


---
name: card0
background-image: url(img/card0.png)
background-size: contain


---
name: card1
background-image: url(img/card1.png)
background-size: contain

---


# Guarda las opciones de la salida en el YAML

.pull-left[

```yaml
---
author: Your name here
title: Your title here
output: html_document
---
```

```yaml
---
author: Your name here
title: Your title here
output:
  html_document:
    toc: true
    toc_float: true
    theme: flatly
---
```


]

.pull-right[

&lt;img src="img/orchestra.jpg" width="75%" style="display: block; margin: auto;" /&gt;

]


---
background-image: url(img/Single-rmd.png)
background-size: contain

---
background-image: url(img/Single-rmd1.png)
background-size: contain

---
background-image: url(img/Single-rmd2.png)
background-size: contain

---
background-image: url(img/Single-rmd3.png)
background-size: contain

---
class: middle center
background-image: url(img/Single-knit1.png)
background-size: contain

--

&lt;img src="img/Single-knit2.png" style="
  position: absolute; 
  width: 91%; 
  top: -53px;
  right: 5px;
"&gt;

--

&lt;img src="img/Single-knit3.png" style="
  position: absolute; 
  width: 97%; 
  top: -45px;
  right: -51px;
"&gt;

---


# Formatos de salida

.center[

&lt;a href="https://rmarkdown.rstudio.com/docs/reference/index.html#section-output-formats" target="_blank"&gt;&lt;img src="img/rmdbase-formats.png" width="40%" /&gt;&lt;/a&gt;

]

https://rmarkdown.rstudio.com/docs/reference/index.html#section-output-formats

---

class: middle, center

# Formatos de extensión de salida


&lt;img src="https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/flexdashboard.png" width="32%" /&gt;&lt;img src="https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/bookdown.png" width="32%" /&gt;&lt;img src="https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/xaringan.png" width="32%" /&gt;

---



# &lt;center&gt;Headers&lt;/center&gt;

--

.pull-left[
```markdown
# HEADER 1

## HEADER 2

### HEADER 3

#### HEADER 4

##### HEADER 5

###### HEADER 6
```
]

--

.pull-right[
# HEADER 1

## HEADER 2

### HEADER 3

#### HEADER 4

##### HEADER 5

###### HEADER 6
]

---

![](img/rmd-nav.png)

---

# &lt;center&gt;Text&lt;/center&gt;

--

.pull-left[
```markdown
Childhood **vaccines**  
are one of the  
_great triumphs_  
of modern medicine. 
```
]

--

.pull-right[

Childhood **vaccines**  
are one of the  
_great triumphs_  
of modern medicine. 

]

---
class: top

# &lt;center&gt;Lists&lt;/center&gt;

--

.pull-left[

```markdown
Indeed, parents whose children are  
vaccinated no longer have to worry about  
their child's death or disability from:

- whooping cough, 
- polio, 
- diphtheria, 
- hepatitis, or 
- a host of other infections.

Vaccines are the most cost-effective health  
care interventions there are. We have   
three new, extremely effective vaccines to  
roll out in developing countries:  

1. pneumonia
1. rotavirus
1. meningitis A
```

]

--

.pull-right[

Indeed, parents whose children are  
vaccinated no longer have to worry about  
their child's death or disability from:

- whooping cough, 
- polio, 
- diphtheria, 
- hepatitis, or 
- a host of other infections.

Vaccines are the most cost-effective health  
care interventions there are. We have  
three new, extremely effective vaccines to  
roll out in developing countries:

1. pneumonia
1. rotavirus
1. meningitis A

]

---

# &lt;center&gt;Images&lt;/center&gt;

--

```markdown
Edificio E56 - Universidad del Valle
![](http://industrial.univalle.edu.co/images/la_escuela/presentacion/ESCUELA_20181001.jpg)
```


--


Edificio E56 - Universidad del Valle
![](http://industrial.univalle.edu.co/images/la_escuela/presentacion/ESCUELA_20181001.jpg)


---

# &lt;center&gt;Links&lt;/center&gt;

--


```markdown
[Photo](http://industrial.univalle.edu.co/images/la_escuela/presentacion/ESCUELA_20181001.jpg)

Edificio E56 - Universidad del Valle
![](http://industrial.univalle.edu.co/images/la_escuela/presentacion/ESCUELA_20181001.jpg)
```


--


[Photo](http://industrial.univalle.edu.co/images/la_escuela/presentacion/ESCUELA_20181001.jpg)

Edificio E56 - Universidad del Valle
![](http://industrial.univalle.edu.co/images/la_escuela/presentacion/ESCUELA_20181001.jpg)


---

# Chunk


Una vez que controlamos como poner títulos, subtítulos y cabeceras y texto, podemos incluir análisis y resultados de R en el informe o tablero. Para ello debemos escribir el codigo de R entre una cabecera y pie que permite interpretar la sintáxis de `R` incluyendo un trozo o `chunk`:


.pull-left[

````
```{r}

x &lt;- 3 + 4


```
````

Este es un ejemplo de **chunk**
]


.pull-right[

&lt;img src="img/chunk.png" width="50%" /&gt;

]

---

# Opciones de los chunk


La salida de chunk se puede personalizar con las opciones de a traves de argumentos establecidos.En la Guía de referencia de R Markdown se encuentra una lista completa de las opciones de los chunk. Los argumentos más comunes son los siguientes:



* **include = FALSE** evita que el código y los resultados aparezcan en el archivo terminado. R Markdown todavía ejecuta el código en el fragmento, y los resultados pueden ser utilizados por otros fragmentos. echo = FALSE impide el código, pero no aparecen los resultados en el archivo terminado. Esta es una forma útil de incrustar figuras.
* **message = FALSE** evita que los mensajes generados por el código aparezcan en el archivo terminado.
* **warning = FALSE** evita que las advertencias generadas por el código aparezcan en el final.
* **fig.cap = "..."** agrega un título a los resultados gráficos.




---

# message / warning



![](https://www.tidyverse.org/images/tidyverse_1.2.0/tidyverse_1-2-0_pkg_load.gif)



---

# message / warning

.pull-left[

````
```{r message=FALSE, warning=FALSE}
library(tidyverse)
```
````

]

.pull-right[


```r
library(tidyverse)
```

]


# Websites!

---
class: middle

.left-column[
# 🔗
]

.right-column[

&lt;a href="https://rmarkdown.rstudio.com/" target="_blank"&gt;&lt;img src="img/rmarkdown-site.png" width="80%" /&gt;&lt;/a&gt;
]

.footnote[https://rmarkdown.rstudio.com/]

---
class: middle

.left-column[
# 🔗
]

.right-column[

&lt;a href="https://rmarkdown.rstudio.com/docs/" target="_blank"&gt;&lt;img src="img/rmarkdowndocs-site.png" width="80%" /&gt;&lt;/a&gt;
]

.footnote[https://rmarkdown.rstudio.com/docs/]

---
class: middle

.left-column[
# 🎯
]

.right-column[

&lt;a href="https://community.rstudio.com/c/R-Markdown" target="_blank"&gt;&lt;img src="img/rmarkdowncommunity-site.png" width="80%" /&gt;&lt;/a&gt;
]

.footnote[https://community.rstudio.com/c/R-Markdown]

---
class: middle

.left-column[
# 🤖
]

.right-column[

&lt;a href="https://rmarkdown.rstudio.com/lesson-6.html" target="_blank"&gt;&lt;img src="https://raw.githubusercontent.com/rstudio/rmarkdown/gh-pages/lesson-images/params-1-hawaii.png" width="80%" /&gt;&lt;/a&gt;
]

.footnote[https://bookdown.org/yihui/rmarkdown/parameterized-reports.html,&lt;br&gt;
https://rmarkdown.rstudio.com/lesson-6.html]


---
class: inverse, middle, center

# Thank you!







































    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"slideNumberFormat": "%current%",
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:9",
"countIncrementalSlides": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
